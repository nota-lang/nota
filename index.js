var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var ReactVersion = "17.0.2";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports.Fragment = 60107;
        exports.StrictMode = 60108;
        exports.Profiler = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        exports.Suspense = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports.Fragment = symbolFor("react.fragment");
          exports.StrictMode = symbolFor("react.strict_mode");
          exports.Profiler = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          exports.Suspense = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: 0
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          assign: _assign
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        }
        function warn(format) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
        function error(format) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case exports.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case exports.Profiler:
              return "Profiler";
            case exports.StrictMode:
              return "StrictMode";
            case exports.Suspense:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentName(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            return escape("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext2(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
              if (payload._status === Pending) {
                var defaultExport = moduleObject.default;
                {
                  if (defaultExport === void 0) {
                    error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                  }
                }
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = defaultExport;
              }
            }, function(error2) {
              if (payload._status === Pending) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
          }
          if (payload._status === Resolved) {
            return payload._result;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: -1,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (render.displayName == null) {
                  render.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        var enableScopeAPI = false;
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare2) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare2 === void 0 ? null : compare2
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (type.displayName == null) {
                  type.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext6(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState4(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef2(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect3(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case exports.Suspense:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name2 = getComponentName(ReactCurrentOwner.current.type);
            if (name2) {
              return "\n\nCheck the render method of `" + name2 + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name2 = getComponentName(type);
              checkPropTypes(propTypes, element.props, "prop", name2, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === exports.Fragment) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            new Map([[frozenObject, null]]);
            new Set([frozenObject]);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.PureComponent = PureComponent;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext2;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback;
        exports.useContext = useContext6;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect3;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef2;
        exports.useState = useState4;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var requestHostCallback;
        var requestHostTimeout;
        var cancelHostTimeout;
        var requestPaint;
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        if (typeof window === "undefined" || typeof MessageChannel !== "function") {
          var _callback = null;
          var _timeoutID = null;
          var _flushCallback = function() {
            if (_callback !== null) {
              try {
                var currentTime = exports.unstable_now();
                var hasRemainingTime = true;
                _callback(hasRemainingTime, currentTime);
                _callback = null;
              } catch (e) {
                setTimeout(_flushCallback, 0);
                throw e;
              }
            }
          };
          requestHostCallback = function(cb) {
            if (_callback !== null) {
              setTimeout(requestHostCallback, 0, cb);
            } else {
              _callback = cb;
              setTimeout(_flushCallback, 0);
            }
          };
          requestHostTimeout = function(cb, ms) {
            _timeoutID = setTimeout(cb, ms);
          };
          cancelHostTimeout = function() {
            clearTimeout(_timeoutID);
          };
          exports.unstable_shouldYield = function() {
            return false;
          };
          requestPaint = exports.unstable_forceFrameRate = function() {
          };
        } else {
          var _setTimeout = window.setTimeout;
          var _clearTimeout = window.clearTimeout;
          if (typeof console !== "undefined") {
            var requestAnimationFrame2 = window.requestAnimationFrame;
            var cancelAnimationFrame2 = window.cancelAnimationFrame;
            if (typeof requestAnimationFrame2 !== "function") {
              console["error"]("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
            if (typeof cancelAnimationFrame2 !== "function") {
              console["error"]("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var taskTimeoutID = -1;
          var yieldInterval = 5;
          var deadline = 0;
          {
            exports.unstable_shouldYield = function() {
              return exports.unstable_now() >= deadline;
            };
            requestPaint = function() {
            };
          }
          exports.unstable_forceFrameRate = function(fps) {
            if (fps < 0 || fps > 125) {
              console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
              return;
            }
            if (fps > 0) {
              yieldInterval = Math.floor(1e3 / fps);
            } else {
              yieldInterval = 5;
            }
          };
          var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
              var currentTime = exports.unstable_now();
              deadline = currentTime + yieldInterval;
              var hasTimeRemaining = true;
              try {
                var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                if (!hasMoreWork) {
                  isMessageLoopRunning = false;
                  scheduledHostCallback = null;
                } else {
                  port.postMessage(null);
                }
              } catch (error) {
                port.postMessage(null);
                throw error;
              }
            } else {
              isMessageLoopRunning = false;
            }
          };
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          requestHostCallback = function(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
              isMessageLoopRunning = true;
              port.postMessage(null);
            }
          };
          requestHostTimeout = function(callback, ms) {
            taskTimeoutID = _setTimeout(function() {
              callback(exports.unstable_now());
            }, ms);
          };
          cancelHostTimeout = function() {
            _clearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          };
        }
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          siftUp(heap, node, index);
        }
        function peek(heap) {
          var first = heap[0];
          return first === void 0 ? null : first;
        }
        function pop(heap) {
          var first = heap[0];
          if (first !== void 0) {
            var last = heap.pop();
            if (last !== first) {
              heap[0] = last;
              siftDown(heap, last, 0);
            }
            return first;
          } else {
            return null;
          }
        }
        function siftUp(heap, node, i) {
          var index = i;
          while (true) {
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (parent !== void 0 && compare2(parent, node) > 0) {
              heap[parentIndex] = node;
              heap[index] = parent;
              index = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i) {
          var index = i;
          var length = heap.length;
          while (index < length) {
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (left !== void 0 && compare2(left, node) < 0) {
              if (right !== void 0 && compare2(right, left) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                heap[index] = left;
                heap[leftIndex] = node;
                index = leftIndex;
              }
            } else if (right !== void 0 && compare2(right, node) < 0) {
              heap[index] = right;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare2(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a.id - b.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms) {
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime = currentTime + delay;
            } else {
              startTime = currentTime;
            }
          } else {
            startTime = currentTime;
          }
          var timeout;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime,
            expirationTime,
            sortIndex: -1
          };
          if (startTime > currentTime) {
            newTask.sortIndex = startTime;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_wrapCallback = unstable_wrapCallback;
      })();
    }
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_development();
    }
  }
});

// node_modules/scheduler/cjs/scheduler-tracing.development.js
var require_scheduler_tracing_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler-tracing.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var DEFAULT_THREAD_ID = 0;
        var interactionIDCounter = 0;
        var threadIDCounter = 0;
        exports.__interactionsRef = null;
        exports.__subscriberRef = null;
        {
          exports.__interactionsRef = {
            current: new Set()
          };
          exports.__subscriberRef = {
            current: null
          };
        }
        function unstable_clear(callback) {
          var prevInteractions = exports.__interactionsRef.current;
          exports.__interactionsRef.current = new Set();
          try {
            return callback();
          } finally {
            exports.__interactionsRef.current = prevInteractions;
          }
        }
        function unstable_getCurrent() {
          {
            return exports.__interactionsRef.current;
          }
        }
        function unstable_getThreadID() {
          return ++threadIDCounter;
        }
        function unstable_trace(name2, timestamp, callback) {
          var threadID = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : DEFAULT_THREAD_ID;
          var interaction = {
            __count: 1,
            id: interactionIDCounter++,
            name: name2,
            timestamp
          };
          var prevInteractions = exports.__interactionsRef.current;
          var interactions = new Set(prevInteractions);
          interactions.add(interaction);
          exports.__interactionsRef.current = interactions;
          var subscriber = exports.__subscriberRef.current;
          var returnValue;
          try {
            if (subscriber !== null) {
              subscriber.onInteractionTraced(interaction);
            }
          } finally {
            try {
              if (subscriber !== null) {
                subscriber.onWorkStarted(interactions, threadID);
              }
            } finally {
              try {
                returnValue = callback();
              } finally {
                exports.__interactionsRef.current = prevInteractions;
                try {
                  if (subscriber !== null) {
                    subscriber.onWorkStopped(interactions, threadID);
                  }
                } finally {
                  interaction.__count--;
                  if (subscriber !== null && interaction.__count === 0) {
                    subscriber.onInteractionScheduledWorkCompleted(interaction);
                  }
                }
              }
            }
          }
          return returnValue;
        }
        function unstable_wrap(callback) {
          var threadID = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_THREAD_ID;
          var wrappedInteractions = exports.__interactionsRef.current;
          var subscriber = exports.__subscriberRef.current;
          if (subscriber !== null) {
            subscriber.onWorkScheduled(wrappedInteractions, threadID);
          }
          wrappedInteractions.forEach(function(interaction) {
            interaction.__count++;
          });
          var hasRun = false;
          function wrapped() {
            var prevInteractions = exports.__interactionsRef.current;
            exports.__interactionsRef.current = wrappedInteractions;
            subscriber = exports.__subscriberRef.current;
            try {
              var returnValue;
              try {
                if (subscriber !== null) {
                  subscriber.onWorkStarted(wrappedInteractions, threadID);
                }
              } finally {
                try {
                  returnValue = callback.apply(void 0, arguments);
                } finally {
                  exports.__interactionsRef.current = prevInteractions;
                  if (subscriber !== null) {
                    subscriber.onWorkStopped(wrappedInteractions, threadID);
                  }
                }
              }
              return returnValue;
            } finally {
              if (!hasRun) {
                hasRun = true;
                wrappedInteractions.forEach(function(interaction) {
                  interaction.__count--;
                  if (subscriber !== null && interaction.__count === 0) {
                    subscriber.onInteractionScheduledWorkCompleted(interaction);
                  }
                });
              }
            }
          }
          wrapped.cancel = function cancel() {
            subscriber = exports.__subscriberRef.current;
            try {
              if (subscriber !== null) {
                subscriber.onWorkCanceled(wrappedInteractions, threadID);
              }
            } finally {
              wrappedInteractions.forEach(function(interaction) {
                interaction.__count--;
                if (subscriber && interaction.__count === 0) {
                  subscriber.onInteractionScheduledWorkCompleted(interaction);
                }
              });
            }
          };
          return wrapped;
        }
        var subscribers = null;
        {
          subscribers = new Set();
        }
        function unstable_subscribe(subscriber) {
          {
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
              exports.__subscriberRef.current = {
                onInteractionScheduledWorkCompleted,
                onInteractionTraced,
                onWorkCanceled,
                onWorkScheduled,
                onWorkStarted,
                onWorkStopped
              };
            }
          }
        }
        function unstable_unsubscribe(subscriber) {
          {
            subscribers.delete(subscriber);
            if (subscribers.size === 0) {
              exports.__subscriberRef.current = null;
            }
          }
        }
        function onInteractionTraced(interaction) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function(subscriber) {
            try {
              subscriber.onInteractionTraced(interaction);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        function onInteractionScheduledWorkCompleted(interaction) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function(subscriber) {
            try {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        function onWorkScheduled(interactions, threadID) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function(subscriber) {
            try {
              subscriber.onWorkScheduled(interactions, threadID);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        function onWorkStarted(interactions, threadID) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function(subscriber) {
            try {
              subscriber.onWorkStarted(interactions, threadID);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        function onWorkStopped(interactions, threadID) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function(subscriber) {
            try {
              subscriber.onWorkStopped(interactions, threadID);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        function onWorkCanceled(interactions, threadID) {
          var didCatchError = false;
          var caughtError = null;
          subscribers.forEach(function(subscriber) {
            try {
              subscriber.onWorkCanceled(interactions, threadID);
            } catch (error) {
              if (!didCatchError) {
                didCatchError = true;
                caughtError = error;
              }
            }
          });
          if (didCatchError) {
            throw caughtError;
          }
        }
        exports.unstable_clear = unstable_clear;
        exports.unstable_getCurrent = unstable_getCurrent;
        exports.unstable_getThreadID = unstable_getThreadID;
        exports.unstable_subscribe = unstable_subscribe;
        exports.unstable_trace = unstable_trace;
        exports.unstable_unsubscribe = unstable_unsubscribe;
        exports.unstable_wrap = unstable_wrap;
      })();
    }
  }
});

// node_modules/scheduler/tracing.js
var require_tracing = __commonJS({
  "node_modules/scheduler/tracing.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_tracing_development();
    }
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React8 = require_react();
        var _assign = require_object_assign();
        var Scheduler = require_scheduler();
        var tracing = require_tracing();
        var ReactSharedInternals = React8.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
        function error(format) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        if (!React8) {
          {
            throw Error("ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.");
          }
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var IndeterminateComponent = 2;
        var HostRoot = 3;
        var HostPortal = 4;
        var HostComponent = 5;
        var HostText = 6;
        var Fragment = 7;
        var Mode = 8;
        var ContextConsumer = 9;
        var ContextProvider = 10;
        var ForwardRef = 11;
        var Profiler = 12;
        var SuspenseComponent = 13;
        var MemoComponent = 14;
        var SimpleMemoComponent = 15;
        var LazyComponent = 16;
        var IncompleteClassComponent = 17;
        var DehydratedFragment = 18;
        var SuspenseListComponent = 19;
        var FundamentalComponent = 20;
        var ScopeComponent = 21;
        var Block = 22;
        var OffscreenComponent = 23;
        var LegacyHiddenComponent = 24;
        var enableProfilerTimer = true;
        var enableFundamentalAPI = false;
        var enableNewReconciler = false;
        var warnAboutStringRefs = false;
        var allNativeEvents = new Set();
        var registrationNameDependencies = {};
        var possibleRegistrationNames = {};
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          {
            if (registrationNameDependencies[registrationName]) {
              error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
            }
          }
          registrationNameDependencies[registrationName] = dependencies;
          {
            var lowerCasedName = registrationName.toLowerCase();
            possibleRegistrationNames[lowerCasedName] = registrationName;
            if (registrationName === "onDoubleClick") {
              possibleRegistrationNames.ondblclick = registrationName;
            }
          }
          for (var i = 0; i < dependencies.length; i++) {
            allNativeEvents.add(dependencies[i]);
          }
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var ROOT_ATTRIBUTE_NAME = "data-reactroot";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name2.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name2) {
          return properties.hasOwnProperty(name2) ? properties[name2] : null;
        }
        function PropertyInfoRecord(name2, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name2;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(name2, RESERVED, false, name2, null, false, false);
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name2 = _ref[0], attributeName = _ref[1];
          properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, null, false, false);
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(name2, BOOLEANISH_STRING, false, name2.toLowerCase(), null, false, false);
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(name2, BOOLEANISH_STRING, false, name2, null, false, false);
        });
        [
          "allowFullScreen",
          "async",
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          "itemScope"
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(name2, BOOLEAN, false, name2.toLowerCase(), null, false, false);
        });
        [
          "checked",
          "multiple",
          "muted",
          "selected"
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(name2, BOOLEAN, true, name2, null, false, false);
        });
        [
          "capture",
          "download"
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(name2, OVERLOADED_BOOLEAN, false, name2, null, false, false);
        });
        [
          "cols",
          "rows",
          "size",
          "span"
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(name2, POSITIVE_NUMERIC, false, name2, null, false, false);
        });
        ["rowSpan", "start"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(name2, NUMERIC, false, name2.toLowerCase(), null, false, false);
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize);
          properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, null, false, false);
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize);
          properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize);
          properties[name2] = new PropertyInfoRecord(name2, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        function getValueForProperty(node, name2, expected, propertyInfo) {
          {
            if (propertyInfo.mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              return node[propertyName];
            } else {
              if (propertyInfo.sanitizeURL) {
                sanitizeURL("" + expected);
              }
              var attributeName = propertyInfo.attributeName;
              var stringValue = null;
              if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                if (node.hasAttribute(attributeName)) {
                  var value = node.getAttribute(attributeName);
                  if (value === "") {
                    return true;
                  }
                  if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                    return value;
                  }
                  if (value === "" + expected) {
                    return expected;
                  }
                  return value;
                }
              } else if (node.hasAttribute(attributeName)) {
                if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                  return node.getAttribute(attributeName);
                }
                if (propertyInfo.type === BOOLEAN) {
                  return expected;
                }
                stringValue = node.getAttribute(attributeName);
              }
              if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                return stringValue === null ? expected : stringValue;
              } else if (stringValue === "" + expected) {
                return expected;
              } else {
                return stringValue;
              }
            }
          }
        }
        function getValueForAttribute(node, name2, expected) {
          {
            if (!isAttributeNameSafe(name2)) {
              return;
            }
            if (isOpaqueHydratingObject(expected)) {
              return expected;
            }
            if (!node.hasAttribute(name2)) {
              return expected === void 0 ? void 0 : null;
            }
            var value = node.getAttribute(name2);
            if (value === "" + expected) {
              return expected;
            }
            return value;
          }
        }
        function setValueForProperty(node, name2, value, isCustomComponentTag) {
          var propertyInfo = getPropertyInfo(name2);
          if (shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag)) {
            return;
          }
          if (shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag)) {
            value = null;
          }
          if (isCustomComponentTag || propertyInfo === null) {
            if (isAttributeNameSafe(name2)) {
              var _attributeName = name2;
              if (value === null) {
                node.removeAttribute(_attributeName);
              } else {
                node.setAttribute(_attributeName, "" + value);
              }
            }
            return;
          }
          var mustUseProperty = propertyInfo.mustUseProperty;
          if (mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            if (value === null) {
              var type = propertyInfo.type;
              node[propertyName] = type === BOOLEAN ? false : "";
            } else {
              node[propertyName] = value;
            }
            return;
          }
          var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
          if (value === null) {
            node.removeAttribute(attributeName);
          } else {
            var _type = propertyInfo.type;
            var attributeValue;
            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
              attributeValue = "";
            } else {
              {
                attributeValue = "" + value;
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL(attributeValue.toString());
              }
            }
            if (attributeNamespace) {
              node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
            } else {
              node.setAttribute(attributeName, attributeValue);
            }
          }
        }
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        function describeFiber(fiber) {
          var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
          var source = fiber._debugSource;
          switch (fiber.tag) {
            case HostComponent:
              return describeBuiltInComponentFrame(fiber.type);
            case LazyComponent:
              return describeBuiltInComponentFrame("Lazy");
            case SuspenseComponent:
              return describeBuiltInComponentFrame("Suspense");
            case SuspenseListComponent:
              return describeBuiltInComponentFrame("SuspenseList");
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
              return describeFunctionComponentFrame(fiber.type);
            case ForwardRef:
              return describeFunctionComponentFrame(fiber.type.render);
            case Block:
              return describeFunctionComponentFrame(fiber.type._render);
            case ClassComponent:
              return describeClassComponentFrame(fiber.type);
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            var node = workInProgress2;
            do {
              info += describeFiber(node);
              node = node.return;
            } while (node);
            return info;
          } catch (x) {
            return "\nError generating stack: " + x.message + "\n" + x.stack;
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentName(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var current = null;
        var isRendering = false;
        function getCurrentFiberOwnerNameInDevOrNull() {
          {
            if (current === null) {
              return null;
            }
            var owner = current._debugOwner;
            if (owner !== null && typeof owner !== "undefined") {
              return getComponentName(owner.type);
            }
          }
          return null;
        }
        function getCurrentFiberStackInDev() {
          {
            if (current === null) {
              return "";
            }
            return getStackByFiberInDevAndProd(current);
          }
        }
        function resetCurrentFiber() {
          {
            ReactDebugCurrentFrame.getCurrentStack = null;
            current = null;
            isRendering = false;
          }
        }
        function setCurrentFiber(fiber) {
          {
            ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
            current = fiber;
            isRendering = false;
          }
        }
        function setIsRendering(rendering) {
          {
            isRendering = rendering;
          }
        }
        function getIsRendering() {
          {
            return isRendering;
          }
        }
        function toString(value) {
          return "" + value;
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "boolean":
            case "number":
            case "object":
            case "string":
            case "undefined":
              return value;
            default:
              return "";
          }
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
        }
        function getTracker(node) {
          return node._valueTracker;
        }
        function detachTracker(node) {
          node._valueTracker = null;
        }
        function getValueFromNode(node) {
          var value = "";
          if (!node) {
            return value;
          }
          if (isCheckable(node)) {
            value = node.checked ? "true" : "false";
          } else {
            value = node.value;
          }
          return value;
        }
        function trackValueOnNode(node) {
          var valueField = isCheckable(node) ? "checked" : "value";
          var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
          var currentValue = "" + node[valueField];
          if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
            return;
          }
          var get2 = descriptor.get, set2 = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get2.call(this);
            },
            set: function(value) {
              currentValue = "" + value;
              set2.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          var tracker = {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              detachTracker(node);
              delete node[valueField];
            }
          };
          return tracker;
        }
        function track(node) {
          if (getTracker(node)) {
            return;
          }
          node._valueTracker = trackValueOnNode(node);
        }
        function updateValueIfChanged(node) {
          if (!node) {
            return false;
          }
          var tracker = getTracker(node);
          if (!tracker) {
            return true;
          }
          var lastValue = tracker.getValue();
          var nextValue = getValueFromNode(node);
          if (nextValue !== lastValue) {
            tracker.setValue(nextValue);
            return true;
          }
          return false;
        }
        function getActiveElement(doc2) {
          doc2 = doc2 || (typeof document !== "undefined" ? document : void 0);
          if (typeof doc2 === "undefined") {
            return null;
          }
          try {
            return doc2.activeElement || doc2.body;
          } catch (e) {
            return doc2.body;
          }
        }
        var didWarnValueDefaultValue = false;
        var didWarnCheckedDefaultChecked = false;
        var didWarnControlledToUncontrolled = false;
        var didWarnUncontrolledToControlled = false;
        function isControlled(props) {
          var usesChecked = props.type === "checkbox" || props.type === "radio";
          return usesChecked ? props.checked != null : props.value != null;
        }
        function getHostProps(element, props) {
          var node = element;
          var checked = props.checked;
          var hostProps = _assign({}, props, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: checked != null ? checked : node._wrapperState.initialChecked
          });
          return hostProps;
        }
        function initWrapperState(element, props) {
          {
            checkControlledValueProps("input", props);
            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
              error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnCheckedDefaultChecked = true;
            }
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
              error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
              didWarnValueDefaultValue = true;
            }
          }
          var node = element;
          var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
          node._wrapperState = {
            initialChecked: props.checked != null ? props.checked : props.defaultChecked,
            initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
            controlled: isControlled(props)
          };
        }
        function updateChecked(element, props) {
          var node = element;
          var checked = props.checked;
          if (checked != null) {
            setValueForProperty(node, "checked", checked, false);
          }
        }
        function updateWrapper(element, props) {
          var node = element;
          {
            var controlled = isControlled(props);
            if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
              error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnUncontrolledToControlled = true;
            }
            if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
              error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnControlledToUncontrolled = true;
            }
          }
          updateChecked(element, props);
          var value = getToStringValue(props.value);
          var type = props.type;
          if (value != null) {
            if (type === "number") {
              if (value === 0 && node.value === "" || node.value != value) {
                node.value = toString(value);
              }
            } else if (node.value !== toString(value)) {
              node.value = toString(value);
            }
          } else if (type === "submit" || type === "reset") {
            node.removeAttribute("value");
            return;
          }
          {
            if (props.hasOwnProperty("value")) {
              setDefaultValue(node, props.type, value);
            } else if (props.hasOwnProperty("defaultValue")) {
              setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
            }
          }
          {
            if (props.checked == null && props.defaultChecked != null) {
              node.defaultChecked = !!props.defaultChecked;
            }
          }
        }
        function postMountWrapper(element, props, isHydrating2) {
          var node = element;
          if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
            var type = props.type;
            var isButton = type === "submit" || type === "reset";
            if (isButton && (props.value === void 0 || props.value === null)) {
              return;
            }
            var initialValue = toString(node._wrapperState.initialValue);
            if (!isHydrating2) {
              {
                if (initialValue !== node.value) {
                  node.value = initialValue;
                }
              }
            }
            {
              node.defaultValue = initialValue;
            }
          }
          var name2 = node.name;
          if (name2 !== "") {
            node.name = "";
          }
          {
            node.defaultChecked = !node.defaultChecked;
            node.defaultChecked = !!node._wrapperState.initialChecked;
          }
          if (name2 !== "") {
            node.name = name2;
          }
        }
        function restoreControlledState(element, props) {
          var node = element;
          updateWrapper(node, props);
          updateNamedCousins(node, props);
        }
        function updateNamedCousins(rootNode, props) {
          var name2 = props.name;
          if (props.type === "radio" && name2 != null) {
            var queryRoot = rootNode;
            while (queryRoot.parentNode) {
              queryRoot = queryRoot.parentNode;
            }
            var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name2) + '][type="radio"]');
            for (var i = 0; i < group.length; i++) {
              var otherNode = group[i];
              if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                continue;
              }
              var otherProps = getFiberCurrentPropsFromNode(otherNode);
              if (!otherProps) {
                {
                  throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                }
              }
              updateValueIfChanged(otherNode);
              updateWrapper(otherNode, otherProps);
            }
          }
        }
        function setDefaultValue(node, type, value) {
          if (type !== "number" || getActiveElement(node.ownerDocument) !== node) {
            if (value == null) {
              node.defaultValue = toString(node._wrapperState.initialValue);
            } else if (node.defaultValue !== toString(value)) {
              node.defaultValue = toString(value);
            }
          }
        }
        var didWarnSelectedSetOnOption = false;
        var didWarnInvalidChild = false;
        function flattenChildren(children) {
          var content2 = "";
          React8.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content2 += child;
          });
          return content2;
        }
        function validateProps(element, props) {
          {
            if (typeof props.children === "object" && props.children !== null) {
              React8.Children.forEach(props.children, function(child) {
                if (child == null) {
                  return;
                }
                if (typeof child === "string" || typeof child === "number") {
                  return;
                }
                if (typeof child.type !== "string") {
                  return;
                }
                if (!didWarnInvalidChild) {
                  didWarnInvalidChild = true;
                  error("Only strings and numbers are supported as <option> children.");
                }
              });
            }
            if (props.selected != null && !didWarnSelectedSetOnOption) {
              error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
              didWarnSelectedSetOnOption = true;
            }
          }
        }
        function postMountWrapper$1(element, props) {
          if (props.value != null) {
            element.setAttribute("value", toString(getToStringValue(props.value)));
          }
        }
        function getHostProps$1(element, props) {
          var hostProps = _assign({
            children: void 0
          }, props);
          var content2 = flattenChildren(props.children);
          if (content2) {
            hostProps.children = content2;
          }
          return hostProps;
        }
        var didWarnValueDefaultValue$1;
        {
          didWarnValueDefaultValue$1 = false;
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          if (ownerName) {
            return "\n\nCheck the render method of `" + ownerName + "`.";
          }
          return "";
        }
        var valuePropNames = ["value", "defaultValue"];
        function checkSelectPropTypes(props) {
          {
            checkControlledValueProps("select", props);
            for (var i = 0; i < valuePropNames.length; i++) {
              var propName = valuePropNames[i];
              if (props[propName] == null) {
                continue;
              }
              var isArray2 = Array.isArray(props[propName]);
              if (props.multiple && !isArray2) {
                error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
              } else if (!props.multiple && isArray2) {
                error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
              }
            }
          }
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          var options2 = node.options;
          if (multiple) {
            var selectedValues = propValue;
            var selectedValue = {};
            for (var i = 0; i < selectedValues.length; i++) {
              selectedValue["$" + selectedValues[i]] = true;
            }
            for (var _i = 0; _i < options2.length; _i++) {
              var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
              if (options2[_i].selected !== selected) {
                options2[_i].selected = selected;
              }
              if (selected && setDefaultSelected) {
                options2[_i].defaultSelected = true;
              }
            }
          } else {
            var _selectedValue = toString(getToStringValue(propValue));
            var defaultSelected = null;
            for (var _i2 = 0; _i2 < options2.length; _i2++) {
              if (options2[_i2].value === _selectedValue) {
                options2[_i2].selected = true;
                if (setDefaultSelected) {
                  options2[_i2].defaultSelected = true;
                }
                return;
              }
              if (defaultSelected === null && !options2[_i2].disabled) {
                defaultSelected = options2[_i2];
              }
            }
            if (defaultSelected !== null) {
              defaultSelected.selected = true;
            }
          }
        }
        function getHostProps$2(element, props) {
          return _assign({}, props, {
            value: void 0
          });
        }
        function initWrapperState$1(element, props) {
          var node = element;
          {
            checkSelectPropTypes(props);
          }
          node._wrapperState = {
            wasMultiple: !!props.multiple
          };
          {
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
              error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnValueDefaultValue$1 = true;
            }
          }
        }
        function postMountWrapper$2(element, props) {
          var node = element;
          node.multiple = !!props.multiple;
          var value = props.value;
          if (value != null) {
            updateOptions(node, !!props.multiple, value, false);
          } else if (props.defaultValue != null) {
            updateOptions(node, !!props.multiple, props.defaultValue, true);
          }
        }
        function postUpdateWrapper(element, props) {
          var node = element;
          var wasMultiple = node._wrapperState.wasMultiple;
          node._wrapperState.wasMultiple = !!props.multiple;
          var value = props.value;
          if (value != null) {
            updateOptions(node, !!props.multiple, value, false);
          } else if (wasMultiple !== !!props.multiple) {
            if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            } else {
              updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
            }
          }
        }
        function restoreControlledState$1(element, props) {
          var node = element;
          var value = props.value;
          if (value != null) {
            updateOptions(node, !!props.multiple, value, false);
          }
        }
        var didWarnValDefaultVal = false;
        function getHostProps$3(element, props) {
          var node = element;
          if (!(props.dangerouslySetInnerHTML == null)) {
            {
              throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            }
          }
          var hostProps = _assign({}, props, {
            value: void 0,
            defaultValue: void 0,
            children: toString(node._wrapperState.initialValue)
          });
          return hostProps;
        }
        function initWrapperState$2(element, props) {
          var node = element;
          {
            checkControlledValueProps("textarea", props);
            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
              error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
              didWarnValDefaultVal = true;
            }
          }
          var initialValue = props.value;
          if (initialValue == null) {
            var children = props.children, defaultValue = props.defaultValue;
            if (children != null) {
              {
                error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              {
                if (!(defaultValue == null)) {
                  {
                    throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                  }
                }
                if (Array.isArray(children)) {
                  if (!(children.length <= 1)) {
                    {
                      throw Error("<textarea> can only have at most one child.");
                    }
                  }
                  children = children[0];
                }
                defaultValue = children;
              }
            }
            if (defaultValue == null) {
              defaultValue = "";
            }
            initialValue = defaultValue;
          }
          node._wrapperState = {
            initialValue: getToStringValue(initialValue)
          };
        }
        function updateWrapper$1(element, props) {
          var node = element;
          var value = getToStringValue(props.value);
          var defaultValue = getToStringValue(props.defaultValue);
          if (value != null) {
            var newValue = toString(value);
            if (newValue !== node.value) {
              node.value = newValue;
            }
            if (props.defaultValue == null && node.defaultValue !== newValue) {
              node.defaultValue = newValue;
            }
          }
          if (defaultValue != null) {
            node.defaultValue = toString(defaultValue);
          }
        }
        function postMountWrapper$3(element, props) {
          var node = element;
          var textContent = node.textContent;
          if (textContent === node._wrapperState.initialValue) {
            if (textContent !== "" && textContent !== null) {
              node.value = textContent;
            }
          }
        }
        function restoreControlledState$2(element, props) {
          updateWrapper$1(element, props);
        }
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var Namespaces = {
          html: HTML_NAMESPACE,
          mathml: MATH_NAMESPACE,
          svg: SVG_NAMESPACE
        };
        function getIntrinsicNamespace(type) {
          switch (type) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type);
          }
          if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var createMicrosoftUnsafeLocalFunction = function(func) {
          if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
            return function(arg0, arg1, arg2, arg3) {
              MSApp.execUnsafeLocalFunction(function() {
                return func(arg0, arg1, arg2, arg3);
              });
            };
          } else {
            return func;
          }
        };
        var reusableSVGContainer;
        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
          if (node.namespaceURI === Namespaces.svg) {
            if (!("innerHTML" in node)) {
              reusableSVGContainer = reusableSVGContainer || document.createElement("div");
              reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
              var svgNode = reusableSVGContainer.firstChild;
              while (node.firstChild) {
                node.removeChild(node.firstChild);
              }
              while (svgNode.firstChild) {
                node.appendChild(svgNode.firstChild);
              }
              return;
            }
          }
          node.innerHTML = html;
        });
        var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;
        var COMMENT_NODE = 8;
        var DOCUMENT_NODE = 9;
        var DOCUMENT_FRAGMENT_NODE = 11;
        var setTextContent = function(node, text) {
          if (text) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
              firstChild.nodeValue = text;
              return;
            }
          }
          node.textContent = text;
        };
        var shorthandToLonghand = {
          animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
          background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
          borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
          borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
          borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
          borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
          borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
          borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
          borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
          borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
          fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
          gap: ["columnGap", "rowGap"],
          grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
          wordWrap: ["overflowWrap"]
        };
        var isUnitlessNumber = {
          animationIterationCount: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name2, value, isCustomProperty) {
          var isEmpty = value == null || typeof value === "boolean" || value === "";
          if (isEmpty) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2])) {
            return value + "px";
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name2) {
          return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string2) {
            return string2.replace(hyphenPattern, function(_4, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name2) {
            if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
              return;
            }
            warnedStyleNames[name2] = true;
            error("Unsupported style property %s. Did you mean %s?", name2, camelize(name2.replace(msPattern$1, "ms-")));
          };
          var warnBadVendoredStyleName = function(name2) {
            if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
              return;
            }
            warnedStyleNames[name2] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name2, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name2, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name2);
          };
          var warnStyleValueIsInfinity = function(name2, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name2);
          };
          warnValidStyle = function(name2, value) {
            if (name2.indexOf("-") > -1) {
              warnHyphenatedStyleName(name2);
            } else if (badVendoredStyleNamePattern.test(name2)) {
              warnBadVendoredStyleName(name2);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name2, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name2, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name2, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        function createDangerousStringForStyles(styles) {
          {
            var serialized = "";
            var delimiter = "";
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var styleValue = styles[styleName];
              if (styleValue != null) {
                var isCustomProperty = styleName.indexOf("--") === 0;
                serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                delimiter = ";";
              }
            }
            return serialized || null;
          }
        }
        function setValueForStyles(node, styles) {
          var style2 = node.style;
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styles[styleName]);
              }
            }
            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
            if (styleName === "float") {
              styleName = "cssFloat";
            }
            if (isCustomProperty) {
              style2.setProperty(styleName, styleValue);
            } else {
              style2[styleName] = styleValue;
            }
          }
        }
        function isValueEmpty(value) {
          return value == null || typeof value === "boolean" || value === "";
        }
        function expandShorthandMap(styles) {
          var expanded = {};
          for (var key in styles) {
            var longhands = shorthandToLonghand[key] || [key];
            for (var i = 0; i < longhands.length; i++) {
              expanded[longhands[i]] = key;
            }
          }
          return expanded;
        }
        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
          {
            if (!nextStyles) {
              return;
            }
            var expandedUpdates = expandShorthandMap(styleUpdates);
            var expandedStyles = expandShorthandMap(nextStyles);
            var warnedAbout = {};
            for (var key in expandedUpdates) {
              var originalKey = expandedUpdates[key];
              var correctOriginalKey = expandedStyles[key];
              if (correctOriginalKey && originalKey !== correctOriginalKey) {
                var warningKey = originalKey + "," + correctOriginalKey;
                if (warnedAbout[warningKey]) {
                  continue;
                }
                warnedAbout[warningKey] = true;
                error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
              }
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        };
        var voidElementTags = _assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
              {
                throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (!(props.children == null)) {
              {
                throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
            }
            if (!(typeof props.dangerouslySetInnerHTML === "object" && HTML in props.dangerouslySetInnerHTML)) {
              {
                throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (!(props.style == null || typeof props.style === "object")) {
            {
              throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var ariaProperties = {
          "aria-current": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        function validateProperty(tagName, name2) {
          {
            if (hasOwnProperty$1.call(warnedProperties, name2) && warnedProperties[name2]) {
              return true;
            }
            if (rARIACamel.test(name2)) {
              var ariaName = "aria-" + name2.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2);
                warnedProperties[name2] = true;
                return true;
              }
              if (name2 !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName);
                warnedProperties[name2] = true;
                return true;
              }
            }
            if (rARIA.test(name2)) {
              var lowerCasedName = name2.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name2] = true;
                return false;
              }
              if (name2 !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName);
                warnedProperties[name2] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name2, value, eventRegistry) {
            if (_hasOwnProperty.call(warnedProperties$1, name2) && warnedProperties$1[name2]) {
              return true;
            }
            var lowerCasedName = name2.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies2.hasOwnProperty(name2)) {
                return true;
              }
              var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName);
                warnedProperties$1[name2] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name2)) {
                error("Unknown event handler property `%s`. It will be ignored.", name2);
                warnedProperties$1[name2] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name2)) {
              if (INVALID_EVENT_NAME_REGEX.test(name2)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2);
              }
              warnedProperties$1[name2] = true;
              return true;
            }
            if (rARIA$1.test(name2) || rARIACamel$1.test(name2)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2);
              warnedProperties$1[name2] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name2);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name2) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName);
                warnedProperties$1[name2] = true;
                return true;
              }
            } else if (!isReserved && name2 !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name2, name2, value, name2);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name2, name2, value, name2, name2, name2);
              }
              warnedProperties$1[name2] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
              warnedProperties$1[name2] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
              warnedProperties$1[name2] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
        var IS_NON_DELEGATED = 1 << 1;
        var IS_CAPTURE_PHASE = 1 << 2;
        var IS_REPLAYED = 1 << 4;
        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
        function getEventTarget(nativeEvent) {
          var target = nativeEvent.target || nativeEvent.srcElement || window;
          if (target.correspondingUseElement) {
            target = target.correspondingUseElement;
          }
          return target.nodeType === TEXT_NODE ? target.parentNode : target;
        }
        var restoreImpl = null;
        var restoreTarget = null;
        var restoreQueue = null;
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (!internalInstance) {
            return;
          }
          if (!(typeof restoreImpl === "function")) {
            {
              throw Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          var stateNode = internalInstance.stateNode;
          if (stateNode) {
            var _props = getFiberCurrentPropsFromNode(stateNode);
            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
          }
        }
        function setRestoreImplementation(impl) {
          restoreImpl = impl;
        }
        function enqueueStateRestore(target) {
          if (restoreTarget) {
            if (restoreQueue) {
              restoreQueue.push(target);
            } else {
              restoreQueue = [target];
            }
          } else {
            restoreTarget = target;
          }
        }
        function needsStateRestore() {
          return restoreTarget !== null || restoreQueue !== null;
        }
        function restoreStateIfNeeded() {
          if (!restoreTarget) {
            return;
          }
          var target = restoreTarget;
          var queuedTargets = restoreQueue;
          restoreTarget = null;
          restoreQueue = null;
          restoreStateOfTarget(target);
          if (queuedTargets) {
            for (var i = 0; i < queuedTargets.length; i++) {
              restoreStateOfTarget(queuedTargets[i]);
            }
          }
        }
        var batchedUpdatesImpl = function(fn, bookkeeping) {
          return fn(bookkeeping);
        };
        var discreteUpdatesImpl = function(fn, a, b, c, d) {
          return fn(a, b, c, d);
        };
        var flushDiscreteUpdatesImpl = function() {
        };
        var batchedEventUpdatesImpl = batchedUpdatesImpl;
        var isInsideEventHandler = false;
        var isBatchingEventUpdates = false;
        function finishEventHandler() {
          var controlledComponentsHavePendingUpdates = needsStateRestore();
          if (controlledComponentsHavePendingUpdates) {
            flushDiscreteUpdatesImpl();
            restoreStateIfNeeded();
          }
        }
        function batchedUpdates(fn, bookkeeping) {
          if (isInsideEventHandler) {
            return fn(bookkeeping);
          }
          isInsideEventHandler = true;
          try {
            return batchedUpdatesImpl(fn, bookkeeping);
          } finally {
            isInsideEventHandler = false;
            finishEventHandler();
          }
        }
        function batchedEventUpdates(fn, a, b) {
          if (isBatchingEventUpdates) {
            return fn(a, b);
          }
          isBatchingEventUpdates = true;
          try {
            return batchedEventUpdatesImpl(fn, a, b);
          } finally {
            isBatchingEventUpdates = false;
            finishEventHandler();
          }
        }
        function discreteUpdates(fn, a, b, c, d) {
          var prevIsInsideEventHandler = isInsideEventHandler;
          isInsideEventHandler = true;
          try {
            return discreteUpdatesImpl(fn, a, b, c, d);
          } finally {
            isInsideEventHandler = prevIsInsideEventHandler;
            if (!isInsideEventHandler) {
              finishEventHandler();
            }
          }
        }
        function flushDiscreteUpdatesIfNeeded(timeStamp) {
          {
            if (!isInsideEventHandler) {
              flushDiscreteUpdatesImpl();
            }
          }
        }
        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {
          batchedUpdatesImpl = _batchedUpdatesImpl;
          discreteUpdatesImpl = _discreteUpdatesImpl;
          flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
          batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
        }
        function isInteractive(tag) {
          return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
        }
        function shouldPreventMouseEvent(name2, type, props) {
          switch (name2) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              return !!(props.disabled && isInteractive(type));
            default:
              return false;
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (stateNode === null) {
            return null;
          }
          var props = getFiberCurrentPropsFromNode(stateNode);
          if (props === null) {
            return null;
          }
          var listener = props[registrationName];
          if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
            return null;
          }
          if (!(!listener || typeof listener === "function")) {
            {
              throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
          }
          return listener;
        }
        var passiveBrowserEventsSupported = false;
        if (canUseDOM) {
          try {
            var options = {};
            Object.defineProperty(options, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
          } catch (e) {
            passiveBrowserEventsSupported = false;
          }
        }
        function invokeGuardedCallbackProd(name2, func, context, a, b, c, d, e, f) {
          var funcArgs = Array.prototype.slice.call(arguments, 3);
          try {
            func.apply(context, funcArgs);
          } catch (error2) {
            this.onError(error2);
          }
        }
        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
        {
          if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
            var fakeNode = document.createElement("react");
            invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name2, func, context, a, b, c, d, e, f) {
              if (!(typeof document !== "undefined")) {
                {
                  throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                }
              }
              var evt = document.createEvent("Event");
              var didCall = false;
              var didError = true;
              var windowEvent = window.event;
              var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
              function restoreAfterDispatch() {
                fakeNode.removeEventListener(evtType, callCallback2, false);
                if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                  window.event = windowEvent;
                }
              }
              var funcArgs = Array.prototype.slice.call(arguments, 3);
              function callCallback2() {
                didCall = true;
                restoreAfterDispatch();
                func.apply(context, funcArgs);
                didError = false;
              }
              var error2;
              var didSetError = false;
              var isCrossOriginError = false;
              function handleWindowError(event) {
                error2 = event.error;
                didSetError = true;
                if (error2 === null && event.colno === 0 && event.lineno === 0) {
                  isCrossOriginError = true;
                }
                if (event.defaultPrevented) {
                  if (error2 != null && typeof error2 === "object") {
                    try {
                      error2._suppressLogging = true;
                    } catch (inner) {
                    }
                  }
                }
              }
              var evtType = "react-" + (name2 ? name2 : "invokeguardedcallback");
              window.addEventListener("error", handleWindowError);
              fakeNode.addEventListener(evtType, callCallback2, false);
              evt.initEvent(evtType, false, false);
              fakeNode.dispatchEvent(evt);
              if (windowEventDescriptor) {
                Object.defineProperty(window, "event", windowEventDescriptor);
              }
              if (didCall && didError) {
                if (!didSetError) {
                  error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                } else if (isCrossOriginError) {
                  error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                }
                this.onError(error2);
              }
              window.removeEventListener("error", handleWindowError);
              if (!didCall) {
                restoreAfterDispatch();
                return invokeGuardedCallbackProd.apply(this, arguments);
              }
            };
          }
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
        var hasError = false;
        var caughtError = null;
        var hasRethrowError = false;
        var rethrowError = null;
        var reporter = {
          onError: function(error2) {
            hasError = true;
            caughtError = error2;
          }
        };
        function invokeGuardedCallback(name2, func, context, a, b, c, d, e, f) {
          hasError = false;
          caughtError = null;
          invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        function invokeGuardedCallbackAndCatchFirstError(name2, func, context, a, b, c, d, e, f) {
          invokeGuardedCallback.apply(this, arguments);
          if (hasError) {
            var error2 = clearCaughtError();
            if (!hasRethrowError) {
              hasRethrowError = true;
              rethrowError = error2;
            }
          }
        }
        function rethrowCaughtError() {
          if (hasRethrowError) {
            var error2 = rethrowError;
            hasRethrowError = false;
            rethrowError = null;
            throw error2;
          }
        }
        function hasCaughtError() {
          return hasError;
        }
        function clearCaughtError() {
          if (hasError) {
            var error2 = caughtError;
            hasError = false;
            caughtError = null;
            return error2;
          } else {
            {
              {
                throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
        }
        function get(key) {
          return key._reactInternals;
        }
        function has(key) {
          return key._reactInternals !== void 0;
        }
        function set(key, value) {
          key._reactInternals = value;
        }
        var NoFlags = 0;
        var PerformedWork = 1;
        var Placement = 2;
        var Update = 4;
        var PlacementAndUpdate = 6;
        var Deletion = 8;
        var ContentReset = 16;
        var Callback = 32;
        var DidCapture = 64;
        var Ref2 = 128;
        var Snapshot = 256;
        var Passive = 512;
        var PassiveUnmountPendingDev = 8192;
        var Hydrating = 1024;
        var HydratingAndUpdate = 1028;
        var LifecycleEffectMask = 932;
        var HostEffectMask = 2047;
        var Incomplete = 2048;
        var ShouldCapture = 4096;
        var ForceUpdateForLegacySuspense = 16384;
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
          var node = fiber;
          var nearestMounted = fiber;
          if (!fiber.alternate) {
            var nextNode = node;
            do {
              node = nextNode;
              if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                nearestMounted = node.return;
              }
              nextNode = node.return;
            } while (nextNode);
          } else {
            while (node.return) {
              node = node.return;
            }
          }
          if (node.tag === HostRoot) {
            return nearestMounted;
          }
          return null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (fiber.tag === SuspenseComponent) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState === null) {
              var current2 = fiber.alternate;
              if (current2 !== null) {
                suspenseState = current2.memoizedState;
              }
            }
            if (suspenseState !== null) {
              return suspenseState.dehydrated;
            }
          }
          return null;
        }
        function getContainerFromFiber(fiber) {
          return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
        }
        function isFiberMounted(fiber) {
          return getNearestMountedFiber(fiber) === fiber;
        }
        function isMounted(component) {
          {
            var owner = ReactCurrentOwner.current;
            if (owner !== null && owner.tag === ClassComponent) {
              var ownerFiber = owner;
              var instance = ownerFiber.stateNode;
              if (!instance._warnedAboutRefsInRender) {
                error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(ownerFiber.type) || "A component");
              }
              instance._warnedAboutRefsInRender = true;
            }
          }
          var fiber = get(component);
          if (!fiber) {
            return false;
          }
          return getNearestMountedFiber(fiber) === fiber;
        }
        function assertIsMounted(fiber) {
          if (!(getNearestMountedFiber(fiber) === fiber)) {
            {
              throw Error("Unable to find node on an unmounted component.");
            }
          }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            var nearestMounted = getNearestMountedFiber(fiber);
            if (!(nearestMounted !== null)) {
              {
                throw Error("Unable to find node on an unmounted component.");
              }
            }
            if (nearestMounted !== fiber) {
              return null;
            }
            return fiber;
          }
          var a = fiber;
          var b = alternate;
          while (true) {
            var parentA = a.return;
            if (parentA === null) {
              break;
            }
            var parentB = parentA.alternate;
            if (parentB === null) {
              var nextParent = parentA.return;
              if (nextParent !== null) {
                a = b = nextParent;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              var child = parentA.child;
              while (child) {
                if (child === a) {
                  assertIsMounted(parentA);
                  return fiber;
                }
                if (child === b) {
                  assertIsMounted(parentA);
                  return alternate;
                }
                child = child.sibling;
              }
              {
                {
                  throw Error("Unable to find node on an unmounted component.");
                }
              }
            }
            if (a.return !== b.return) {
              a = parentA;
              b = parentB;
            } else {
              var didFindChild = false;
              var _child = parentA.child;
              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                _child = parentB.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  {
                    throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                  }
                }
              }
            }
            if (!(a.alternate === b)) {
              {
                throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          if (!(a.tag === HostRoot)) {
            {
              throw Error("Unable to find node on an unmounted component.");
            }
          }
          if (a.stateNode.current === a) {
            return fiber;
          }
          return alternate;
        }
        function findCurrentHostFiber(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          if (!currentParent) {
            return null;
          }
          var node = currentParent;
          while (true) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            } else if (node.child) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === currentParent) {
              return null;
            }
            while (!node.sibling) {
              if (!node.return || node.return === currentParent) {
                return null;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        function findCurrentHostFiberWithNoPortals(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          if (!currentParent) {
            return null;
          }
          var node = currentParent;
          while (true) {
            if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI) {
              return node;
            } else if (node.child && node.tag !== HostPortal) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === currentParent) {
              return null;
            }
            while (!node.sibling) {
              if (!node.return || node.return === currentParent) {
                return null;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        function doesFiberContain(parentFiber, childFiber) {
          var node = childFiber;
          var parentFiberAlternate = parentFiber.alternate;
          while (node !== null) {
            if (node === parentFiber || node === parentFiberAlternate) {
              return true;
            }
            node = node.return;
          }
          return false;
        }
        var attemptUserBlockingHydration;
        function setAttemptUserBlockingHydration(fn) {
          attemptUserBlockingHydration = fn;
        }
        var attemptContinuousHydration;
        function setAttemptContinuousHydration(fn) {
          attemptContinuousHydration = fn;
        }
        var attemptHydrationAtCurrentPriority;
        function setAttemptHydrationAtCurrentPriority(fn) {
          attemptHydrationAtCurrentPriority = fn;
        }
        var attemptHydrationAtPriority;
        function setAttemptHydrationAtPriority(fn) {
          attemptHydrationAtPriority = fn;
        }
        var hasScheduledReplayAttempt = false;
        var queuedDiscreteEvents = [];
        var queuedFocus = null;
        var queuedDrag = null;
        var queuedMouse = null;
        var queuedPointers = new Map();
        var queuedPointerCaptures = new Map();
        var queuedExplicitHydrationTargets = [];
        function hasQueuedDiscreteEvents() {
          return queuedDiscreteEvents.length > 0;
        }
        var discreteReplayableEvents = [
          "mousedown",
          "mouseup",
          "touchcancel",
          "touchend",
          "touchstart",
          "auxclick",
          "dblclick",
          "pointercancel",
          "pointerdown",
          "pointerup",
          "dragend",
          "dragstart",
          "drop",
          "compositionend",
          "compositionstart",
          "keydown",
          "keypress",
          "keyup",
          "input",
          "textInput",
          "copy",
          "cut",
          "paste",
          "click",
          "change",
          "contextmenu",
          "reset",
          "submit"
        ];
        function isReplayableDiscreteEvent(eventType) {
          return discreteReplayableEvents.indexOf(eventType) > -1;
        }
        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return {
            blockedOn,
            domEventName,
            eventSystemFlags: eventSystemFlags | IS_REPLAYED,
            nativeEvent,
            targetContainers: [targetContainer]
          };
        }
        function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
          queuedDiscreteEvents.push(queuedEvent);
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout": {
              var pointerId = nativeEvent.pointerId;
              queuedPointers.delete(pointerId);
              break;
            }
            case "gotpointercapture":
            case "lostpointercapture": {
              var _pointerId = nativeEvent.pointerId;
              queuedPointerCaptures.delete(_pointerId);
              break;
            }
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn !== null) {
              var _fiber2 = getInstanceFromNode(blockedOn);
              if (_fiber2 !== null) {
                attemptContinuousHydration(_fiber2);
              }
            }
            return queuedEvent;
          }
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          var targetContainers = existingQueuedEvent.targetContainers;
          if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
            targetContainers.push(targetContainer);
          }
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin": {
              var focusEvent = nativeEvent;
              queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
              return true;
            }
            case "dragenter": {
              var dragEvent = nativeEvent;
              queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
              return true;
            }
            case "mouseover": {
              var mouseEvent = nativeEvent;
              queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
              return true;
            }
            case "pointerover": {
              var pointerEvent = nativeEvent;
              var pointerId = pointerEvent.pointerId;
              queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
              return true;
            }
            case "gotpointercapture": {
              var _pointerEvent = nativeEvent;
              var _pointerId2 = _pointerEvent.pointerId;
              queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
              return true;
            }
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted !== null) {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  queuedTarget.blockedOn = instance;
                  attemptHydrationAtPriority(queuedTarget.lanePriority, function() {
                    Scheduler.unstable_runWithPriority(queuedTarget.priority, function() {
                      attemptHydrationAtCurrentPriority(nearestMounted);
                    });
                  });
                  return;
                }
              } else if (tag === HostRoot) {
                var root2 = nearestMounted.stateNode;
                if (root2.hydrate) {
                  queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                  return;
                }
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (queuedEvent.blockedOn !== null) {
            return false;
          }
          var targetContainers = queuedEvent.targetContainers;
          while (targetContainers.length > 0) {
            var targetContainer = targetContainers[0];
            var nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
            if (nextBlockedOn !== null) {
              var _fiber3 = getInstanceFromNode(nextBlockedOn);
              if (_fiber3 !== null) {
                attemptContinuousHydration(_fiber3);
              }
              queuedEvent.blockedOn = nextBlockedOn;
              return false;
            }
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
          if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
            map.delete(key);
          }
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          while (queuedDiscreteEvents.length > 0) {
            var nextDiscreteEvent = queuedDiscreteEvents[0];
            if (nextDiscreteEvent.blockedOn !== null) {
              var _fiber4 = getInstanceFromNode(nextDiscreteEvent.blockedOn);
              if (_fiber4 !== null) {
                attemptUserBlockingHydration(_fiber4);
              }
              break;
            }
            var targetContainers = nextDiscreteEvent.targetContainers;
            while (targetContainers.length > 0) {
              var targetContainer = targetContainers[0];
              var nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);
              if (nextBlockedOn !== null) {
                nextDiscreteEvent.blockedOn = nextBlockedOn;
                break;
              }
              targetContainers.shift();
            }
            if (nextDiscreteEvent.blockedOn === null) {
              queuedDiscreteEvents.shift();
            }
          }
          if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
            queuedFocus = null;
          }
          if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
            queuedDrag = null;
          }
          if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
            queuedMouse = null;
          }
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          if (queuedEvent.blockedOn === unblocked) {
            queuedEvent.blockedOn = null;
            if (!hasScheduledReplayAttempt) {
              hasScheduledReplayAttempt = true;
              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
            }
          }
        }
        function retryIfBlockedOn(unblocked) {
          if (queuedDiscreteEvents.length > 0) {
            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
            for (var i = 1; i < queuedDiscreteEvents.length; i++) {
              var queuedEvent = queuedDiscreteEvents[i];
              if (queuedEvent.blockedOn === unblocked) {
                queuedEvent.blockedOn = null;
              }
            }
          }
          if (queuedFocus !== null) {
            scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          }
          if (queuedDrag !== null) {
            scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          }
          if (queuedMouse !== null) {
            scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          }
          var unblock = function(queuedEvent2) {
            return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
          };
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
            var queuedTarget = queuedExplicitHydrationTargets[_i];
            if (queuedTarget.blockedOn === unblocked) {
              queuedTarget.blockedOn = null;
            }
          }
          while (queuedExplicitHydrationTargets.length > 0) {
            var nextExplicitTarget = queuedExplicitHydrationTargets[0];
            if (nextExplicitTarget.blockedOn !== null) {
              break;
            } else {
              attemptExplicitHydrationTarget(nextExplicitTarget);
              if (nextExplicitTarget.blockedOn === null) {
                queuedExplicitHydrationTargets.shift();
              }
            }
          }
        }
        var DiscreteEvent = 0;
        var UserBlockingEvent = 1;
        var ContinuousEvent = 2;
        function makePrefixMap(styleProp, eventName) {
          var prefixes2 = {};
          prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes2["Webkit" + styleProp] = "webkit" + eventName;
          prefixes2["Moz" + styleProp] = "moz" + eventName;
          return prefixes2;
        }
        var vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        };
        var prefixedEventNames = {};
        var style = {};
        if (canUseDOM) {
          style = document.createElement("div").style;
          if (!("AnimationEvent" in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
          }
          if (!("TransitionEvent" in window)) {
            delete vendorPrefixes.transitionend.transition;
          }
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) {
            return prefixedEventNames[eventName];
          } else if (!vendorPrefixes[eventName]) {
            return eventName;
          }
          var prefixMap = vendorPrefixes[eventName];
          for (var styleProp in prefixMap) {
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
              return prefixedEventNames[eventName] = prefixMap[styleProp];
            }
          }
          return eventName;
        }
        var ANIMATION_END = getVendorPrefixedEventName("animationend");
        var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
        var ANIMATION_START = getVendorPrefixedEventName("animationstart");
        var TRANSITION_END = getVendorPrefixedEventName("transitionend");
        var topLevelEventsToReactNames = new Map();
        var eventPriorities = new Map();
        var discreteEventPairsForSimpleEventPlugin = [
          "cancel",
          "cancel",
          "click",
          "click",
          "close",
          "close",
          "contextmenu",
          "contextMenu",
          "copy",
          "copy",
          "cut",
          "cut",
          "auxclick",
          "auxClick",
          "dblclick",
          "doubleClick",
          "dragend",
          "dragEnd",
          "dragstart",
          "dragStart",
          "drop",
          "drop",
          "focusin",
          "focus",
          "focusout",
          "blur",
          "input",
          "input",
          "invalid",
          "invalid",
          "keydown",
          "keyDown",
          "keypress",
          "keyPress",
          "keyup",
          "keyUp",
          "mousedown",
          "mouseDown",
          "mouseup",
          "mouseUp",
          "paste",
          "paste",
          "pause",
          "pause",
          "play",
          "play",
          "pointercancel",
          "pointerCancel",
          "pointerdown",
          "pointerDown",
          "pointerup",
          "pointerUp",
          "ratechange",
          "rateChange",
          "reset",
          "reset",
          "seeked",
          "seeked",
          "submit",
          "submit",
          "touchcancel",
          "touchCancel",
          "touchend",
          "touchEnd",
          "touchstart",
          "touchStart",
          "volumechange",
          "volumeChange"
        ];
        var otherDiscreteEvents = ["change", "selectionchange", "textInput", "compositionstart", "compositionend", "compositionupdate"];
        var userBlockingPairsForSimpleEventPlugin = ["drag", "drag", "dragenter", "dragEnter", "dragexit", "dragExit", "dragleave", "dragLeave", "dragover", "dragOver", "mousemove", "mouseMove", "mouseout", "mouseOut", "mouseover", "mouseOver", "pointermove", "pointerMove", "pointerout", "pointerOut", "pointerover", "pointerOver", "scroll", "scroll", "toggle", "toggle", "touchmove", "touchMove", "wheel", "wheel"];
        var continuousPairsForSimpleEventPlugin = ["abort", "abort", ANIMATION_END, "animationEnd", ANIMATION_ITERATION, "animationIteration", ANIMATION_START, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", TRANSITION_END, "transitionEnd", "waiting", "waiting"];
        function registerSimplePluginEventsAndSetTheirPriorities(eventTypes, priority) {
          for (var i = 0; i < eventTypes.length; i += 2) {
            var topEvent = eventTypes[i];
            var event = eventTypes[i + 1];
            var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
            var reactName = "on" + capitalizedEvent;
            eventPriorities.set(topEvent, priority);
            topLevelEventsToReactNames.set(topEvent, reactName);
            registerTwoPhaseEvent(reactName, [topEvent]);
          }
        }
        function setEventPriorities(eventTypes, priority) {
          for (var i = 0; i < eventTypes.length; i++) {
            eventPriorities.set(eventTypes[i], priority);
          }
        }
        function getEventPriorityForPluginSystem(domEventName) {
          var priority = eventPriorities.get(domEventName);
          return priority === void 0 ? ContinuousEvent : priority;
        }
        function registerSimpleEvents() {
          registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);
          registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);
          registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent);
          setEventPriorities(otherDiscreteEvents, DiscreteEvent);
        }
        var Scheduler_now = Scheduler.unstable_now;
        {
          if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
            {
              throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
            }
          }
        }
        var ImmediatePriority = 99;
        var UserBlockingPriority = 98;
        var NormalPriority = 97;
        var LowPriority = 96;
        var IdlePriority = 95;
        var NoPriority = 90;
        var initialTimeMs = Scheduler_now();
        var SyncLanePriority = 15;
        var SyncBatchedLanePriority = 14;
        var InputDiscreteHydrationLanePriority = 13;
        var InputDiscreteLanePriority = 12;
        var InputContinuousHydrationLanePriority = 11;
        var InputContinuousLanePriority = 10;
        var DefaultHydrationLanePriority = 9;
        var DefaultLanePriority = 8;
        var TransitionHydrationPriority = 7;
        var TransitionPriority = 6;
        var RetryLanePriority = 5;
        var SelectiveHydrationLanePriority = 4;
        var IdleHydrationLanePriority = 3;
        var IdleLanePriority = 2;
        var OffscreenLanePriority = 1;
        var NoLanePriority = 0;
        var TotalLanes = 31;
        var NoLanes = 0;
        var NoLane = 0;
        var SyncLane = 1;
        var SyncBatchedLane = 2;
        var InputDiscreteHydrationLane = 4;
        var InputDiscreteLanes = 24;
        var InputContinuousHydrationLane = 32;
        var InputContinuousLanes = 192;
        var DefaultHydrationLane = 256;
        var DefaultLanes = 3584;
        var TransitionHydrationLane = 4096;
        var TransitionLanes = 4186112;
        var RetryLanes = 62914560;
        var SomeRetryLane = 33554432;
        var SelectiveHydrationLane = 67108864;
        var NonIdleLanes = 134217727;
        var IdleHydrationLane = 134217728;
        var IdleLanes = 805306368;
        var OffscreenLane = 1073741824;
        var NoTimestamp = -1;
        function setCurrentUpdateLanePriority(newLanePriority) {
        }
        var return_highestLanePriority = DefaultLanePriority;
        function getHighestPriorityLanes(lanes) {
          if ((SyncLane & lanes) !== NoLanes) {
            return_highestLanePriority = SyncLanePriority;
            return SyncLane;
          }
          if ((SyncBatchedLane & lanes) !== NoLanes) {
            return_highestLanePriority = SyncBatchedLanePriority;
            return SyncBatchedLane;
          }
          if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
            return_highestLanePriority = InputDiscreteHydrationLanePriority;
            return InputDiscreteHydrationLane;
          }
          var inputDiscreteLanes = InputDiscreteLanes & lanes;
          if (inputDiscreteLanes !== NoLanes) {
            return_highestLanePriority = InputDiscreteLanePriority;
            return inputDiscreteLanes;
          }
          if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
            return_highestLanePriority = InputContinuousHydrationLanePriority;
            return InputContinuousHydrationLane;
          }
          var inputContinuousLanes = InputContinuousLanes & lanes;
          if (inputContinuousLanes !== NoLanes) {
            return_highestLanePriority = InputContinuousLanePriority;
            return inputContinuousLanes;
          }
          if ((lanes & DefaultHydrationLane) !== NoLanes) {
            return_highestLanePriority = DefaultHydrationLanePriority;
            return DefaultHydrationLane;
          }
          var defaultLanes = DefaultLanes & lanes;
          if (defaultLanes !== NoLanes) {
            return_highestLanePriority = DefaultLanePriority;
            return defaultLanes;
          }
          if ((lanes & TransitionHydrationLane) !== NoLanes) {
            return_highestLanePriority = TransitionHydrationPriority;
            return TransitionHydrationLane;
          }
          var transitionLanes = TransitionLanes & lanes;
          if (transitionLanes !== NoLanes) {
            return_highestLanePriority = TransitionPriority;
            return transitionLanes;
          }
          var retryLanes = RetryLanes & lanes;
          if (retryLanes !== NoLanes) {
            return_highestLanePriority = RetryLanePriority;
            return retryLanes;
          }
          if (lanes & SelectiveHydrationLane) {
            return_highestLanePriority = SelectiveHydrationLanePriority;
            return SelectiveHydrationLane;
          }
          if ((lanes & IdleHydrationLane) !== NoLanes) {
            return_highestLanePriority = IdleHydrationLanePriority;
            return IdleHydrationLane;
          }
          var idleLanes = IdleLanes & lanes;
          if (idleLanes !== NoLanes) {
            return_highestLanePriority = IdleLanePriority;
            return idleLanes;
          }
          if ((OffscreenLane & lanes) !== NoLanes) {
            return_highestLanePriority = OffscreenLanePriority;
            return OffscreenLane;
          }
          {
            error("Should have found matching lanes. This is a bug in React.");
          }
          return_highestLanePriority = DefaultLanePriority;
          return lanes;
        }
        function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
          switch (schedulerPriorityLevel) {
            case ImmediatePriority:
              return SyncLanePriority;
            case UserBlockingPriority:
              return InputContinuousLanePriority;
            case NormalPriority:
            case LowPriority:
              return DefaultLanePriority;
            case IdlePriority:
              return IdleLanePriority;
            default:
              return NoLanePriority;
          }
        }
        function lanePriorityToSchedulerPriority(lanePriority) {
          switch (lanePriority) {
            case SyncLanePriority:
            case SyncBatchedLanePriority:
              return ImmediatePriority;
            case InputDiscreteHydrationLanePriority:
            case InputDiscreteLanePriority:
            case InputContinuousHydrationLanePriority:
            case InputContinuousLanePriority:
              return UserBlockingPriority;
            case DefaultHydrationLanePriority:
            case DefaultLanePriority:
            case TransitionHydrationPriority:
            case TransitionPriority:
            case SelectiveHydrationLanePriority:
            case RetryLanePriority:
              return NormalPriority;
            case IdleHydrationLanePriority:
            case IdleLanePriority:
            case OffscreenLanePriority:
              return IdlePriority;
            case NoLanePriority:
              return NoPriority;
            default: {
              {
                throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
              }
            }
          }
        }
        function getNextLanes(root2, wipLanes) {
          var pendingLanes = root2.pendingLanes;
          if (pendingLanes === NoLanes) {
            return_highestLanePriority = NoLanePriority;
            return NoLanes;
          }
          var nextLanes = NoLanes;
          var nextLanePriority = NoLanePriority;
          var expiredLanes = root2.expiredLanes;
          var suspendedLanes = root2.suspendedLanes;
          var pingedLanes = root2.pingedLanes;
          if (expiredLanes !== NoLanes) {
            nextLanes = expiredLanes;
            nextLanePriority = return_highestLanePriority = SyncLanePriority;
          } else {
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
              var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
              if (nonIdleUnblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
                nextLanePriority = return_highestLanePriority;
              } else {
                var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                if (nonIdlePingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                  nextLanePriority = return_highestLanePriority;
                }
              }
            } else {
              var unblockedLanes = pendingLanes & ~suspendedLanes;
              if (unblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(unblockedLanes);
                nextLanePriority = return_highestLanePriority;
              } else {
                if (pingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(pingedLanes);
                  nextLanePriority = return_highestLanePriority;
                }
              }
            }
          }
          if (nextLanes === NoLanes) {
            return NoLanes;
          }
          nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes);
          if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {
            getHighestPriorityLanes(wipLanes);
            var wipLanePriority = return_highestLanePriority;
            if (nextLanePriority <= wipLanePriority) {
              return wipLanes;
            } else {
              return_highestLanePriority = nextLanePriority;
            }
          }
          var entangledLanes = root2.entangledLanes;
          if (entangledLanes !== NoLanes) {
            var entanglements = root2.entanglements;
            var lanes = nextLanes & entangledLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              nextLanes |= entanglements[index2];
              lanes &= ~lane;
            }
          }
          return nextLanes;
        }
        function getMostRecentEventTime(root2, lanes) {
          var eventTimes = root2.eventTimes;
          var mostRecentEventTime = NoTimestamp;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            var eventTime = eventTimes[index2];
            if (eventTime > mostRecentEventTime) {
              mostRecentEventTime = eventTime;
            }
            lanes &= ~lane;
          }
          return mostRecentEventTime;
        }
        function computeExpirationTime(lane, currentTime) {
          getHighestPriorityLanes(lane);
          var priority = return_highestLanePriority;
          if (priority >= InputContinuousLanePriority) {
            return currentTime + 250;
          } else if (priority >= TransitionPriority) {
            return currentTime + 5e3;
          } else {
            return NoTimestamp;
          }
        }
        function markStarvedLanesAsExpired(root2, currentTime) {
          var pendingLanes = root2.pendingLanes;
          var suspendedLanes = root2.suspendedLanes;
          var pingedLanes = root2.pingedLanes;
          var expirationTimes = root2.expirationTimes;
          var lanes = pendingLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            var expirationTime = expirationTimes[index2];
            if (expirationTime === NoTimestamp) {
              if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                expirationTimes[index2] = computeExpirationTime(lane, currentTime);
              }
            } else if (expirationTime <= currentTime) {
              root2.expiredLanes |= lane;
            }
            lanes &= ~lane;
          }
        }
        function getLanesToRetrySynchronouslyOnError(root2) {
          var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
          if (everythingButOffscreen !== NoLanes) {
            return everythingButOffscreen;
          }
          if (everythingButOffscreen & OffscreenLane) {
            return OffscreenLane;
          }
          return NoLanes;
        }
        function returnNextLanesPriority() {
          return return_highestLanePriority;
        }
        function includesNonIdleWork(lanes) {
          return (lanes & NonIdleLanes) !== NoLanes;
        }
        function includesOnlyRetries(lanes) {
          return (lanes & RetryLanes) === lanes;
        }
        function includesOnlyTransitions(lanes) {
          return (lanes & TransitionLanes) === lanes;
        }
        function findUpdateLane(lanePriority, wipLanes) {
          switch (lanePriority) {
            case NoLanePriority:
              break;
            case SyncLanePriority:
              return SyncLane;
            case SyncBatchedLanePriority:
              return SyncBatchedLane;
            case InputDiscreteLanePriority: {
              var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);
              if (_lane === NoLane) {
                return findUpdateLane(InputContinuousLanePriority, wipLanes);
              }
              return _lane;
            }
            case InputContinuousLanePriority: {
              var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);
              if (_lane2 === NoLane) {
                return findUpdateLane(DefaultLanePriority, wipLanes);
              }
              return _lane2;
            }
            case DefaultLanePriority: {
              var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);
              if (_lane3 === NoLane) {
                _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);
                if (_lane3 === NoLane) {
                  _lane3 = pickArbitraryLane(DefaultLanes);
                }
              }
              return _lane3;
            }
            case TransitionPriority:
            case RetryLanePriority:
              break;
            case IdleLanePriority:
              var lane = pickArbitraryLane(IdleLanes & ~wipLanes);
              if (lane === NoLane) {
                lane = pickArbitraryLane(IdleLanes);
              }
              return lane;
          }
          {
            {
              throw Error("Invalid update priority: " + lanePriority + ". This is a bug in React.");
            }
          }
        }
        function findTransitionLane(wipLanes, pendingLanes) {
          var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);
          if (lane === NoLane) {
            lane = pickArbitraryLane(TransitionLanes & ~wipLanes);
            if (lane === NoLane) {
              lane = pickArbitraryLane(TransitionLanes);
            }
          }
          return lane;
        }
        function findRetryLane(wipLanes) {
          var lane = pickArbitraryLane(RetryLanes & ~wipLanes);
          if (lane === NoLane) {
            lane = pickArbitraryLane(RetryLanes);
          }
          return lane;
        }
        function getHighestPriorityLane(lanes) {
          return lanes & -lanes;
        }
        function getLowestPriorityLane(lanes) {
          var index2 = 31 - clz32(lanes);
          return index2 < 0 ? NoLanes : 1 << index2;
        }
        function getEqualOrHigherPriorityLanes(lanes) {
          return (getLowestPriorityLane(lanes) << 1) - 1;
        }
        function pickArbitraryLane(lanes) {
          return getHighestPriorityLane(lanes);
        }
        function pickArbitraryLaneIndex(lanes) {
          return 31 - clz32(lanes);
        }
        function laneToIndex(lane) {
          return pickArbitraryLaneIndex(lane);
        }
        function includesSomeLane(a, b) {
          return (a & b) !== NoLanes;
        }
        function isSubsetOfLanes(set2, subset) {
          return (set2 & subset) === subset;
        }
        function mergeLanes(a, b) {
          return a | b;
        }
        function removeLanes(set2, subset) {
          return set2 & ~subset;
        }
        function laneToLanes(lane) {
          return lane;
        }
        function higherPriorityLane(a, b) {
          return a !== NoLane && a < b ? a : b;
        }
        function createLaneMap(initial) {
          var laneMap = [];
          for (var i = 0; i < TotalLanes; i++) {
            laneMap.push(initial);
          }
          return laneMap;
        }
        function markRootUpdated(root2, updateLane, eventTime) {
          root2.pendingLanes |= updateLane;
          var higherPriorityLanes = updateLane - 1;
          root2.suspendedLanes &= higherPriorityLanes;
          root2.pingedLanes &= higherPriorityLanes;
          var eventTimes = root2.eventTimes;
          var index2 = laneToIndex(updateLane);
          eventTimes[index2] = eventTime;
        }
        function markRootSuspended(root2, suspendedLanes) {
          root2.suspendedLanes |= suspendedLanes;
          root2.pingedLanes &= ~suspendedLanes;
          var expirationTimes = root2.expirationTimes;
          var lanes = suspendedLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            expirationTimes[index2] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootPinged(root2, pingedLanes, eventTime) {
          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        }
        function markDiscreteUpdatesExpired(root2) {
          root2.expiredLanes |= InputDiscreteLanes & root2.pendingLanes;
        }
        function hasDiscreteLanes(lanes) {
          return (lanes & InputDiscreteLanes) !== NoLanes;
        }
        function markRootMutableRead(root2, updateLane) {
          root2.mutableReadLanes |= updateLane & root2.pendingLanes;
        }
        function markRootFinished(root2, remainingLanes) {
          var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
          root2.pendingLanes = remainingLanes;
          root2.suspendedLanes = 0;
          root2.pingedLanes = 0;
          root2.expiredLanes &= remainingLanes;
          root2.mutableReadLanes &= remainingLanes;
          root2.entangledLanes &= remainingLanes;
          var entanglements = root2.entanglements;
          var eventTimes = root2.eventTimes;
          var expirationTimes = root2.expirationTimes;
          var lanes = noLongerPendingLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            entanglements[index2] = NoLanes;
            eventTimes[index2] = NoTimestamp;
            expirationTimes[index2] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootEntangled(root2, entangledLanes) {
          root2.entangledLanes |= entangledLanes;
          var entanglements = root2.entanglements;
          var lanes = entangledLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            entanglements[index2] |= entangledLanes;
            lanes &= ~lane;
          }
        }
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(lanes) {
          if (lanes === 0) {
            return 32;
          }
          return 31 - (log(lanes) / LN2 | 0) | 0;
        }
        var UserBlockingPriority$1 = Scheduler.unstable_UserBlockingPriority, runWithPriority = Scheduler.unstable_runWithPriority;
        var _enabled = true;
        function setEnabled(enabled) {
          _enabled = !!enabled;
        }
        function isEnabled() {
          return _enabled;
        }
        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
          var eventPriority = getEventPriorityForPluginSystem(domEventName);
          var listenerWrapper;
          switch (eventPriority) {
            case DiscreteEvent:
              listenerWrapper = dispatchDiscreteEvent;
              break;
            case UserBlockingEvent:
              listenerWrapper = dispatchUserBlockingUpdate;
              break;
            case ContinuousEvent:
            default:
              listenerWrapper = dispatchEvent;
              break;
          }
          return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          {
            flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);
          }
          discreteUpdates(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);
        }
        function dispatchUserBlockingUpdate(domEventName, eventSystemFlags, container, nativeEvent) {
          {
            runWithPriority(UserBlockingPriority$1, dispatchEvent.bind(null, domEventName, eventSystemFlags, container, nativeEvent));
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (!_enabled) {
            return;
          }
          var allowReplay = true;
          {
            allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;
          }
          if (allowReplay && hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(domEventName)) {
            queueDiscreteEvent(null, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            return;
          }
          var blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn === null) {
            if (allowReplay) {
              clearIfContinuousEvent(domEventName, nativeEvent);
            }
            return;
          }
          if (allowReplay) {
            if (isReplayableDiscreteEvent(domEventName)) {
              queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
              return;
            }
            clearIfContinuousEvent(domEventName, nativeEvent);
          }
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
        }
        function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          var nativeEventTarget = getEventTarget(nativeEvent);
          var targetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted === null) {
              targetInst = null;
            } else {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  return instance;
                }
                targetInst = null;
              } else if (tag === HostRoot) {
                var root2 = nearestMounted.stateNode;
                if (root2.hydrate) {
                  return getContainerFromFiber(nearestMounted);
                }
                targetInst = null;
              } else if (nearestMounted !== targetInst) {
                targetInst = null;
              }
            }
          }
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer);
          return null;
        }
        function addEventBubbleListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, false);
          return listener;
        }
        function addEventCaptureListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, true);
          return listener;
        }
        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            capture: true,
            passive
          });
          return listener;
        }
        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            passive
          });
          return listener;
        }
        var root = null;
        var startText = null;
        var fallbackText = null;
        function initialize(nativeEventTarget) {
          root = nativeEventTarget;
          startText = getText();
          return true;
        }
        function reset() {
          root = null;
          startText = null;
          fallbackText = null;
        }
        function getData() {
          if (fallbackText) {
            return fallbackText;
          }
          var start2;
          var startValue = startText;
          var startLength = startValue.length;
          var end;
          var endValue = getText();
          var endLength = endValue.length;
          for (start2 = 0; start2 < startLength; start2++) {
            if (startValue[start2] !== endValue[start2]) {
              break;
            }
          }
          var minEnd = startLength - start2;
          for (end = 1; end <= minEnd; end++) {
            if (startValue[startLength - end] !== endValue[endLength - end]) {
              break;
            }
          }
          var sliceTail = end > 1 ? 1 - end : void 0;
          fallbackText = endValue.slice(start2, sliceTail);
          return fallbackText;
        }
        function getText() {
          if ("value" in root) {
            return root.value;
          }
          return root.textContent;
        }
        function getEventCharCode(nativeEvent) {
          var charCode;
          var keyCode = nativeEvent.keyCode;
          if ("charCode" in nativeEvent) {
            charCode = nativeEvent.charCode;
            if (charCode === 0 && keyCode === 13) {
              charCode = 13;
            }
          } else {
            charCode = keyCode;
          }
          if (charCode === 10) {
            charCode = 13;
          }
          if (charCode >= 32 || charCode === 13) {
            return charCode;
          }
          return 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var _propName in Interface) {
              if (!Interface.hasOwnProperty(_propName)) {
                continue;
              }
              var normalize = Interface[_propName];
              if (normalize) {
                this[_propName] = normalize(nativeEvent);
              } else {
                this[_propName] = nativeEvent[_propName];
              }
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) {
              this.isDefaultPrevented = functionThatReturnsTrue;
            } else {
              this.isDefaultPrevented = functionThatReturnsFalse;
            }
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          _assign(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.preventDefault) {
                event.preventDefault();
              } else if (typeof event.returnValue !== "unknown") {
                event.returnValue = false;
              }
              this.isDefaultPrevented = functionThatReturnsTrue;
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.stopPropagation) {
                event.stopPropagation();
              } else if (typeof event.cancelBubble !== "unknown") {
                event.cancelBubble = true;
              }
              this.isPropagationStopped = functionThatReturnsTrue;
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        var EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        };
        var SyntheticEvent = createSyntheticEvent(EventInterface);
        var UIEventInterface = _assign({}, EventInterface, {
          view: 0,
          detail: 0
        });
        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
        var lastMovementX;
        var lastMovementY;
        var lastMouseEvent;
        function updateMouseMovementPolyfillState(event) {
          if (event !== lastMouseEvent) {
            if (lastMouseEvent && event.type === "mousemove") {
              lastMovementX = event.screenX - lastMouseEvent.screenX;
              lastMovementY = event.screenY - lastMouseEvent.screenY;
            } else {
              lastMovementX = 0;
              lastMovementY = 0;
            }
            lastMouseEvent = event;
          }
        }
        var MouseEventInterface = _assign({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            if (event.relatedTarget === void 0)
              return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
            return event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) {
              return event.movementX;
            }
            updateMouseMovementPolyfillState(event);
            return lastMovementX;
          },
          movementY: function(event) {
            if ("movementY" in event) {
              return event.movementY;
            }
            return lastMovementY;
          }
        });
        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
        var DragEventInterface = _assign({}, MouseEventInterface, {
          dataTransfer: 0
        });
        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
        var FocusEventInterface = _assign({}, UIEventInterface, {
          relatedTarget: 0
        });
        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
        var AnimationEventInterface = _assign({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
        var ClipboardEventInterface = _assign({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        });
        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
        var CompositionEventInterface = _assign({}, EventInterface, {
          data: 0
        });
        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
        var SyntheticInputEvent = SyntheticCompositionEvent;
        var normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        };
        var translateToKey = {
          "8": "Backspace",
          "9": "Tab",
          "12": "Clear",
          "13": "Enter",
          "16": "Shift",
          "17": "Control",
          "18": "Alt",
          "19": "Pause",
          "20": "CapsLock",
          "27": "Escape",
          "32": " ",
          "33": "PageUp",
          "34": "PageDown",
          "35": "End",
          "36": "Home",
          "37": "ArrowLeft",
          "38": "ArrowUp",
          "39": "ArrowRight",
          "40": "ArrowDown",
          "45": "Insert",
          "46": "Delete",
          "112": "F1",
          "113": "F2",
          "114": "F3",
          "115": "F4",
          "116": "F5",
          "117": "F6",
          "118": "F7",
          "119": "F8",
          "120": "F9",
          "121": "F10",
          "122": "F11",
          "123": "F12",
          "144": "NumLock",
          "145": "ScrollLock",
          "224": "Meta"
        };
        function getEventKey(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key !== "Unidentified") {
              return key;
            }
          }
          if (nativeEvent.type === "keypress") {
            var charCode = getEventCharCode(nativeEvent);
            return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
          }
          if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
            return translateToKey[nativeEvent.keyCode] || "Unidentified";
          }
          return "";
        }
        var modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        };
        function modifierStateGetter(keyArg) {
          var syntheticEvent = this;
          var nativeEvent = syntheticEvent.nativeEvent;
          if (nativeEvent.getModifierState) {
            return nativeEvent.getModifierState(keyArg);
          }
          var keyProp = modifierKeyToProp[keyArg];
          return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
          return modifierStateGetter;
        }
        var KeyboardEventInterface = _assign({}, UIEventInterface, {
          key: getEventKey,
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            return 0;
          },
          keyCode: function(event) {
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          },
          which: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          }
        });
        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
        var PointerEventInterface = _assign({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        });
        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
        var TouchEventInterface = _assign({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        });
        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
        var TransitionEventInterface = _assign({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
        var WheelEventInterface = _assign({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        });
        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
        var END_KEYCODES = [9, 13, 27, 32];
        var START_KEYCODE = 229;
        var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
        var documentMode = null;
        if (canUseDOM && "documentMode" in document) {
          documentMode = document.documentMode;
        }
        var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
        var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
        var SPACEBAR_CODE = 32;
        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
        function registerEvents() {
          registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
          registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        }
        var hasSpaceKeypress = false;
        function isKeypressCommand(nativeEvent) {
          return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
        }
        function getCompositionEventType(domEventName) {
          switch (domEventName) {
            case "compositionstart":
              return "onCompositionStart";
            case "compositionend":
              return "onCompositionEnd";
            case "compositionupdate":
              return "onCompositionUpdate";
          }
        }
        function isFallbackCompositionStart(domEventName, nativeEvent) {
          return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          var detail = nativeEvent.detail;
          if (typeof detail === "object" && "data" in detail) {
            return detail.data;
          }
          return null;
        }
        function isUsingKoreanIME(nativeEvent) {
          return nativeEvent.locale === "ko";
        }
        var isComposing = false;
        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var eventType;
          var fallbackData;
          if (canUseCompositionEvent) {
            eventType = getCompositionEventType(domEventName);
          } else if (!isComposing) {
            if (isFallbackCompositionStart(domEventName, nativeEvent)) {
              eventType = "onCompositionStart";
            }
          } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
            eventType = "onCompositionEnd";
          }
          if (!eventType) {
            return null;
          }
          if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
            if (!isComposing && eventType === "onCompositionStart") {
              isComposing = initialize(nativeEventTarget);
            } else if (eventType === "onCompositionEnd") {
              if (isComposing) {
                fallbackData = getData();
              }
            }
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
          if (listeners.length > 0) {
            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            if (fallbackData) {
              event.data = fallbackData;
            } else {
              var customData = getDataFromCustomEvent(nativeEvent);
              if (customData !== null) {
                event.data = customData;
              }
            }
          }
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              var which = nativeEvent.which;
              if (which !== SPACEBAR_CODE) {
                return null;
              }
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              var chars = nativeEvent.data;
              if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                return null;
              }
              return chars;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing) {
            if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
              var chars = getData();
              reset();
              isComposing = false;
              return chars;
            }
            return null;
          }
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!isKeypressCommand(nativeEvent)) {
                if (nativeEvent.char && nativeEvent.char.length > 1) {
                  return nativeEvent.char;
                } else if (nativeEvent.which) {
                  return String.fromCharCode(nativeEvent.which);
                }
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var chars;
          if (canUseTextInputEvent) {
            chars = getNativeBeforeInputChars(domEventName, nativeEvent);
          } else {
            chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
          }
          if (!chars) {
            return null;
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
          if (listeners.length > 0) {
            var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            event.data = chars;
          }
        }
        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        var supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        };
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          if (nodeName === "input") {
            return !!supportedInputTypes[elem.type];
          }
          if (nodeName === "textarea") {
            return true;
          }
          return false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM) {
            return false;
          }
          var eventName = "on" + eventNameSuffix;
          var isSupported = eventName in document;
          if (!isSupported) {
            var element = document.createElement("div");
            element.setAttribute(eventName, "return;");
            isSupported = typeof element[eventName] === "function";
          }
          return isSupported;
        }
        function registerEvents$1() {
          registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          enqueueStateRestore(target);
          var listeners = accumulateTwoPhaseListeners(inst, "onChange");
          if (listeners.length > 0) {
            var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        var activeElement = null;
        var activeElementInst = null;
        function shouldUseChangeEvent(elem) {
          var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName === "select" || nodeName === "input" && elem.type === "file";
        }
        function manualDispatchChangeEvent(nativeEvent) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
          batchedUpdates(runEventInBatch, dispatchQueue);
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) {
            return targetInst;
          }
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if (domEventName === "change") {
            return targetInst;
          }
        }
        var isInputEventSupported = false;
        if (canUseDOM) {
          isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
        }
        function startWatchingForValueChange(target, targetInst) {
          activeElement = target;
          activeElementInst = targetInst;
          activeElement.attachEvent("onpropertychange", handlePropertyChange);
        }
        function stopWatchingForValueChange() {
          if (!activeElement) {
            return;
          }
          activeElement.detachEvent("onpropertychange", handlePropertyChange);
          activeElement = null;
          activeElementInst = null;
        }
        function handlePropertyChange(nativeEvent) {
          if (nativeEvent.propertyName !== "value") {
            return;
          }
          if (getInstIfValueChanged(activeElementInst)) {
            manualDispatchChangeEvent(nativeEvent);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          if (domEventName === "focusin") {
            stopWatchingForValueChange();
            startWatchingForValueChange(target, targetInst);
          } else if (domEventName === "focusout") {
            stopWatchingForValueChange();
          }
        }
        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
          if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
            return getInstIfValueChanged(activeElementInst);
          }
        }
        function shouldUseClickEvent(elem) {
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if (domEventName === "click") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if (domEventName === "input" || domEventName === "change") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function handleControlledInputBlur(node) {
          var state = node._wrapperState;
          if (!state || !state.controlled || node.type !== "number") {
            return;
          }
          {
            setDefaultValue(node, "number", node.value);
          }
        }
        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          var getTargetInstFunc, handleEventFunc;
          if (shouldUseChangeEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForChangeEvent;
          } else if (isTextInputElement(targetNode)) {
            if (isInputEventSupported) {
              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            } else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              handleEventFunc = handleEventsForInputEventPolyfill;
            }
          } else if (shouldUseClickEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForClickEvent;
          }
          if (getTargetInstFunc) {
            var inst = getTargetInstFunc(domEventName, targetInst);
            if (inst) {
              createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
              return;
            }
          }
          if (handleEventFunc) {
            handleEventFunc(domEventName, targetNode, targetInst);
          }
          if (domEventName === "focusout") {
            handleControlledInputBlur(targetNode);
          }
        }
        function registerEvents$2() {
          registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
          registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
          registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
          registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        }
        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
          var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
          if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {
            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
            if (related) {
              if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                return;
              }
            }
          }
          if (!isOutEvent && !isOverEvent) {
            return;
          }
          var win;
          if (nativeEventTarget.window === nativeEventTarget) {
            win = nativeEventTarget;
          } else {
            var doc2 = nativeEventTarget.ownerDocument;
            if (doc2) {
              win = doc2.defaultView || doc2.parentWindow;
            } else {
              win = window;
            }
          }
          var from;
          var to;
          if (isOutEvent) {
            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
            from = targetInst;
            to = _related ? getClosestInstanceFromNode(_related) : null;
            if (to !== null) {
              var nearestMounted = getNearestMountedFiber(to);
              if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                to = null;
              }
            }
          } else {
            from = null;
            to = targetInst;
          }
          if (from === to) {
            return;
          }
          var SyntheticEventCtor = SyntheticMouseEvent;
          var leaveEventType = "onMouseLeave";
          var enterEventType = "onMouseEnter";
          var eventTypePrefix = "mouse";
          if (domEventName === "pointerout" || domEventName === "pointerover") {
            SyntheticEventCtor = SyntheticPointerEvent;
            leaveEventType = "onPointerLeave";
            enterEventType = "onPointerEnter";
            eventTypePrefix = "pointer";
          }
          var fromNode = from == null ? win : getNodeFromInstance(from);
          var toNode = to == null ? win : getNodeFromInstance(to);
          var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
          leave.target = fromNode;
          leave.relatedTarget = toNode;
          var enter = null;
          var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (nativeTargetInst === targetInst) {
            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
            enterEvent.target = toNode;
            enterEvent.relatedTarget = fromNode;
            enter = enterEvent;
          }
          accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        function shallowEqual(objA, objB) {
          if (objectIs(objA, objB)) {
            return true;
          }
          if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
            return false;
          }
          var keysA = Object.keys(objA);
          var keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) {
            return false;
          }
          for (var i = 0; i < keysA.length; i++) {
            if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) {
              return false;
            }
          }
          return true;
        }
        function getLeafNode(node) {
          while (node && node.firstChild) {
            node = node.firstChild;
          }
          return node;
        }
        function getSiblingNode(node) {
          while (node) {
            if (node.nextSibling) {
              return node.nextSibling;
            }
            node = node.parentNode;
          }
        }
        function getNodeForCharacterOffset(root2, offset) {
          var node = getLeafNode(root2);
          var nodeStart = 0;
          var nodeEnd = 0;
          while (node) {
            if (node.nodeType === TEXT_NODE) {
              nodeEnd = nodeStart + node.textContent.length;
              if (nodeStart <= offset && nodeEnd >= offset) {
                return {
                  node,
                  offset: offset - nodeStart
                };
              }
              nodeStart = nodeEnd;
            }
            node = getLeafNode(getSiblingNode(node));
          }
        }
        function getOffsets(outerNode) {
          var ownerDocument = outerNode.ownerDocument;
          var win = ownerDocument && ownerDocument.defaultView || window;
          var selection = win.getSelection && win.getSelection();
          if (!selection || selection.rangeCount === 0) {
            return null;
          }
          var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
          try {
            anchorNode.nodeType;
            focusNode.nodeType;
          } catch (e) {
            return null;
          }
          return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
        }
        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
          var length = 0;
          var start2 = -1;
          var end = -1;
          var indexWithinAnchor = 0;
          var indexWithinFocus = 0;
          var node = outerNode;
          var parentNode = null;
          outer:
            while (true) {
              var next = null;
              while (true) {
                if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                  start2 = length + anchorOffset;
                }
                if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                  end = length + focusOffset;
                }
                if (node.nodeType === TEXT_NODE) {
                  length += node.nodeValue.length;
                }
                if ((next = node.firstChild) === null) {
                  break;
                }
                parentNode = node;
                node = next;
              }
              while (true) {
                if (node === outerNode) {
                  break outer;
                }
                if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                  start2 = length;
                }
                if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                  end = length;
                }
                if ((next = node.nextSibling) !== null) {
                  break;
                }
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
          if (start2 === -1 || end === -1) {
            return null;
          }
          return {
            start: start2,
            end
          };
        }
        function setOffsets(node, offsets) {
          var doc2 = node.ownerDocument || document;
          var win = doc2 && doc2.defaultView || window;
          if (!win.getSelection) {
            return;
          }
          var selection = win.getSelection();
          var length = node.textContent.length;
          var start2 = Math.min(offsets.start, length);
          var end = offsets.end === void 0 ? start2 : Math.min(offsets.end, length);
          if (!selection.extend && start2 > end) {
            var temp = end;
            end = start2;
            start2 = temp;
          }
          var startMarker = getNodeForCharacterOffset(node, start2);
          var endMarker = getNodeForCharacterOffset(node, end);
          if (startMarker && endMarker) {
            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
              return;
            }
            var range = doc2.createRange();
            range.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start2 > end) {
              selection.addRange(range);
              selection.extend(endMarker.node, endMarker.offset);
            } else {
              range.setEnd(endMarker.node, endMarker.offset);
              selection.addRange(range);
            }
          }
        }
        function isTextNode(node) {
          return node && node.nodeType === TEXT_NODE;
        }
        function containsNode(outerNode, innerNode) {
          if (!outerNode || !innerNode) {
            return false;
          } else if (outerNode === innerNode) {
            return true;
          } else if (isTextNode(outerNode)) {
            return false;
          } else if (isTextNode(innerNode)) {
            return containsNode(outerNode, innerNode.parentNode);
          } else if ("contains" in outerNode) {
            return outerNode.contains(innerNode);
          } else if (outerNode.compareDocumentPosition) {
            return !!(outerNode.compareDocumentPosition(innerNode) & 16);
          } else {
            return false;
          }
        }
        function isInDocument(node) {
          return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
        }
        function isSameOriginFrame(iframe) {
          try {
            return typeof iframe.contentWindow.location.href === "string";
          } catch (err) {
            return false;
          }
        }
        function getActiveElementDeep() {
          var win = window;
          var element = getActiveElement();
          while (element instanceof win.HTMLIFrameElement) {
            if (isSameOriginFrame(element)) {
              win = element.contentWindow;
            } else {
              return element;
            }
            element = getActiveElement(win.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
        }
        function getSelectionInformation() {
          var focusedElem = getActiveElementDeep();
          return {
            focusedElem,
            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection2(focusedElem) : null
          };
        }
        function restoreSelection(priorSelectionInformation) {
          var curFocusedElem = getActiveElementDeep();
          var priorFocusedElem = priorSelectionInformation.focusedElem;
          var priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
              setSelection(priorFocusedElem, priorSelectionRange);
            }
            var ancestors = [];
            var ancestor = priorFocusedElem;
            while (ancestor = ancestor.parentNode) {
              if (ancestor.nodeType === ELEMENT_NODE) {
                ancestors.push({
                  element: ancestor,
                  left: ancestor.scrollLeft,
                  top: ancestor.scrollTop
                });
              }
            }
            if (typeof priorFocusedElem.focus === "function") {
              priorFocusedElem.focus();
            }
            for (var i = 0; i < ancestors.length; i++) {
              var info = ancestors[i];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
        }
        function getSelection2(input) {
          var selection;
          if ("selectionStart" in input) {
            selection = {
              start: input.selectionStart,
              end: input.selectionEnd
            };
          } else {
            selection = getOffsets(input);
          }
          return selection || {
            start: 0,
            end: 0
          };
        }
        function setSelection(input, offsets) {
          var start2 = offsets.start;
          var end = offsets.end;
          if (end === void 0) {
            end = start2;
          }
          if ("selectionStart" in input) {
            input.selectionStart = start2;
            input.selectionEnd = Math.min(end, input.value.length);
          } else {
            setOffsets(input, offsets);
          }
        }
        var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
        function registerEvents$3() {
          registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
        }
        var activeElement$1 = null;
        var activeElementInst$1 = null;
        var lastSelection = null;
        var mouseDown = false;
        function getSelection$1(node) {
          if ("selectionStart" in node && hasSelectionCapabilities(node)) {
            return {
              start: node.selectionStart,
              end: node.selectionEnd
            };
          } else {
            var win = node.ownerDocument && node.ownerDocument.defaultView || window;
            var selection = win.getSelection();
            return {
              anchorNode: selection.anchorNode,
              anchorOffset: selection.anchorOffset,
              focusNode: selection.focusNode,
              focusOffset: selection.focusOffset
            };
          }
        }
        function getEventTargetDocument(eventTarget) {
          return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc2 = getEventTargetDocument(nativeEventTarget);
          if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc2)) {
            return;
          }
          var currentSelection = getSelection$1(activeElement$1);
          if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.target = activeElement$1;
            }
          }
        }
        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                activeElement$1 = targetNode;
                activeElementInst$1 = targetInst;
                lastSelection = null;
              }
              break;
            case "focusout":
              activeElement$1 = null;
              activeElementInst$1 = null;
              lastSelection = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) {
                break;
              }
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
        }
        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (reactName === void 0) {
            return;
          }
          var SyntheticEventCtor = SyntheticEvent;
          var reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (getEventCharCode(nativeEvent) === 0) {
                return;
              }
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (nativeEvent.button === 2) {
                return;
              }
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
          }
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          {
            var accumulateTargetOnly = !inCapturePhase && domEventName === "scroll";
            var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
            if (_listeners.length > 0) {
              var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event: _event,
                listeners: _listeners
              });
            }
          }
        }
        registerSimpleEvents();
        registerEvents$2();
        registerEvents$1();
        registerEvents$3();
        registerEvents();
        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
          if (shouldProcessPolyfillPlugins) {
            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
        }
        var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
        var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
        function executeDispatch(event, listener, currentTarget) {
          var type = event.type || "unknown-event";
          event.currentTarget = currentTarget;
          invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
          event.currentTarget = null;
        }
        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
          var previousInstance;
          if (inCapturePhase) {
            for (var i = dispatchListeners.length - 1; i >= 0; i--) {
              var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, listener, currentTarget);
              previousInstance = instance;
            }
          } else {
            for (var _i = 0; _i < dispatchListeners.length; _i++) {
              var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
              if (_instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, _listener, _currentTarget);
              previousInstance = _instance;
            }
          }
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          for (var i = 0; i < dispatchQueue.length; i++) {
            var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
            processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
          }
          rethrowCaughtError();
        }
        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var nativeEventTarget = getEventTarget(nativeEvent);
          var dispatchQueue = [];
          extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          var isCapturePhaseListener = false;
          var listenerSet = getEventListenerSet(targetElement);
          var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
          if (!listenerSet.has(listenerSetKey)) {
            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
          }
        }
        var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
        function listenToAllSupportedEvents(rootContainerElement) {
          {
            if (rootContainerElement[listeningMarker]) {
              return;
            }
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              if (!nonDelegatedEvents.has(domEventName)) {
                listenToNativeEvent(domEventName, false, rootContainerElement, null);
              }
              listenToNativeEvent(domEventName, true, rootContainerElement, null);
            });
          }
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {
          var eventSystemFlags = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
          var target = rootContainerElement;
          if (domEventName === "selectionchange" && rootContainerElement.nodeType !== DOCUMENT_NODE) {
            target = rootContainerElement.ownerDocument;
          }
          if (targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {
            if (domEventName !== "scroll") {
              return;
            }
            eventSystemFlags |= IS_NON_DELEGATED;
            target = targetElement;
          }
          var listenerSet = getEventListenerSet(target);
          var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
          if (!listenerSet.has(listenerSetKey)) {
            if (isCapturePhaseListener) {
              eventSystemFlags |= IS_CAPTURE_PHASE;
            }
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
          var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
          var isPassiveListener = void 0;
          if (passiveBrowserEventsSupported) {
            if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
              isPassiveListener = true;
            }
          }
          targetContainer = targetContainer;
          var unsubscribeListener;
          if (isCapturePhaseListener) {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
            }
          } else {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
            }
          }
        }
        function isMatchingRootContainer(grandContainer, targetContainer) {
          return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var ancestorInst = targetInst;
          if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
            var targetContainerNode = targetContainer;
            if (targetInst !== null) {
              var node = targetInst;
              mainLoop:
                while (true) {
                  if (node === null) {
                    return;
                  }
                  var nodeTag = node.tag;
                  if (nodeTag === HostRoot || nodeTag === HostPortal) {
                    var container = node.stateNode.containerInfo;
                    if (isMatchingRootContainer(container, targetContainerNode)) {
                      break;
                    }
                    if (nodeTag === HostPortal) {
                      var grandNode = node.return;
                      while (grandNode !== null) {
                        var grandTag = grandNode.tag;
                        if (grandTag === HostRoot || grandTag === HostPortal) {
                          var grandContainer = grandNode.stateNode.containerInfo;
                          if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                            return;
                          }
                        }
                        grandNode = grandNode.return;
                      }
                    }
                    while (container !== null) {
                      var parentNode = getClosestInstanceFromNode(container);
                      if (parentNode === null) {
                        return;
                      }
                      var parentTag = parentNode.tag;
                      if (parentTag === HostComponent || parentTag === HostText) {
                        node = ancestorInst = parentNode;
                        continue mainLoop;
                      }
                      container = container.parentNode;
                    }
                  }
                  node = node.return;
                }
            }
          }
          batchedEventUpdates(function() {
            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly) {
          var captureName = reactName !== null ? reactName + "Capture" : null;
          var reactEventName = inCapturePhase ? captureName : reactName;
          var listeners = [];
          var instance = targetFiber;
          var lastHostComponent = null;
          while (instance !== null) {
            var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
            if (tag === HostComponent && stateNode !== null) {
              lastHostComponent = stateNode;
              if (reactEventName !== null) {
                var listener = getListener(instance, reactEventName);
                if (listener != null) {
                  listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                }
              }
            }
            if (accumulateTargetOnly) {
              break;
            }
            instance = instance.return;
          }
          return listeners;
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          var captureName = reactName + "Capture";
          var listeners = [];
          var instance = targetFiber;
          while (instance !== null) {
            var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              var captureListener = getListener(instance, captureName);
              if (captureListener != null) {
                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
              }
              var bubbleListener = getListener(instance, reactName);
              if (bubbleListener != null) {
                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
              }
            }
            instance = instance.return;
          }
          return listeners;
        }
        function getParent(inst) {
          if (inst === null) {
            return null;
          }
          do {
            inst = inst.return;
          } while (inst && inst.tag !== HostComponent);
          if (inst) {
            return inst;
          }
          return null;
        }
        function getLowestCommonAncestor(instA, instB) {
          var nodeA = instA;
          var nodeB = instB;
          var depthA = 0;
          for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
            depthA++;
          }
          var depthB = 0;
          for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
            depthB++;
          }
          while (depthA - depthB > 0) {
            nodeA = getParent(nodeA);
            depthA--;
          }
          while (depthB - depthA > 0) {
            nodeB = getParent(nodeB);
            depthB--;
          }
          var depth = depthA;
          while (depth--) {
            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
              return nodeA;
            }
            nodeA = getParent(nodeA);
            nodeB = getParent(nodeB);
          }
          return null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          var registrationName = event._reactName;
          var listeners = [];
          var instance = target;
          while (instance !== null) {
            if (instance === common) {
              break;
            }
            var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
            if (alternate !== null && alternate === common) {
              break;
            }
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              if (inCapturePhase) {
                var captureListener = getListener(instance, registrationName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
              } else if (!inCapturePhase) {
                var bubbleListener = getListener(instance, registrationName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
            }
            instance = instance.return;
          }
          if (listeners.length !== 0) {
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
          var common = from && to ? getLowestCommonAncestor(from, to) : null;
          if (from !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
          }
          if (to !== null && enterEvent !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
          }
        }
        function getListenerSetKey(domEventName, capture) {
          return domEventName + "__" + (capture ? "capture" : "bubble");
        }
        var didWarnInvalidHydration = false;
        var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
        var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
        var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
        var AUTOFOCUS = "autoFocus";
        var CHILDREN = "children";
        var STYLE = "style";
        var HTML$1 = "__html";
        var HTML_NAMESPACE$1 = Namespaces.html;
        var warnedUnknownTags;
        var suppressHydrationWarning;
        var validatePropertiesInDevelopment;
        var warnForTextDifference;
        var warnForPropDifference;
        var warnForExtraAttributes;
        var warnForInvalidEventListener;
        var canDiffStyleForHydrationWarning;
        var normalizeMarkupForTextOrAttribute;
        var normalizeHTML;
        {
          warnedUnknownTags = {
            dialog: true,
            webview: true
          };
          validatePropertiesInDevelopment = function(type, props) {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, {
              registrationNameDependencies,
              possibleRegistrationNames
            });
          };
          canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
          var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
          var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
          normalizeMarkupForTextOrAttribute = function(markup) {
            var markupString = typeof markup === "string" ? markup : "" + markup;
            return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
          };
          warnForTextDifference = function(serverText, clientText) {
            if (didWarnInvalidHydration) {
              return;
            }
            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
            var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
            if (normalizedServerText === normalizedClientText) {
              return;
            }
            didWarnInvalidHydration = true;
            error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
          };
          warnForPropDifference = function(propName, serverValue, clientValue) {
            if (didWarnInvalidHydration) {
              return;
            }
            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
            var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
            if (normalizedServerValue === normalizedClientValue) {
              return;
            }
            didWarnInvalidHydration = true;
            error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
          };
          warnForExtraAttributes = function(attributeNames) {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            var names = [];
            attributeNames.forEach(function(name2) {
              names.push(name2);
            });
            error("Extra attributes from the server: %s", names);
          };
          warnForInvalidEventListener = function(registrationName, listener) {
            if (listener === false) {
              error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
            } else {
              error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
            }
          };
          normalizeHTML = function(parent, html) {
            var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
            testElement.innerHTML = html;
            return testElement.innerHTML;
          };
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function noop() {
        }
        function trapClickOnNonInteractiveElement(node) {
          node.onclick = noop;
        }
        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
          for (var propKey in nextProps) {
            if (!nextProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = nextProps[propKey];
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              setValueForStyles(domElement, nextProp);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              if (nextHtml != null) {
                setInnerHTML(domElement, nextHtml);
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                var canSetTextContent = tag !== "textarea" || nextProp !== "";
                if (canSetTextContent) {
                  setTextContent(domElement, nextProp);
                }
              } else if (typeof nextProp === "number") {
                setTextContent(domElement, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (nextProp != null) {
              setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
            }
          }
        }
        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
          for (var i = 0; i < updatePayload.length; i += 2) {
            var propKey = updatePayload[i];
            var propValue = updatePayload[i + 1];
            if (propKey === STYLE) {
              setValueForStyles(domElement, propValue);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              setInnerHTML(domElement, propValue);
            } else if (propKey === CHILDREN) {
              setTextContent(domElement, propValue);
            } else {
              setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
            }
          }
        }
        function createElement(type, props, rootContainerElement, parentNamespace) {
          var isCustomComponentTag;
          var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
          var domElement;
          var namespaceURI = parentNamespace;
          if (namespaceURI === HTML_NAMESPACE$1) {
            namespaceURI = getIntrinsicNamespace(type);
          }
          if (namespaceURI === HTML_NAMESPACE$1) {
            {
              isCustomComponentTag = isCustomComponent(type, props);
              if (!isCustomComponentTag && type !== type.toLowerCase()) {
                error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
              }
            }
            if (type === "script") {
              var div = ownerDocument.createElement("div");
              div.innerHTML = "<script><\/script>";
              var firstChild = div.firstChild;
              domElement = div.removeChild(firstChild);
            } else if (typeof props.is === "string") {
              domElement = ownerDocument.createElement(type, {
                is: props.is
              });
            } else {
              domElement = ownerDocument.createElement(type);
              if (type === "select") {
                var node = domElement;
                if (props.multiple) {
                  node.multiple = true;
                } else if (props.size) {
                  node.size = props.size;
                }
              }
            }
          } else {
            domElement = ownerDocument.createElementNS(namespaceURI, type);
          }
          {
            if (namespaceURI === HTML_NAMESPACE$1) {
              if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
                warnedUnknownTags[type] = true;
                error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
              }
            }
          }
          return domElement;
        }
        function createTextNode(text, rootContainerElement) {
          return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
        }
        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
          var isCustomComponentTag = isCustomComponent(tag, rawProps);
          {
            validatePropertiesInDevelopment(tag, rawProps);
          }
          var props;
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              props = rawProps;
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "video":
            case "audio":
              for (var i = 0; i < mediaEventTypes.length; i++) {
                listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
              }
              props = rawProps;
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              props = rawProps;
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              props = rawProps;
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              props = rawProps;
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              props = getHostProps(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              props = getHostProps$1(domElement, rawProps);
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              props = getHostProps$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              props = getHostProps$3(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            default:
              props = rawProps;
          }
          assertValidProps(tag, props);
          setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, false);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "option":
              postMountWrapper$1(domElement, rawProps);
              break;
            case "select":
              postMountWrapper$2(domElement, rawProps);
              break;
            default:
              if (typeof props.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
        }
        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
          {
            validatePropertiesInDevelopment(tag, nextRawProps);
          }
          var updatePayload = null;
          var lastProps;
          var nextProps;
          switch (tag) {
            case "input":
              lastProps = getHostProps(domElement, lastRawProps);
              nextProps = getHostProps(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "option":
              lastProps = getHostProps$1(domElement, lastRawProps);
              nextProps = getHostProps$1(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "select":
              lastProps = getHostProps$2(domElement, lastRawProps);
              nextProps = getHostProps$2(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "textarea":
              lastProps = getHostProps$3(domElement, lastRawProps);
              nextProps = getHostProps$3(domElement, nextRawProps);
              updatePayload = [];
              break;
            default:
              lastProps = lastRawProps;
              nextProps = nextRawProps;
              if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          assertValidProps(tag, nextProps);
          var propKey;
          var styleName;
          var styleUpdates = null;
          for (propKey in lastProps) {
            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
              continue;
            }
            if (propKey === STYLE) {
              var lastStyle = lastProps[propKey];
              for (styleName in lastStyle) {
                if (lastStyle.hasOwnProperty(styleName)) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
              ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (propKey === AUTOFOCUS)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (!updatePayload) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, null);
            }
          }
          for (propKey in nextProps) {
            var nextProp = nextProps[propKey];
            var lastProp = lastProps != null ? lastProps[propKey] : void 0;
            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
              continue;
            }
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              if (lastProp) {
                for (styleName in lastProp) {
                  if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
                for (styleName in nextProp) {
                  if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = nextProp[styleName];
                  }
                }
              } else {
                if (!styleUpdates) {
                  if (!updatePayload) {
                    updatePayload = [];
                  }
                  updatePayload.push(propKey, styleUpdates);
                }
                styleUpdates = nextProp;
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
              if (nextHtml != null) {
                if (lastHtml !== nextHtml) {
                  (updatePayload = updatePayload || []).push(propKey, nextHtml);
                }
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string" || typeof nextProp === "number") {
                (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
              ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
              if (!updatePayload && lastProp !== nextProp) {
                updatePayload = [];
              }
            } else if (typeof nextProp === "object" && nextProp !== null && nextProp.$$typeof === REACT_OPAQUE_ID_TYPE) {
              nextProp.toString();
            } else {
              (updatePayload = updatePayload || []).push(propKey, nextProp);
            }
          }
          if (styleUpdates) {
            {
              validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
            }
            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
          }
          return updatePayload;
        }
        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
          if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
            updateChecked(domElement, nextRawProps);
          }
          var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
          var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
          updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
          switch (tag) {
            case "input":
              updateWrapper(domElement, nextRawProps);
              break;
            case "textarea":
              updateWrapper$1(domElement, nextRawProps);
              break;
            case "select":
              postUpdateWrapper(domElement, nextRawProps);
              break;
          }
        }
        function getPossibleStandardName(propName) {
          {
            var lowerCasedName = propName.toLowerCase();
            if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              return null;
            }
            return possibleStandardNames[lowerCasedName] || null;
          }
        }
        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
          var isCustomComponentTag;
          var extraAttributeNames;
          {
            suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;
            isCustomComponentTag = isCustomComponent(tag, rawProps);
            validatePropertiesInDevelopment(tag, rawProps);
          }
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (var i = 0; i < mediaEventTypes.length; i++) {
                listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
              }
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
          }
          assertValidProps(tag, rawProps);
          {
            extraAttributeNames = new Set();
            var attributes = domElement.attributes;
            for (var _i = 0; _i < attributes.length; _i++) {
              var name2 = attributes[_i].name.toLowerCase();
              switch (name2) {
                case "data-reactroot":
                  break;
                case "value":
                  break;
                case "checked":
                  break;
                case "selected":
                  break;
                default:
                  extraAttributeNames.add(attributes[_i].name);
              }
            }
          }
          var updatePayload = null;
          for (var propKey in rawProps) {
            if (!rawProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = rawProps[propKey];
            if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                if (domElement.textContent !== nextProp) {
                  if (!suppressHydrationWarning) {
                    warnForTextDifference(domElement.textContent, nextProp);
                  }
                  updatePayload = [CHILDREN, nextProp];
                }
              } else if (typeof nextProp === "number") {
                if (domElement.textContent !== "" + nextProp) {
                  if (!suppressHydrationWarning) {
                    warnForTextDifference(domElement.textContent, nextProp);
                  }
                  updatePayload = [CHILDREN, "" + nextProp];
                }
              }
            } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (typeof isCustomComponentTag === "boolean") {
              var serverValue = void 0;
              var propertyInfo = getPropertyInfo(propKey);
              if (suppressHydrationWarning)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === "value" || propKey === "checked" || propKey === "selected")
                ;
              else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var serverHTML = domElement.innerHTML;
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  var expectedHTML = normalizeHTML(domElement, nextHtml);
                  if (expectedHTML !== serverHTML) {
                    warnForPropDifference(propKey, serverHTML, expectedHTML);
                  }
                }
              } else if (propKey === STYLE) {
                extraAttributeNames.delete(propKey);
                if (canDiffStyleForHydrationWarning) {
                  var expectedStyle = createDangerousStringForStyles(nextProp);
                  serverValue = domElement.getAttribute("style");
                  if (expectedStyle !== serverValue) {
                    warnForPropDifference(propKey, serverValue, expectedStyle);
                  }
                }
              } else if (isCustomComponentTag) {
                extraAttributeNames.delete(propKey.toLowerCase());
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
                if (nextProp !== serverValue) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                var isMismatchDueToBadCasing = false;
                if (propertyInfo !== null) {
                  extraAttributeNames.delete(propertyInfo.attributeName);
                  serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                } else {
                  var ownNamespace = parentNamespace;
                  if (ownNamespace === HTML_NAMESPACE$1) {
                    ownNamespace = getIntrinsicNamespace(tag);
                  }
                  if (ownNamespace === HTML_NAMESPACE$1) {
                    extraAttributeNames.delete(propKey.toLowerCase());
                  } else {
                    var standardName = getPossibleStandardName(propKey);
                    if (standardName !== null && standardName !== propKey) {
                      isMismatchDueToBadCasing = true;
                      extraAttributeNames.delete(standardName);
                    }
                    extraAttributeNames.delete(propKey);
                  }
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                }
                if (nextProp !== serverValue && !isMismatchDueToBadCasing) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              }
            }
          }
          {
            if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
              warnForExtraAttributes(extraAttributeNames);
            }
          }
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, true);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "select":
            case "option":
              break;
            default:
              if (typeof rawProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          return updatePayload;
        }
        function diffHydratedText(textNode, text) {
          var isDifferent = textNode.nodeValue !== text;
          return isDifferent;
        }
        function warnForUnmatchedText(textNode, text) {
          {
            warnForTextDifference(textNode.nodeValue, text);
          }
        }
        function warnForDeletedHydratableElement(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
          }
        }
        function warnForDeletedHydratableText(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedElement(parentNode, tag, props) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedText(parentNode, text) {
          {
            if (text === "") {
              return;
            }
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
          }
        }
        function restoreControlledState$3(domElement, tag, props) {
          switch (tag) {
            case "input":
              restoreControlledState(domElement, props);
              return;
            case "textarea":
              restoreControlledState$2(domElement, props);
              return;
            case "select":
              restoreControlledState$1(domElement, props);
              return;
          }
        }
        var validateDOMNesting = function() {
        };
        var updatedAncestorInfo = function() {
        };
        {
          var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
          var inScopeTags = [
            "applet",
            "caption",
            "html",
            "table",
            "td",
            "th",
            "marquee",
            "object",
            "template",
            "foreignObject",
            "desc",
            "title"
          ];
          var buttonScopeTags = inScopeTags.concat(["button"]);
          var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
          var emptyAncestorInfo = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null
          };
          updatedAncestorInfo = function(oldInfo, tag) {
            var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
            var info = {
              tag
            };
            if (inScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.aTagInScope = null;
              ancestorInfo.buttonTagInScope = null;
              ancestorInfo.nobrTagInScope = null;
            }
            if (buttonScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.pTagInButtonScope = null;
            }
            if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
              ancestorInfo.listItemTagAutoclosing = null;
              ancestorInfo.dlItemTagAutoclosing = null;
            }
            ancestorInfo.current = info;
            if (tag === "form") {
              ancestorInfo.formTag = info;
            }
            if (tag === "a") {
              ancestorInfo.aTagInScope = info;
            }
            if (tag === "button") {
              ancestorInfo.buttonTagInScope = info;
            }
            if (tag === "nobr") {
              ancestorInfo.nobrTagInScope = info;
            }
            if (tag === "p") {
              ancestorInfo.pTagInButtonScope = info;
            }
            if (tag === "li") {
              ancestorInfo.listItemTagAutoclosing = info;
            }
            if (tag === "dd" || tag === "dt") {
              ancestorInfo.dlItemTagAutoclosing = info;
            }
            return ancestorInfo;
          };
          var isTagValidWithParent = function(tag, parentTag) {
            switch (parentTag) {
              case "select":
                return tag === "option" || tag === "optgroup" || tag === "#text";
              case "optgroup":
                return tag === "option" || tag === "#text";
              case "option":
                return tag === "#text";
              case "tr":
                return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
              case "tbody":
              case "thead":
              case "tfoot":
                return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
              case "colgroup":
                return tag === "col" || tag === "template";
              case "table":
                return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
              case "head":
                return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
              case "html":
                return tag === "head" || tag === "body" || tag === "frameset";
              case "frameset":
                return tag === "frame";
              case "#document":
                return tag === "html";
            }
            switch (tag) {
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
              case "rp":
              case "rt":
                return impliedEndTags.indexOf(parentTag) === -1;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "frameset":
              case "frame":
              case "head":
              case "html":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return parentTag == null;
            }
            return true;
          };
          var findInvalidAncestorForTag = function(tag, ancestorInfo) {
            switch (tag) {
              case "address":
              case "article":
              case "aside":
              case "blockquote":
              case "center":
              case "details":
              case "dialog":
              case "dir":
              case "div":
              case "dl":
              case "fieldset":
              case "figcaption":
              case "figure":
              case "footer":
              case "header":
              case "hgroup":
              case "main":
              case "menu":
              case "nav":
              case "ol":
              case "p":
              case "section":
              case "summary":
              case "ul":
              case "pre":
              case "listing":
              case "table":
              case "hr":
              case "xmp":
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return ancestorInfo.pTagInButtonScope;
              case "form":
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
              case "li":
                return ancestorInfo.listItemTagAutoclosing;
              case "dd":
              case "dt":
                return ancestorInfo.dlItemTagAutoclosing;
              case "button":
                return ancestorInfo.buttonTagInScope;
              case "a":
                return ancestorInfo.aTagInScope;
              case "nobr":
                return ancestorInfo.nobrTagInScope;
            }
            return null;
          };
          var didWarn$1 = {};
          validateDOMNesting = function(childTag, childText, ancestorInfo) {
            ancestorInfo = ancestorInfo || emptyAncestorInfo;
            var parentInfo = ancestorInfo.current;
            var parentTag = parentInfo && parentInfo.tag;
            if (childText != null) {
              if (childTag != null) {
                error("validateDOMNesting: when childText is passed, childTag should be null");
              }
              childTag = "#text";
            }
            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
            var invalidParentOrAncestor = invalidParent || invalidAncestor;
            if (!invalidParentOrAncestor) {
              return;
            }
            var ancestorTag = invalidParentOrAncestor.tag;
            var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
            if (didWarn$1[warnKey]) {
              return;
            }
            didWarn$1[warnKey] = true;
            var tagDisplayName = childTag;
            var whitespaceInfo = "";
            if (childTag === "#text") {
              if (/\S/.test(childText)) {
                tagDisplayName = "Text nodes";
              } else {
                tagDisplayName = "Whitespace text nodes";
                whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
              }
            } else {
              tagDisplayName = "<" + childTag + ">";
            }
            if (invalidParent) {
              var info = "";
              if (ancestorTag === "table" && childTag === "tr") {
                info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
              }
              error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
            } else {
              error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
            }
          };
        }
        var SUPPRESS_HYDRATION_WARNING$1;
        {
          SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
        }
        var SUSPENSE_START_DATA = "$";
        var SUSPENSE_END_DATA = "/$";
        var SUSPENSE_PENDING_START_DATA = "$?";
        var SUSPENSE_FALLBACK_START_DATA = "$!";
        var STYLE$1 = "style";
        var eventsEnabled = null;
        var selectionInformation = null;
        function shouldAutoFocusHostComponent(type, props) {
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              return !!props.autoFocus;
          }
          return false;
        }
        function getRootHostContext(rootContainerInstance) {
          var type;
          var namespace;
          var nodeType = rootContainerInstance.nodeType;
          switch (nodeType) {
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE: {
              type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
              var root2 = rootContainerInstance.documentElement;
              namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
              break;
            }
            default: {
              var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
              var ownNamespace = container.namespaceURI || null;
              type = container.tagName;
              namespace = getChildNamespace(ownNamespace, type);
              break;
            }
          }
          {
            var validatedTag = type.toLowerCase();
            var ancestorInfo = updatedAncestorInfo(null, validatedTag);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getChildHostContext(parentHostContext, type, rootContainerInstance) {
          {
            var parentHostContextDev = parentHostContext;
            var namespace = getChildNamespace(parentHostContextDev.namespace, type);
            var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
            return {
              namespace,
              ancestorInfo
            };
          }
        }
        function getPublicInstance(instance) {
          return instance;
        }
        function prepareForCommit(containerInfo) {
          eventsEnabled = isEnabled();
          selectionInformation = getSelectionInformation();
          var activeInstance = null;
          setEnabled(false);
          return activeInstance;
        }
        function resetAfterCommit(containerInfo) {
          restoreSelection(selectionInformation);
          setEnabled(eventsEnabled);
          eventsEnabled = null;
          selectionInformation = null;
        }
        function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            validateDOMNesting(type, null, hostContextDev.ancestorInfo);
            if (typeof props.children === "string" || typeof props.children === "number") {
              var string2 = "" + props.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
              validateDOMNesting(null, string2, ownAncestorInfo);
            }
            parentNamespace = hostContextDev.namespace;
          }
          var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
          precacheFiberNode(internalInstanceHandle, domElement);
          updateFiberProps(domElement, props);
          return domElement;
        }
        function appendInitialChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
          setInitialProperties(domElement, type, props, rootContainerInstance);
          return shouldAutoFocusHostComponent(type, props);
        }
        function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
          {
            var hostContextDev = hostContext;
            if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
              var string2 = "" + newProps.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
              validateDOMNesting(null, string2, ownAncestorInfo);
            }
          }
          return diffProperties(domElement, type, oldProps, newProps);
        }
        function shouldSetTextContent(type, props) {
          return type === "textarea" || type === "option" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
        }
        function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
          {
            var hostContextDev = hostContext;
            validateDOMNesting(null, text, hostContextDev.ancestorInfo);
          }
          var textNode = createTextNode(text, rootContainerInstance);
          precacheFiberNode(internalInstanceHandle, textNode);
          return textNode;
        }
        var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
        var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
        var noTimeout = -1;
        function commitMount(domElement, type, newProps, internalInstanceHandle) {
          if (shouldAutoFocusHostComponent(type, newProps)) {
            domElement.focus();
          }
        }
        function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
          updateFiberProps(domElement, newProps);
          updateProperties(domElement, updatePayload, type, oldProps, newProps);
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function appendChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function appendChildToContainer(container, child) {
          var parentNode;
          if (container.nodeType === COMMENT_NODE) {
            parentNode = container.parentNode;
            parentNode.insertBefore(child, container);
          } else {
            parentNode = container;
            parentNode.appendChild(child);
          }
          var reactRootContainer = container._reactRootContainer;
          if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
            trapClickOnNonInteractiveElement(parentNode);
          }
        }
        function insertBefore(parentInstance, child, beforeChild) {
          parentInstance.insertBefore(child, beforeChild);
        }
        function insertInContainerBefore(container, child, beforeChild) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.insertBefore(child, beforeChild);
          } else {
            container.insertBefore(child, beforeChild);
          }
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.removeChild(child);
          } else {
            container.removeChild(child);
          }
        }
        function hideInstance(instance) {
          instance = instance;
          var style2 = instance.style;
          if (typeof style2.setProperty === "function") {
            style2.setProperty("display", "none", "important");
          } else {
            style2.display = "none";
          }
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance, props) {
          instance = instance;
          var styleProp = props[STYLE$1];
          var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
          instance.style.display = dangerousStyleValue("display", display);
        }
        function unhideTextInstance(textInstance, text) {
          textInstance.nodeValue = text;
        }
        function clearContainer(container) {
          if (container.nodeType === ELEMENT_NODE) {
            container.textContent = "";
          } else if (container.nodeType === DOCUMENT_NODE) {
            var body = container.body;
            if (body != null) {
              body.textContent = "";
            }
          }
        }
        function canHydrateInstance(instance, type, props) {
          if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
            return null;
          }
          return instance;
        }
        function canHydrateTextInstance(instance, text) {
          if (text === "" || instance.nodeType !== TEXT_NODE) {
            return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return instance.data === SUSPENSE_PENDING_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA;
        }
        function getNextHydratable(node) {
          for (; node != null; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
              break;
            }
          }
          return node;
        }
        function getNextHydratableSibling(instance) {
          return getNextHydratable(instance.nextSibling);
        }
        function getFirstHydratableChild(parentInstance) {
          return getNextHydratable(parentInstance.firstChild);
        }
        function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
          precacheFiberNode(internalInstanceHandle, instance);
          updateFiberProps(instance, props);
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            parentNamespace = hostContextDev.namespace;
          }
          return diffHydratedProperties(instance, type, props, parentNamespace);
        }
        function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
          precacheFiberNode(internalInstanceHandle, textInstance);
          return diffHydratedText(textInstance, text);
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          var node = suspenseInstance.nextSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  return getNextHydratableSibling(node);
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                depth++;
              }
            }
            node = node.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          var node = targetInstance.previousSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                if (depth === 0) {
                  return node;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_END_DATA) {
                depth++;
              }
            }
            node = node.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
          {
            warnForUnmatchedText(textInstance, text);
          }
        }
        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            warnForUnmatchedText(textInstance, text);
          }
        }
        function didNotHydrateContainerInstance(parentContainer, instance) {
          {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentContainer, instance);
            } else if (instance.nodeType === COMMENT_NODE)
              ;
            else {
              warnForDeletedHydratableText(parentContainer, instance);
            }
          }
        }
        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentInstance, instance);
            } else if (instance.nodeType === COMMENT_NODE)
              ;
            else {
              warnForDeletedHydratableText(parentInstance, instance);
            }
          }
        }
        function didNotFindHydratableContainerInstance(parentContainer, type, props) {
          {
            warnForInsertedHydratedElement(parentContainer, type);
          }
        }
        function didNotFindHydratableContainerTextInstance(parentContainer, text) {
          {
            warnForInsertedHydratedText(parentContainer, text);
          }
        }
        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            warnForInsertedHydratedElement(parentInstance, type);
          }
        }
        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            warnForInsertedHydratedText(parentInstance, text);
          }
        }
        function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true)
            ;
        }
        var clientId = 0;
        function makeClientIdInDEV(warnOnAccessInDEV) {
          var id = "r:" + (clientId++).toString(36);
          return {
            toString: function() {
              warnOnAccessInDEV();
              return id;
            },
            valueOf: function() {
              warnOnAccessInDEV();
              return id;
            }
          };
        }
        function isOpaqueHydratingObject(value) {
          return value !== null && typeof value === "object" && value.$$typeof === REACT_OPAQUE_ID_TYPE;
        }
        function makeOpaqueHydratingObject(attemptToReadValue) {
          return {
            $$typeof: REACT_OPAQUE_ID_TYPE,
            toString: attemptToReadValue,
            valueOf: attemptToReadValue
          };
        }
        function preparePortalMount(portalInstance) {
          {
            listenToAllSupportedEvents(portalInstance);
          }
        }
        var randomKey = Math.random().toString(36).slice(2);
        var internalInstanceKey = "__reactFiber$" + randomKey;
        var internalPropsKey = "__reactProps$" + randomKey;
        var internalContainerInstanceKey = "__reactContainer$" + randomKey;
        var internalEventHandlersKey = "__reactEvents$" + randomKey;
        function precacheFiberNode(hostInst, node) {
          node[internalInstanceKey] = hostInst;
        }
        function markContainerAsRoot(hostRoot, node) {
          node[internalContainerInstanceKey] = hostRoot;
        }
        function unmarkContainerAsRoot(node) {
          node[internalContainerInstanceKey] = null;
        }
        function isContainerMarkedAsRoot(node) {
          return !!node[internalContainerInstanceKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) {
            return targetInst;
          }
          var parentNode = targetNode.parentNode;
          while (parentNode) {
            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
            if (targetInst) {
              var alternate = targetInst.alternate;
              if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                var suspenseInstance = getParentSuspenseInstance(targetNode);
                while (suspenseInstance !== null) {
                  var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                  if (targetSuspenseInst) {
                    return targetSuspenseInst;
                  }
                  suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                }
              }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
          if (inst) {
            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
              return inst;
            } else {
              return null;
            }
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          if (inst.tag === HostComponent || inst.tag === HostText) {
            return inst.stateNode;
          }
          {
            {
              throw Error("getNodeFromInstance: Invalid argument.");
            }
          }
        }
        function getFiberCurrentPropsFromNode(node) {
          return node[internalPropsKey] || null;
        }
        function updateFiberProps(node, props) {
          node[internalPropsKey] = props;
        }
        function getEventListenerSet(node) {
          var elementListenerSet = node[internalEventHandlersKey];
          if (elementListenerSet === void 0) {
            elementListenerSet = node[internalEventHandlersKey] = new Set();
          }
          return elementListenerSet;
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has2 = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has2(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var valueStack = [];
        var fiberStack;
        {
          fiberStack = [];
        }
        var index = -1;
        function createCursor(defaultValue) {
          return {
            current: defaultValue
          };
        }
        function pop(cursor, fiber) {
          if (index < 0) {
            {
              error("Unexpected pop.");
            }
            return;
          }
          {
            if (fiber !== fiberStack[index]) {
              error("Unexpected Fiber popped.");
            }
          }
          cursor.current = valueStack[index];
          valueStack[index] = null;
          {
            fiberStack[index] = null;
          }
          index--;
        }
        function push(cursor, value, fiber) {
          index++;
          valueStack[index] = cursor.current;
          {
            fiberStack[index] = fiber;
          }
          cursor.current = value;
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        var contextStackCursor = createCursor(emptyContextObject);
        var didPerformWorkStackCursor = createCursor(false);
        var previousContext = emptyContextObject;
        function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
          {
            if (didPushOwnContextIfProvider && isContextProvider(Component)) {
              return previousContext;
            }
            return contextStackCursor.current;
          }
        }
        function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
          {
            var instance = workInProgress2.stateNode;
            instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
            instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
          }
        }
        function getMaskedContext(workInProgress2, unmaskedContext) {
          {
            var type = workInProgress2.type;
            var contextTypes = type.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var instance = workInProgress2.stateNode;
            if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
              return instance.__reactInternalMemoizedMaskedChildContext;
            }
            var context = {};
            for (var key in contextTypes) {
              context[key] = unmaskedContext[key];
            }
            {
              var name2 = getComponentName(type) || "Unknown";
              checkPropTypes(contextTypes, context, "context", name2);
            }
            if (instance) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return context;
          }
        }
        function hasContextChanged() {
          {
            return didPerformWorkStackCursor.current;
          }
        }
        function isContextProvider(type) {
          {
            var childContextTypes = type.childContextTypes;
            return childContextTypes !== null && childContextTypes !== void 0;
          }
        }
        function popContext(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function popTopLevelContextObject(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function pushTopLevelContextObject(fiber, context, didChange) {
          {
            if (!(contextStackCursor.current === emptyContextObject)) {
              {
                throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            push(contextStackCursor, context, fiber);
            push(didPerformWorkStackCursor, didChange, fiber);
          }
        }
        function processChildContext(fiber, type, parentContext) {
          {
            var instance = fiber.stateNode;
            var childContextTypes = type.childContextTypes;
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentName(type) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                {
                  throw Error((getComponentName(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
            }
            {
              var name2 = getComponentName(type) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name2);
            }
            return _assign({}, parentContext, childContext);
          }
        }
        function pushContextProvider(workInProgress2) {
          {
            var instance = workInProgress2.stateNode;
            var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
            previousContext = contextStackCursor.current;
            push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
            push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
            return true;
          }
        }
        function invalidateContextProvider(workInProgress2, type, didChange) {
          {
            var instance = workInProgress2.stateNode;
            if (!instance) {
              {
                throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (didChange) {
              var mergedContext = processChildContext(workInProgress2, type, previousContext);
              instance.__reactInternalMemoizedMergedChildContext = mergedContext;
              pop(didPerformWorkStackCursor, workInProgress2);
              pop(contextStackCursor, workInProgress2);
              push(contextStackCursor, mergedContext, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            } else {
              pop(didPerformWorkStackCursor, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            }
          }
        }
        function findCurrentUnmaskedContext(fiber) {
          {
            if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) {
              {
                throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            var node = fiber;
            do {
              switch (node.tag) {
                case HostRoot:
                  return node.stateNode.context;
                case ClassComponent: {
                  var Component = node.type;
                  if (isContextProvider(Component)) {
                    return node.stateNode.__reactInternalMemoizedMergedChildContext;
                  }
                  break;
                }
              }
              node = node.return;
            } while (node !== null);
            {
              {
                throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
        }
        var LegacyRoot = 0;
        var BlockingRoot = 1;
        var ConcurrentRoot = 2;
        var rendererID = null;
        var injectedHook = null;
        var hasLoggedError = false;
        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
        function injectInternals(internals) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
            return false;
          }
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) {
            return true;
          }
          if (!hook.supportsFiber) {
            {
              error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
            }
            return true;
          }
          try {
            rendererID = hook.inject(internals);
            injectedHook = hook;
          } catch (err) {
            {
              error("React instrumentation encountered an error: %s.", err);
            }
          }
          return true;
        }
        function onScheduleRoot(root2, children) {
          {
            if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
              try {
                injectedHook.onScheduleFiberRoot(rendererID, root2, children);
              } catch (err) {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitRoot(root2, priorityLevel) {
          if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
            try {
              var didError = (root2.current.flags & DidCapture) === DidCapture;
              if (enableProfilerTimer) {
                injectedHook.onCommitFiberRoot(rendererID, root2, priorityLevel, didError);
              } else {
                injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
              }
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        function onCommitUnmount(fiber) {
          if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
            try {
              injectedHook.onCommitFiberUnmount(rendererID, fiber);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
        var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority, Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback, Scheduler_cancelCallback = Scheduler.unstable_cancelCallback, Scheduler_shouldYield = Scheduler.unstable_shouldYield, Scheduler_requestPaint = Scheduler.unstable_requestPaint, Scheduler_now$1 = Scheduler.unstable_now, Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority, Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, Scheduler_NormalPriority = Scheduler.unstable_NormalPriority, Scheduler_LowPriority = Scheduler.unstable_LowPriority, Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;
        {
          if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
            {
              throw Error("It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling");
            }
          }
        }
        var fakeCallbackNode = {};
        var ImmediatePriority$1 = 99;
        var UserBlockingPriority$2 = 98;
        var NormalPriority$1 = 97;
        var LowPriority$1 = 96;
        var IdlePriority$1 = 95;
        var NoPriority$1 = 90;
        var shouldYield = Scheduler_shouldYield;
        var requestPaint = Scheduler_requestPaint !== void 0 ? Scheduler_requestPaint : function() {
        };
        var syncQueue = null;
        var immediateQueueCallbackNode = null;
        var isFlushingSyncQueue = false;
        var initialTimeMs$1 = Scheduler_now$1();
        var now = initialTimeMs$1 < 1e4 ? Scheduler_now$1 : function() {
          return Scheduler_now$1() - initialTimeMs$1;
        };
        function getCurrentPriorityLevel() {
          switch (Scheduler_getCurrentPriorityLevel()) {
            case Scheduler_ImmediatePriority:
              return ImmediatePriority$1;
            case Scheduler_UserBlockingPriority:
              return UserBlockingPriority$2;
            case Scheduler_NormalPriority:
              return NormalPriority$1;
            case Scheduler_LowPriority:
              return LowPriority$1;
            case Scheduler_IdlePriority:
              return IdlePriority$1;
            default: {
              {
                throw Error("Unknown priority level.");
              }
            }
          }
        }
        function reactPriorityToSchedulerPriority(reactPriorityLevel) {
          switch (reactPriorityLevel) {
            case ImmediatePriority$1:
              return Scheduler_ImmediatePriority;
            case UserBlockingPriority$2:
              return Scheduler_UserBlockingPriority;
            case NormalPriority$1:
              return Scheduler_NormalPriority;
            case LowPriority$1:
              return Scheduler_LowPriority;
            case IdlePriority$1:
              return Scheduler_IdlePriority;
            default: {
              {
                throw Error("Unknown priority level.");
              }
            }
          }
        }
        function runWithPriority$1(reactPriorityLevel, fn) {
          var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
          return Scheduler_runWithPriority(priorityLevel, fn);
        }
        function scheduleCallback(reactPriorityLevel, callback, options2) {
          var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
          return Scheduler_scheduleCallback(priorityLevel, callback, options2);
        }
        function scheduleSyncCallback(callback) {
          if (syncQueue === null) {
            syncQueue = [callback];
            immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
          } else {
            syncQueue.push(callback);
          }
          return fakeCallbackNode;
        }
        function cancelCallback(callbackNode) {
          if (callbackNode !== fakeCallbackNode) {
            Scheduler_cancelCallback(callbackNode);
          }
        }
        function flushSyncCallbackQueue() {
          if (immediateQueueCallbackNode !== null) {
            var node = immediateQueueCallbackNode;
            immediateQueueCallbackNode = null;
            Scheduler_cancelCallback(node);
          }
          flushSyncCallbackQueueImpl();
        }
        function flushSyncCallbackQueueImpl() {
          if (!isFlushingSyncQueue && syncQueue !== null) {
            isFlushingSyncQueue = true;
            var i = 0;
            {
              try {
                var _isSync2 = true;
                var _queue = syncQueue;
                runWithPriority$1(ImmediatePriority$1, function() {
                  for (; i < _queue.length; i++) {
                    var callback = _queue[i];
                    do {
                      callback = callback(_isSync2);
                    } while (callback !== null);
                  }
                });
                syncQueue = null;
              } catch (error2) {
                if (syncQueue !== null) {
                  syncQueue = syncQueue.slice(i + 1);
                }
                Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
                throw error2;
              } finally {
                isFlushingSyncQueue = false;
              }
            }
          }
        }
        var ReactVersion = "17.0.2";
        var NoMode = 0;
        var StrictMode = 1;
        var BlockingMode = 2;
        var ConcurrentMode = 4;
        var ProfileMode = 8;
        var DebugTracingMode = 16;
        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
        var NoTransition = 0;
        function requestCurrentTransition() {
          return ReactCurrentBatchConfig.transition;
        }
        var ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function(fiber, instance) {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function(fiber, instance) {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        };
        {
          var findStrictRoot = function(fiber) {
            var maybeStrictRoot = null;
            var node = fiber;
            while (node !== null) {
              if (node.mode & StrictMode) {
                maybeStrictRoot = node;
              }
              node = node.return;
            }
            return maybeStrictRoot;
          };
          var setToSortedString = function(set2) {
            var array = [];
            set2.forEach(function(value) {
              array.push(value);
            });
            return array.sort().join(", ");
          };
          var pendingComponentWillMountWarnings = [];
          var pendingUNSAFE_ComponentWillMountWarnings = [];
          var pendingComponentWillReceivePropsWarnings = [];
          var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          var pendingComponentWillUpdateWarnings = [];
          var pendingUNSAFE_ComponentWillUpdateWarnings = [];
          var didWarnAboutUnsafeLifecycles = new Set();
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
            if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
              return;
            }
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              pendingComponentWillMountWarnings.push(fiber);
            }
            if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillMount === "function") {
              pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              pendingComponentWillReceivePropsWarnings.push(fiber);
            }
            if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              pendingComponentWillUpdateWarnings.push(fiber);
            }
            if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
              pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
            var componentWillMountUniqueNames = new Set();
            if (pendingComponentWillMountWarnings.length > 0) {
              pendingComponentWillMountWarnings.forEach(function(fiber) {
                componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillMountWarnings = [];
            }
            var UNSAFE_componentWillMountUniqueNames = new Set();
            if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
              pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillMountWarnings = [];
            }
            var componentWillReceivePropsUniqueNames = new Set();
            if (pendingComponentWillReceivePropsWarnings.length > 0) {
              pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillReceivePropsWarnings = [];
            }
            var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
            if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            }
            var componentWillUpdateUniqueNames = new Set();
            if (pendingComponentWillUpdateWarnings.length > 0) {
              pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillUpdateWarnings = [];
            }
            var UNSAFE_componentWillUpdateUniqueNames = new Set();
            if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
              pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
            }
            if (UNSAFE_componentWillMountUniqueNames.size > 0) {
              var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
              error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
            }
            if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
              error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
            }
            if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
              error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
            }
            if (componentWillMountUniqueNames.size > 0) {
              var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
              warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
            }
            if (componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
              warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
            }
            if (componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
              warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
            }
          };
          var pendingLegacyContextWarning = new Map();
          var didWarnAboutLegacyContext = new Set();
          ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
            var strictRoot = findStrictRoot(fiber);
            if (strictRoot === null) {
              error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
              return;
            }
            if (didWarnAboutLegacyContext.has(fiber.type)) {
              return;
            }
            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
            if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
              if (warningsForRoot === void 0) {
                warningsForRoot = [];
                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
              }
              warningsForRoot.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushLegacyContextWarning = function() {
            pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
              if (fiberArray.length === 0) {
                return;
              }
              var firstFiber = fiberArray[0];
              var uniqueNames = new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentName(fiber.type) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              try {
                setCurrentFiber(firstFiber);
                error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
              } finally {
                resetCurrentFiber();
              }
            });
          };
          ReactStrictModeWarnings.discardPendingWarnings = function() {
            pendingComponentWillMountWarnings = [];
            pendingUNSAFE_ComponentWillMountWarnings = [];
            pendingComponentWillReceivePropsWarnings = [];
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            pendingComponentWillUpdateWarnings = [];
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
            pendingLegacyContextWarning = new Map();
          };
        }
        function resolveDefaultProps(Component, baseProps) {
          if (Component && Component.defaultProps) {
            var props = _assign({}, baseProps);
            var defaultProps = Component.defaultProps;
            for (var propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
            return props;
          }
          return baseProps;
        }
        var MAX_SIGNED_31_BIT_INT = 1073741823;
        var valueCursor = createCursor(null);
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var currentlyRenderingFiber = null;
        var lastContextDependency = null;
        var lastContextWithAllBitsObserved = null;
        var isDisallowedContextReadInDEV = false;
        function resetContextDependencies() {
          currentlyRenderingFiber = null;
          lastContextDependency = null;
          lastContextWithAllBitsObserved = null;
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function enterDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = true;
          }
        }
        function exitDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function pushProvider(providerFiber, nextValue) {
          var context = providerFiber.type._context;
          {
            push(valueCursor, context._currentValue, providerFiber);
            context._currentValue = nextValue;
            {
              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context._currentRenderer = rendererSigil;
            }
          }
        }
        function popProvider(providerFiber) {
          var currentValue = valueCursor.current;
          pop(valueCursor, providerFiber);
          var context = providerFiber.type._context;
          {
            context._currentValue = currentValue;
          }
        }
        function calculateChangedBits(context, newValue, oldValue) {
          if (objectIs(oldValue, newValue)) {
            return 0;
          } else {
            var changedBits = typeof context._calculateChangedBits === "function" ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
            {
              if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {
                error("calculateChangedBits: Expected the return value to be a 31-bit integer. Instead received: %s", changedBits);
              }
            }
            return changedBits | 0;
          }
        }
        function scheduleWorkOnParentPath(parent, renderLanes2) {
          var node = parent;
          while (node !== null) {
            var alternate = node.alternate;
            if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
              node.childLanes = mergeLanes(node.childLanes, renderLanes2);
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            } else {
              break;
            }
            node = node.return;
          }
        }
        function propagateContextChange(workInProgress2, context, changedBits, renderLanes2) {
          var fiber = workInProgress2.child;
          if (fiber !== null) {
            fiber.return = workInProgress2;
          }
          while (fiber !== null) {
            var nextFiber = void 0;
            var list = fiber.dependencies;
            if (list !== null) {
              nextFiber = fiber.child;
              var dependency = list.firstContext;
              while (dependency !== null) {
                if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
                  if (fiber.tag === ClassComponent) {
                    var update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes2));
                    update.tag = ForceUpdate;
                    enqueueUpdate(fiber, update);
                  }
                  fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                  var alternate = fiber.alternate;
                  if (alternate !== null) {
                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                  }
                  scheduleWorkOnParentPath(fiber.return, renderLanes2);
                  list.lanes = mergeLanes(list.lanes, renderLanes2);
                  break;
                }
                dependency = dependency.next;
              }
            } else if (fiber.tag === ContextProvider) {
              nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
            } else {
              nextFiber = fiber.child;
            }
            if (nextFiber !== null) {
              nextFiber.return = fiber;
            } else {
              nextFiber = fiber;
              while (nextFiber !== null) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                var sibling = nextFiber.sibling;
                if (sibling !== null) {
                  sibling.return = nextFiber.return;
                  nextFiber = sibling;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            }
            fiber = nextFiber;
          }
        }
        function prepareToReadContext(workInProgress2, renderLanes2) {
          currentlyRenderingFiber = workInProgress2;
          lastContextDependency = null;
          lastContextWithAllBitsObserved = null;
          var dependencies = workInProgress2.dependencies;
          if (dependencies !== null) {
            var firstContext = dependencies.firstContext;
            if (firstContext !== null) {
              if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                markWorkInProgressReceivedUpdate();
              }
              dependencies.firstContext = null;
            }
          }
        }
        function readContext(context, observedBits) {
          {
            if (isDisallowedContextReadInDEV) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          if (lastContextWithAllBitsObserved === context)
            ;
          else if (observedBits === false || observedBits === 0)
            ;
          else {
            var resolvedObservedBits;
            if (typeof observedBits !== "number" || observedBits === MAX_SIGNED_31_BIT_INT) {
              lastContextWithAllBitsObserved = context;
              resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
            } else {
              resolvedObservedBits = observedBits;
            }
            var contextItem = {
              context,
              observedBits: resolvedObservedBits,
              next: null
            };
            if (lastContextDependency === null) {
              if (!(currentlyRenderingFiber !== null)) {
                {
                  throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                }
              }
              lastContextDependency = contextItem;
              currentlyRenderingFiber.dependencies = {
                lanes: NoLanes,
                firstContext: contextItem,
                responders: null
              };
            } else {
              lastContextDependency = lastContextDependency.next = contextItem;
            }
          }
          return context._currentValue;
        }
        var UpdateState = 0;
        var ReplaceState = 1;
        var ForceUpdate = 2;
        var CaptureUpdate = 3;
        var hasForceUpdate = false;
        var didWarnUpdateInsideUpdate;
        var currentlyProcessingQueue;
        {
          didWarnUpdateInsideUpdate = false;
          currentlyProcessingQueue = null;
        }
        function initializeUpdateQueue(fiber) {
          var queue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null
            },
            effects: null
          };
          fiber.updateQueue = queue;
        }
        function cloneUpdateQueue(current2, workInProgress2) {
          var queue = workInProgress2.updateQueue;
          var currentQueue = current2.updateQueue;
          if (queue === currentQueue) {
            var clone = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: currentQueue.firstBaseUpdate,
              lastBaseUpdate: currentQueue.lastBaseUpdate,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            };
            workInProgress2.updateQueue = clone;
          }
        }
        function createUpdate(eventTime, lane) {
          var update = {
            eventTime,
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
          return update;
        }
        function enqueueUpdate(fiber, update) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return;
          }
          var sharedQueue = updateQueue.shared;
          var pending = sharedQueue.pending;
          if (pending === null) {
            update.next = update;
          } else {
            update.next = pending.next;
            pending.next = update;
          }
          sharedQueue.pending = update;
          {
            if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
              error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
              didWarnUpdateInsideUpdate = true;
            }
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue;
          var current2 = workInProgress2.alternate;
          if (current2 !== null) {
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var newFirst = null;
              var newLast = null;
              var firstBaseUpdate = queue.firstBaseUpdate;
              if (firstBaseUpdate !== null) {
                var update = firstBaseUpdate;
                do {
                  var clone = {
                    eventTime: update.eventTime,
                    lane: update.lane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLast === null) {
                    newFirst = newLast = clone;
                  } else {
                    newLast.next = clone;
                    newLast = clone;
                  }
                  update = update.next;
                } while (update !== null);
                if (newLast === null) {
                  newFirst = newLast = capturedUpdate;
                } else {
                  newLast.next = capturedUpdate;
                  newLast = capturedUpdate;
                }
              } else {
                newFirst = newLast = capturedUpdate;
              }
              queue = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: newFirst,
                lastBaseUpdate: newLast,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = queue;
              return;
            }
          }
          var lastBaseUpdate = queue.lastBaseUpdate;
          if (lastBaseUpdate === null) {
            queue.firstBaseUpdate = capturedUpdate;
          } else {
            lastBaseUpdate.next = capturedUpdate;
          }
          queue.lastBaseUpdate = capturedUpdate;
        }
        function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
          switch (update.tag) {
            case ReplaceState: {
              var payload = update.payload;
              if (typeof payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                var nextState = payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictMode) {
                    disableLogs();
                    try {
                      payload.call(instance, prevState, nextProps);
                    } finally {
                      reenableLogs();
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
                return nextState;
              }
              return payload;
            }
            case CaptureUpdate: {
              workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
            }
            case UpdateState: {
              var _payload = update.payload;
              var partialState;
              if (typeof _payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                partialState = _payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictMode) {
                    disableLogs();
                    try {
                      _payload.call(instance, prevState, nextProps);
                    } finally {
                      reenableLogs();
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
              } else {
                partialState = _payload;
              }
              if (partialState === null || partialState === void 0) {
                return prevState;
              }
              return _assign({}, prevState, partialState);
            }
            case ForceUpdate: {
              hasForceUpdate = true;
              return prevState;
            }
          }
          return prevState;
        }
        function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          {
            currentlyProcessingQueue = queue.shared;
          }
          var firstBaseUpdate = queue.firstBaseUpdate;
          var lastBaseUpdate = queue.lastBaseUpdate;
          var pendingQueue = queue.shared.pending;
          if (pendingQueue !== null) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue;
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            if (lastBaseUpdate === null) {
              firstBaseUpdate = firstPendingUpdate;
            } else {
              lastBaseUpdate.next = firstPendingUpdate;
            }
            lastBaseUpdate = lastPendingUpdate;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
              if (currentLastBaseUpdate !== lastBaseUpdate) {
                if (currentLastBaseUpdate === null) {
                  currentQueue.firstBaseUpdate = firstPendingUpdate;
                } else {
                  currentLastBaseUpdate.next = firstPendingUpdate;
                }
                currentQueue.lastBaseUpdate = lastPendingUpdate;
              }
            }
          }
          if (firstBaseUpdate !== null) {
            var newState = queue.baseState;
            var newLanes = NoLanes;
            var newBaseState = null;
            var newFirstBaseUpdate = null;
            var newLastBaseUpdate = null;
            var update = firstBaseUpdate;
            do {
              var updateLane = update.lane;
              var updateEventTime = update.eventTime;
              if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                var clone = {
                  eventTime: updateEventTime,
                  lane: updateLane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                if (newLastBaseUpdate === null) {
                  newFirstBaseUpdate = newLastBaseUpdate = clone;
                  newBaseState = newState;
                } else {
                  newLastBaseUpdate = newLastBaseUpdate.next = clone;
                }
                newLanes = mergeLanes(newLanes, updateLane);
              } else {
                if (newLastBaseUpdate !== null) {
                  var _clone = {
                    eventTime: updateEventTime,
                    lane: NoLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                }
                newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                var callback = update.callback;
                if (callback !== null) {
                  workInProgress2.flags |= Callback;
                  var effects = queue.effects;
                  if (effects === null) {
                    queue.effects = [update];
                  } else {
                    effects.push(update);
                  }
                }
              }
              update = update.next;
              if (update === null) {
                pendingQueue = queue.shared.pending;
                if (pendingQueue === null) {
                  break;
                } else {
                  var _lastPendingUpdate = pendingQueue;
                  var _firstPendingUpdate = _lastPendingUpdate.next;
                  _lastPendingUpdate.next = null;
                  update = _firstPendingUpdate;
                  queue.lastBaseUpdate = _lastPendingUpdate;
                  queue.shared.pending = null;
                }
              }
            } while (true);
            if (newLastBaseUpdate === null) {
              newBaseState = newState;
            }
            queue.baseState = newBaseState;
            queue.firstBaseUpdate = newFirstBaseUpdate;
            queue.lastBaseUpdate = newLastBaseUpdate;
            markSkippedUpdateLanes(newLanes);
            workInProgress2.lanes = newLanes;
            workInProgress2.memoizedState = newState;
          }
          {
            currentlyProcessingQueue = null;
          }
        }
        function callCallback(callback, context) {
          if (!(typeof callback === "function")) {
            {
              throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
            }
          }
          callback.call(context);
        }
        function resetHasForceUpdateBeforeProcessing() {
          hasForceUpdate = false;
        }
        function checkHasForceUpdateAfterProcessing() {
          return hasForceUpdate;
        }
        function commitUpdateQueue(finishedWork, finishedQueue, instance) {
          var effects = finishedQueue.effects;
          finishedQueue.effects = null;
          if (effects !== null) {
            for (var i = 0; i < effects.length; i++) {
              var effect = effects[i];
              var callback = effect.callback;
              if (callback !== null) {
                effect.callback = null;
                callCallback(callback, instance);
              }
            }
          }
        }
        var fakeInternalInstance = {};
        var isArray = Array.isArray;
        var emptyRefsObject = new React8.Component().refs;
        var didWarnAboutStateAssignmentForComponent;
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutStateAssignmentForComponent = new Set();
          didWarnAboutUninitializedState = new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
          didWarnAboutDirectlyAssigningPropsToState = new Set();
          didWarnAboutUndefinedDerivedState = new Set();
          didWarnAboutContextTypeAndContextTypes = new Set();
          didWarnAboutInvalidateContextType = new Set();
          var didWarnOnInvalidCallback = new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key)) {
              didWarnOnInvalidCallback.add(key);
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentName(type) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
          Object.defineProperty(fakeInternalInstance, "_processChildContext", {
            enumerable: false,
            value: function() {
              {
                {
                  throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
                }
              }
            }
          });
          Object.freeze(fakeInternalInstance);
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState;
          {
            if (workInProgress2.mode & StrictMode) {
              disableLogs();
              try {
                getDerivedStateFromProps(nextProps, prevState);
              } finally {
                reenableLogs();
              }
            }
          }
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var memoizedState = partialState === null || partialState === void 0 ? prevState : _assign({}, prevState, partialState);
          workInProgress2.memoizedState = memoizedState;
          if (workInProgress2.lanes === NoLanes) {
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = memoizedState;
          }
        }
        var classComponentUpdater = {
          isMounted,
          enqueueSetState: function(inst, payload, callback) {
            var fiber = get(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "setState");
              }
              update.callback = callback;
            }
            enqueueUpdate(fiber, update);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var fiber = get(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ReplaceState;
            update.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "replaceState");
              }
              update.callback = callback;
            }
            enqueueUpdate(fiber, update);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
          },
          enqueueForceUpdate: function(inst, callback) {
            var fiber = get(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update = createUpdate(eventTime, lane);
            update.tag = ForceUpdate;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "forceUpdate");
              }
              update.callback = callback;
            }
            enqueueUpdate(fiber, update);
            scheduleUpdateOnFiber(fiber, lane, eventTime);
          }
        };
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if (typeof instance.shouldComponentUpdate === "function") {
            {
              if (workInProgress2.mode & StrictMode) {
                disableLogs();
                try {
                  instance.shouldComponentUpdate(newProps, newState, nextContext);
                } finally {
                  reenableLogs();
                }
              }
            }
            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
            {
              if (shouldUpdate === void 0) {
                error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentName(ctor) || "Component");
              }
            }
            return shouldUpdate;
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent) {
            return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
          }
          return true;
        }
        function checkClassInstance(workInProgress2, ctor, newProps) {
          var instance = workInProgress2.stateNode;
          {
            var name2 = getComponentName(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name2);
              } else {
                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name2);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2);
            }
            if (instance.propTypes) {
              error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name2);
            }
            if (instance.contextType) {
              error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2);
            }
            {
              if (instance.contextTypes) {
                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name2);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name2);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2, name2);
            }
            if (instance.defaultProps) {
              error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray(_state))) {
              error("%s.state: must be set to an object or null", name2);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
            }
          }
        }
        function adoptClassInstance(workInProgress2, instance) {
          instance.updater = classComponentUpdater;
          workInProgress2.stateNode = instance;
          set(instance, workInProgress2);
          {
            instance._reactInternalInstance = fakeInternalInstance;
          }
        }
        function constructClassInstance(workInProgress2, ctor, props) {
          var isLegacyContextConsumer = false;
          var unmaskedContext = emptyContextObject;
          var context = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context = readContext(contextType);
          } else {
            unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            var contextTypes = ctor.contextTypes;
            isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
            context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
          }
          {
            if (workInProgress2.mode & StrictMode) {
              disableLogs();
              try {
                new ctor(props, context);
              } finally {
                reenableLogs();
              }
            }
          }
          var instance = new ctor(props, context);
          var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
          adoptClassInstance(workInProgress2, instance);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
              var componentName = getComponentName(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentName(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          if (isLegacyContextConsumer) {
            cacheContext(workInProgress2, unmaskedContext, context);
          }
          return instance;
        }
        function callComponentWillMount(workInProgress2, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentName(workInProgress2.type) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          if (typeof instance.componentWillReceiveProps === "function") {
            instance.componentWillReceiveProps(newProps, nextContext);
          }
          if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          }
          if (instance.state !== oldState) {
            {
              var componentName = getComponentName(workInProgress2.type) || "Component";
              if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                didWarnAboutStateAssignmentForComponent.add(componentName);
                error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
              }
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          {
            checkClassInstance(workInProgress2, ctor, newProps);
          }
          var instance = workInProgress2.stateNode;
          instance.props = newProps;
          instance.state = workInProgress2.memoizedState;
          instance.refs = emptyRefsObject;
          initializeUpdateQueue(workInProgress2);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            instance.context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentName(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
            if (workInProgress2.mode & StrictMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
            }
            {
              ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
            }
          }
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          instance.state = workInProgress2.memoizedState;
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(workInProgress2, instance);
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof instance.componentDidMount === "function") {
            workInProgress2.flags |= Update;
          }
        }
        function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          var oldProps = workInProgress2.memoizedProps;
          instance.props = oldProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (oldProps !== newProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            if (typeof instance.componentDidMount === "function") {
              workInProgress2.flags |= Update;
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              if (typeof instance.componentWillMount === "function") {
                instance.componentWillMount();
              }
              if (typeof instance.UNSAFE_componentWillMount === "function") {
                instance.UNSAFE_componentWillMount();
              }
            }
            if (typeof instance.componentDidMount === "function") {
              workInProgress2.flags |= Update;
            }
          } else {
            if (typeof instance.componentDidMount === "function") {
              workInProgress2.flags |= Update;
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          cloneUpdateQueue(current2, workInProgress2);
          var unresolvedOldProps = workInProgress2.memoizedProps;
          var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
          instance.props = oldProps;
          var unresolvedNewProps = workInProgress2.pendingProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
              if (typeof instance.componentWillUpdate === "function") {
                instance.componentWillUpdate(newProps, newState, nextContext);
              }
              if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
              }
            }
            if (typeof instance.componentDidUpdate === "function") {
              workInProgress2.flags |= Update;
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              workInProgress2.flags |= Snapshot;
            }
          } else {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        var didWarnAboutMaps;
        var didWarnAboutGenerators;
        var didWarnAboutStringRefs;
        var ownerHasKeyUseWarning;
        var ownerHasFunctionTypeWarning;
        var warnForMissingKey = function(child, returnFiber) {
        };
        {
          didWarnAboutMaps = false;
          didWarnAboutGenerators = false;
          didWarnAboutStringRefs = {};
          ownerHasKeyUseWarning = {};
          ownerHasFunctionTypeWarning = {};
          warnForMissingKey = function(child, returnFiber) {
            if (child === null || typeof child !== "object") {
              return;
            }
            if (!child._store || child._store.validated || child.key != null) {
              return;
            }
            if (!(typeof child._store === "object")) {
              {
                throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            child._store.validated = true;
            var componentName = getComponentName(returnFiber.type) || "Component";
            if (ownerHasKeyUseWarning[componentName]) {
              return;
            }
            ownerHasKeyUseWarning[componentName] = true;
            error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
          };
        }
        var isArray$1 = Array.isArray;
        function coerceRef(returnFiber, current2, element) {
          var mixedRef = element.ref;
          if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
            {
              if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                var componentName = getComponentName(returnFiber.type) || "Component";
                if (!didWarnAboutStringRefs[componentName]) {
                  {
                    error('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                  }
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
            if (element._owner) {
              var owner = element._owner;
              var inst;
              if (owner) {
                var ownerFiber = owner;
                if (!(ownerFiber.tag === ClassComponent)) {
                  {
                    throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                  }
                }
                inst = ownerFiber.stateNode;
              }
              if (!inst) {
                {
                  throw Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              var stringRef = "" + mixedRef;
              if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                return current2.ref;
              }
              var ref = function(value) {
                var refs = inst.refs;
                if (refs === emptyRefsObject) {
                  refs = inst.refs = {};
                }
                if (value === null) {
                  delete refs[stringRef];
                } else {
                  refs[stringRef] = value;
                }
              };
              ref._stringRef = stringRef;
              return ref;
            } else {
              if (!(typeof mixedRef === "string")) {
                {
                  throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                }
              }
              if (!element._owner) {
                {
                  throw Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                }
              }
            }
          }
          return mixedRef;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          if (returnFiber.type !== "textarea") {
            {
              {
                throw Error("Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
          }
        }
        function warnOnFunctionType(returnFiber) {
          {
            var componentName = getComponentName(returnFiber.type) || "Component";
            if (ownerHasFunctionTypeWarning[componentName]) {
              return;
            }
            ownerHasFunctionTypeWarning[componentName] = true;
            error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
        function ChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackSideEffects) {
              return;
            }
            var last = returnFiber.lastEffect;
            if (last !== null) {
              last.nextEffect = childToDelete;
              returnFiber.lastEffect = childToDelete;
            } else {
              returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
            }
            childToDelete.nextEffect = null;
            childToDelete.flags = Deletion;
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) {
              return null;
            }
            var childToDelete = currentFirstChild;
            while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
            }
            return null;
          }
          function mapRemainingChildren(returnFiber, currentFirstChild) {
            var existingChildren = new Map();
            var existingChild = currentFirstChild;
            while (existingChild !== null) {
              if (existingChild.key !== null) {
                existingChildren.set(existingChild.key, existingChild);
              } else {
                existingChildren.set(existingChild.index, existingChild);
              }
              existingChild = existingChild.sibling;
            }
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            var clone = createWorkInProgress(fiber, pendingProps);
            clone.index = 0;
            clone.sibling = null;
            return clone;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects) {
              return lastPlacedIndex;
            }
            var current2 = newFiber.alternate;
            if (current2 !== null) {
              var oldIndex = current2.index;
              if (oldIndex < lastPlacedIndex) {
                newFiber.flags = Placement;
                return lastPlacedIndex;
              } else {
                return oldIndex;
              }
            } else {
              newFiber.flags = Placement;
              return lastPlacedIndex;
            }
          }
          function placeSingleChild(newFiber) {
            if (shouldTrackSideEffects && newFiber.alternate === null) {
              newFiber.flags = Placement;
            }
            return newFiber;
          }
          function updateTextNode(returnFiber, current2, textContent, lanes) {
            if (current2 === null || current2.tag !== HostText) {
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, textContent);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateElement(returnFiber, current2, element, lanes) {
            if (current2 !== null) {
              if (current2.elementType === element.type || isCompatibleFamilyForHotReloading(current2, element)) {
                var existing = useFiber(current2, element.props);
                existing.ref = coerceRef(returnFiber, current2, element);
                existing.return = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              }
            }
            var created = createFiberFromElement(element, returnFiber.mode, lanes);
            created.ref = coerceRef(returnFiber, current2, element);
            created.return = returnFiber;
            return created;
          }
          function updatePortal(returnFiber, current2, portal, lanes) {
            if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, portal.children || []);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateFragment2(returnFiber, current2, fragment, lanes, key) {
            if (current2 === null || current2.tag !== Fragment) {
              var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current2, fragment);
              existing.return = returnFiber;
              return existing;
            }
          }
          function createChild(returnFiber, newChild, lanes) {
            if (typeof newChild === "string" || typeof newChild === "number") {
              var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }
                case REACT_PORTAL_TYPE: {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  _created2.return = returnFiber;
                  return _created2;
                }
              }
              if (isArray$1(newChild) || getIteratorFn(newChild)) {
                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                _created3.return = returnFiber;
                return _created3;
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = oldFiber !== null ? oldFiber.key : null;
            if (typeof newChild === "string" || typeof newChild === "number") {
              if (key !== null) {
                return null;
              }
              return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  if (newChild.key === key) {
                    if (newChild.type === REACT_FRAGMENT_TYPE) {
                      return updateFragment2(returnFiber, oldFiber, newChild.props.children, lanes, key);
                    }
                    return updateElement(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_PORTAL_TYPE: {
                  if (newChild.key === key) {
                    return updatePortal(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
              }
              if (isArray$1(newChild) || getIteratorFn(newChild)) {
                if (key !== null) {
                  return null;
                }
                return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if (typeof newChild === "string" || typeof newChild === "number") {
              var matchedFiber = existingChildren.get(newIdx) || null;
              return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  if (newChild.type === REACT_FRAGMENT_TYPE) {
                    return updateFragment2(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key);
                  }
                  return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                }
                case REACT_PORTAL_TYPE: {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                }
              }
              if (isArray$1(newChild) || getIteratorFn(newChild)) {
                var _matchedFiber3 = existingChildren.get(newIdx) || null;
                return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function warnOnInvalidKey(child, knownKeys, returnFiber) {
            {
              if (typeof child !== "object" || child === null) {
                return knownKeys;
              }
              switch (child.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  warnForMissingKey(child, returnFiber);
                  var key = child.key;
                  if (typeof key !== "string") {
                    break;
                  }
                  if (knownKeys === null) {
                    knownKeys = new Set();
                    knownKeys.add(key);
                    break;
                  }
                  if (!knownKeys.has(key)) {
                    knownKeys.add(key);
                    break;
                  }
                  error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                  break;
              }
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            {
              var knownKeys = null;
              for (var i = 0; i < newChildren.length; i++) {
                var child = newChildren[i];
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length) {
              deleteRemainingChildren(returnFiber, oldFiber);
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                if (_newFiber === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber;
                } else {
                  previousNewFiber.sibling = _newFiber;
                }
                previousNewFiber = _newFiber;
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
              if (_newFiber2 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber2.alternate !== null) {
                    existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber2;
                } else {
                  previousNewFiber.sibling = _newFiber2;
                }
                previousNewFiber = _newFiber2;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
            var iteratorFn = getIteratorFn(newChildrenIterable);
            if (!(typeof iteratorFn === "function")) {
              {
                throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            {
              if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (newChildrenIterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) {
                  error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
              var _newChildren = iteratorFn.call(newChildrenIterable);
              if (_newChildren) {
                var knownKeys = null;
                var _step = _newChildren.next();
                for (; !_step.done; _step = _newChildren.next()) {
                  var child = _step.value;
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
            }
            var newChildren = iteratorFn.call(newChildrenIterable);
            if (!(newChildren != null)) {
              {
                throw Error("An iterable object provided no iterator.");
              }
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            var step = newChildren.next();
            for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done) {
              deleteRemainingChildren(returnFiber, oldFiber);
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber3 = createChild(returnFiber, step.value, lanes);
                if (_newFiber3 === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber3;
                } else {
                  previousNewFiber.sibling = _newFiber3;
                }
                previousNewFiber = _newFiber3;
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
              if (_newFiber4 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber4.alternate !== null) {
                    existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber4;
                } else {
                  previousNewFiber.sibling = _newFiber4;
                }
                previousNewFiber = _newFiber4;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            return resultingFirstChild;
          }
          function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
              deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
              var existing = useFiber(currentFirstChild, textContent);
              existing.return = returnFiber;
              return existing;
            }
            deleteRemainingChildren(returnFiber, currentFirstChild);
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
            var key = element.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key) {
                switch (child.tag) {
                  case Fragment: {
                    if (element.type === REACT_FRAGMENT_TYPE) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(child, element.props.children);
                      existing.return = returnFiber;
                      {
                        existing._debugSource = element._source;
                        existing._debugOwner = element._owner;
                      }
                      return existing;
                    }
                    break;
                  }
                  case Block:
                  default: {
                    if (child.elementType === element.type || isCompatibleFamilyForHotReloading(child, element)) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var _existing3 = useFiber(child, element.props);
                      _existing3.ref = coerceRef(returnFiber, child, element);
                      _existing3.return = returnFiber;
                      {
                        _existing3._debugSource = element._source;
                        _existing3._debugOwner = element._owner;
                      }
                      return _existing3;
                    }
                    break;
                  }
                }
                deleteRemainingChildren(returnFiber, child);
                break;
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            if (element.type === REACT_FRAGMENT_TYPE) {
              var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
              created.return = returnFiber;
              return created;
            } else {
              var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
              _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
              _created4.return = returnFiber;
              return _created4;
            }
          }
          function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
            var key = portal.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key) {
                if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, portal.children || []);
                  existing.return = returnFiber;
                  return existing;
                } else {
                  deleteRemainingChildren(returnFiber, child);
                  break;
                }
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
            var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
            if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
            }
            var isObject = typeof newChild === "object" && newChild !== null;
            if (isObject) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_PORTAL_TYPE:
                  return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
              }
            }
            if (typeof newChild === "string" || typeof newChild === "number") {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
            }
            if (isArray$1(newChild)) {
              return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
            }
            if (getIteratorFn(newChild)) {
              return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
            }
            if (isObject) {
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
              switch (returnFiber.tag) {
                case ClassComponent: {
                  {
                    var instance = returnFiber.stateNode;
                    if (instance.render._isMockFunction) {
                      break;
                    }
                  }
                }
                case Block:
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  {
                    {
                      throw Error((getComponentName(returnFiber.type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
                    }
                  }
                }
              }
            }
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return reconcileChildFibers2;
        }
        var reconcileChildFibers = ChildReconciler(true);
        var mountChildFibers = ChildReconciler(false);
        function cloneChildFibers(current2, workInProgress2) {
          if (!(current2 === null || workInProgress2.child === current2.child)) {
            {
              throw Error("Resuming work not yet implemented.");
            }
          }
          if (workInProgress2.child === null) {
            return;
          }
          var currentChild = workInProgress2.child;
          var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
          workInProgress2.child = newChild;
          newChild.return = workInProgress2;
          while (currentChild.sibling !== null) {
            currentChild = currentChild.sibling;
            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
            newChild.return = workInProgress2;
          }
          newChild.sibling = null;
        }
        function resetChildFibers(workInProgress2, lanes) {
          var child = workInProgress2.child;
          while (child !== null) {
            resetWorkInProgress(child, lanes);
            child = child.sibling;
          }
        }
        var NO_CONTEXT = {};
        var contextStackCursor$1 = createCursor(NO_CONTEXT);
        var contextFiberStackCursor = createCursor(NO_CONTEXT);
        var rootInstanceStackCursor = createCursor(NO_CONTEXT);
        function requiredContext(c) {
          if (!(c !== NO_CONTEXT)) {
            {
              throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          return c;
        }
        function getRootHostContainer() {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          return rootInstance;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, NO_CONTEXT, fiber);
          var nextRootContext = getRootHostContext(nextRootInstance);
          pop(contextStackCursor$1, fiber);
          push(contextStackCursor$1, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          var context = requiredContext(contextStackCursor$1.current);
          return context;
        }
        function pushHostContext(fiber) {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          var context = requiredContext(contextStackCursor$1.current);
          var nextContext = getChildHostContext(context, fiber.type);
          if (context === nextContext) {
            return;
          }
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, nextContext, fiber);
        }
        function popHostContext(fiber) {
          if (contextFiberStackCursor.current !== fiber) {
            return;
          }
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
        }
        var DefaultSuspenseContext = 0;
        var SubtreeSuspenseContextMask = 1;
        var InvisibleParentSuspenseContext = 1;
        var ForceSuspenseFallback = 2;
        var suspenseStackCursor = createCursor(DefaultSuspenseContext);
        function hasSuspenseContext(parentContext, flag) {
          return (parentContext & flag) !== 0;
        }
        function setDefaultShallowSuspenseContext(parentContext) {
          return parentContext & SubtreeSuspenseContextMask;
        }
        function setShallowSuspenseContext(parentContext, shallowContext) {
          return parentContext & SubtreeSuspenseContextMask | shallowContext;
        }
        function addSubtreeSuspenseContext(parentContext, subtreeContext) {
          return parentContext | subtreeContext;
        }
        function pushSuspenseContext(fiber, newContext) {
          push(suspenseStackCursor, newContext, fiber);
        }
        function popSuspenseContext(fiber) {
          pop(suspenseStackCursor, fiber);
        }
        function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
          var nextState = workInProgress2.memoizedState;
          if (nextState !== null) {
            if (nextState.dehydrated !== null) {
              return true;
            }
            return false;
          }
          var props = workInProgress2.memoizedProps;
          if (props.fallback === void 0) {
            return false;
          }
          if (props.unstable_avoidThisFallback !== true) {
            return true;
          }
          if (hasInvisibleParent) {
            return false;
          }
          return true;
        }
        function findFirstSuspended(row) {
          var node = row;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state = node.memoizedState;
              if (state !== null) {
                var dehydrated = state.dehydrated;
                if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                  return node;
                }
              }
            } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== void 0) {
              var didSuspend = (node.flags & DidCapture) !== NoFlags;
              if (didSuspend) {
                return node;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) {
              return null;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === row) {
                return null;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        var NoFlags$1 = 0;
        var HasEffect = 1;
        var Layout = 2;
        var Passive$1 = 4;
        var hydrationParentFiber = null;
        var nextHydratableInstance = null;
        var isHydrating = false;
        function enterHydrationState(fiber) {
          var parentInstance = fiber.stateNode.containerInfo;
          nextHydratableInstance = getFirstHydratableChild(parentInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          return true;
        }
        function deleteHydratableInstance(returnFiber, instance) {
          {
            switch (returnFiber.tag) {
              case HostRoot:
                didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
                break;
              case HostComponent:
                didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
                break;
            }
          }
          var childToDelete = createFiberFromHostInstanceForDeletion();
          childToDelete.stateNode = instance;
          childToDelete.return = returnFiber;
          childToDelete.flags = Deletion;
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = childToDelete;
            returnFiber.lastEffect = childToDelete;
          } else {
            returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
          }
        }
        function insertNonHydratedInstance(returnFiber, fiber) {
          fiber.flags = fiber.flags & ~Hydrating | Placement;
          {
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                switch (fiber.tag) {
                  case HostComponent:
                    var type = fiber.type;
                    var props = fiber.pendingProps;
                    didNotFindHydratableContainerInstance(parentContainer, type);
                    break;
                  case HostText:
                    var text = fiber.pendingProps;
                    didNotFindHydratableContainerTextInstance(parentContainer, text);
                    break;
                }
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                switch (fiber.tag) {
                  case HostComponent:
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
                    break;
                  case HostText:
                    var _text = fiber.pendingProps;
                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                    break;
                  case SuspenseComponent:
                    didNotFindHydratableSuspenseInstance(parentType, parentProps);
                    break;
                }
                break;
              }
              default:
                return;
            }
          }
        }
        function tryHydrate(fiber, nextInstance) {
          switch (fiber.tag) {
            case HostComponent: {
              var type = fiber.type;
              var props = fiber.pendingProps;
              var instance = canHydrateInstance(nextInstance, type);
              if (instance !== null) {
                fiber.stateNode = instance;
                return true;
              }
              return false;
            }
            case HostText: {
              var text = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text);
              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                return true;
              }
              return false;
            }
            case SuspenseComponent: {
              return false;
            }
            default:
              return false;
          }
        }
        function tryToClaimNextHydratableInstance(fiber) {
          if (!isHydrating) {
            return;
          }
          var nextInstance = nextHydratableInstance;
          if (!nextInstance) {
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          var firstAttemptedInstance = nextInstance;
          if (!tryHydrate(fiber, nextInstance)) {
            nextInstance = getNextHydratableSibling(firstAttemptedInstance);
            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
          }
          hydrationParentFiber = fiber;
          nextHydratableInstance = getFirstHydratableChild(nextInstance);
        }
        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
          var instance = fiber.stateNode;
          var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
          fiber.updateQueue = updatePayload;
          if (updatePayload !== null) {
            return true;
          }
          return false;
        }
        function prepareToHydrateHostTextInstance(fiber) {
          var textInstance = fiber.stateNode;
          var textContent = fiber.memoizedProps;
          var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
          {
            if (shouldUpdate) {
              var returnFiber = hydrationParentFiber;
              if (returnFiber !== null) {
                switch (returnFiber.tag) {
                  case HostRoot: {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                    break;
                  }
                  case HostComponent: {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                    break;
                  }
                }
              }
            }
          }
          return shouldUpdate;
        }
        function skipPastDehydratedSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            {
              throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
        }
        function popToNextHostParent(fiber) {
          var parent = fiber.return;
          while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
            parent = parent.return;
          }
          hydrationParentFiber = parent;
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) {
            return false;
          }
          if (!isHydrating) {
            popToNextHostParent(fiber);
            isHydrating = true;
            return false;
          }
          var type = fiber.type;
          if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps)) {
            var nextInstance = nextHydratableInstance;
            while (nextInstance) {
              deleteHydratableInstance(fiber, nextInstance);
              nextInstance = getNextHydratableSibling(nextInstance);
            }
          }
          popToNextHostParent(fiber);
          if (fiber.tag === SuspenseComponent) {
            nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
          } else {
            nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
          }
          return true;
        }
        function resetHydrationState() {
          hydrationParentFiber = null;
          nextHydratableInstance = null;
          isHydrating = false;
        }
        function getIsHydrating() {
          return isHydrating;
        }
        var workInProgressSources = [];
        var rendererSigil$1;
        {
          rendererSigil$1 = {};
        }
        function markSourceAsDirty(mutableSource) {
          workInProgressSources.push(mutableSource);
        }
        function resetWorkInProgressVersions() {
          for (var i = 0; i < workInProgressSources.length; i++) {
            var mutableSource = workInProgressSources[i];
            {
              mutableSource._workInProgressVersionPrimary = null;
            }
          }
          workInProgressSources.length = 0;
        }
        function getWorkInProgressVersion(mutableSource) {
          {
            return mutableSource._workInProgressVersionPrimary;
          }
        }
        function setWorkInProgressVersion(mutableSource, version) {
          {
            mutableSource._workInProgressVersionPrimary = version;
          }
          workInProgressSources.push(mutableSource);
        }
        function warnAboutMultipleRenderersDEV(mutableSource) {
          {
            {
              if (mutableSource._currentPrimaryRenderer == null) {
                mutableSource._currentPrimaryRenderer = rendererSigil$1;
              } else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) {
                error("Detected multiple renderers concurrently rendering the same mutable source. This is currently unsupported.");
              }
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
        var didWarnAboutMismatchedHooksForComponent;
        var didWarnAboutUseOpaqueIdentifier;
        {
          didWarnAboutUseOpaqueIdentifier = {};
          didWarnAboutMismatchedHooksForComponent = new Set();
        }
        var renderLanes = NoLanes;
        var currentlyRenderingFiber$1 = null;
        var currentHook = null;
        var workInProgressHook = null;
        var didScheduleRenderPhaseUpdate = false;
        var didScheduleRenderPhaseUpdateDuringThisPass = false;
        var RE_RENDER_LIMIT = 25;
        var currentHookNameInDev = null;
        var hookTypesDev = null;
        var hookTypesUpdateIndexDev = -1;
        var ignorePreviousDependencies = false;
        function mountHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev === null) {
              hookTypesDev = [hookName];
            } else {
              hookTypesDev.push(hookName);
            }
          }
        }
        function updateHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev !== null) {
              hookTypesUpdateIndexDev++;
              if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                warnOnHookMismatchInDev(hookName);
              }
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          {
            if (deps !== void 0 && deps !== null && !Array.isArray(deps)) {
              error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
            }
          }
        }
        function warnOnHookMismatchInDev(currentHookName) {
          {
            var componentName = getComponentName(currentlyRenderingFiber$1.type);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
              didWarnAboutMismatchedHooksForComponent.add(componentName);
              if (hookTypesDev !== null) {
                var table = "";
                var secondColumnStart = 30;
                for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                  var oldHookName = hookTypesDev[i];
                  var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                  var row = i + 1 + ". " + oldHookName;
                  while (row.length < secondColumnStart) {
                    row += " ";
                  }
                  row += newHookName + "\n";
                  table += row;
                }
                error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
              }
            }
          }
        }
        function throwInvalidHookError() {
          {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          {
            if (ignorePreviousDependencies) {
              return false;
            }
          }
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
            }
          }
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
            if (objectIs(nextDeps[i], prevDeps[i])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber$1 = workInProgress2;
          {
            hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
            hookTypesUpdateIndexDev = -1;
            ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
          }
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = NoLanes;
          {
            if (current2 !== null && current2.memoizedState !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
            } else if (hookTypesDev !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
            } else {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
            }
          }
          var children = Component(props, secondArg);
          if (didScheduleRenderPhaseUpdateDuringThisPass) {
            var numberOfReRenders = 0;
            do {
              didScheduleRenderPhaseUpdateDuringThisPass = false;
              if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
                {
                  throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                }
              }
              numberOfReRenders += 1;
              {
                ignorePreviousDependencies = false;
              }
              currentHook = null;
              workInProgressHook = null;
              workInProgress2.updateQueue = null;
              {
                hookTypesUpdateIndexDev = -1;
              }
              ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
              children = Component(props, secondArg);
            } while (didScheduleRenderPhaseUpdateDuringThisPass);
          }
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          {
            workInProgress2._debugHookTypes = hookTypesDev;
          }
          var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            currentHookNameInDev = null;
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
          }
          didScheduleRenderPhaseUpdate = false;
          if (!!didRenderTooFewHooks) {
            {
              throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
            }
          }
          return children;
        }
        function bailoutHooks(current2, workInProgress2, lanes) {
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.flags &= ~(Passive | Update);
          current2.lanes = removeLanes(current2.lanes, lanes);
        }
        function resetHooksAfterThrow() {
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          if (didScheduleRenderPhaseUpdate) {
            var hook = currentlyRenderingFiber$1.memoizedState;
            while (hook !== null) {
              var queue = hook.queue;
              if (queue !== null) {
                queue.pending = null;
              }
              hook = hook.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            currentHookNameInDev = null;
            isUpdatingOpaqueValueInRenderPhase = false;
          }
          didScheduleRenderPhaseUpdateDuringThisPass = false;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
          } else {
            workInProgressHook = workInProgressHook.next = hook;
          }
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          var nextCurrentHook;
          if (currentHook === null) {
            var current2 = currentlyRenderingFiber$1.alternate;
            if (current2 !== null) {
              nextCurrentHook = current2.memoizedState;
            } else {
              nextCurrentHook = null;
            }
          } else {
            nextCurrentHook = currentHook.next;
          }
          var nextWorkInProgressHook;
          if (workInProgressHook === null) {
            nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
          } else {
            nextWorkInProgressHook = workInProgressHook.next;
          }
          if (nextWorkInProgressHook !== null) {
            workInProgressHook = nextWorkInProgressHook;
            nextWorkInProgressHook = workInProgressHook.next;
            currentHook = nextCurrentHook;
          } else {
            if (!(nextCurrentHook !== null)) {
              {
                throw Error("Rendered more hooks than during the previous render.");
              }
            }
            currentHook = nextCurrentHook;
            var newHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
            } else {
              workInProgressHook = workInProgressHook.next = newHook;
            }
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return {
            lastEffect: null
          };
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          var initialState;
          if (init !== void 0) {
            initialState = init(initialArg);
          } else {
            initialState = initialArg;
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = hook.queue = {
            pending: null,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch];
        }
        function updateReducer(reducer, initialArg, init) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (!(queue !== null)) {
            {
              throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
          }
          queue.lastRenderedReducer = reducer;
          var current2 = currentHook;
          var baseQueue = current2.baseQueue;
          var pendingQueue = queue.pending;
          if (pendingQueue !== null) {
            if (baseQueue !== null) {
              var baseFirst = baseQueue.next;
              var pendingFirst = pendingQueue.next;
              baseQueue.next = pendingFirst;
              pendingQueue.next = baseFirst;
            }
            {
              if (current2.baseQueue !== baseQueue) {
                error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
              }
            }
            current2.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          if (baseQueue !== null) {
            var first = baseQueue.next;
            var newState = current2.baseState;
            var newBaseState = null;
            var newBaseQueueFirst = null;
            var newBaseQueueLast = null;
            var update = first;
            do {
              var updateLane = update.lane;
              if (!isSubsetOfLanes(renderLanes, updateLane)) {
                var clone = {
                  lane: updateLane,
                  action: update.action,
                  eagerReducer: update.eagerReducer,
                  eagerState: update.eagerState,
                  next: null
                };
                if (newBaseQueueLast === null) {
                  newBaseQueueFirst = newBaseQueueLast = clone;
                  newBaseState = newState;
                } else {
                  newBaseQueueLast = newBaseQueueLast.next = clone;
                }
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                markSkippedUpdateLanes(updateLane);
              } else {
                if (newBaseQueueLast !== null) {
                  var _clone = {
                    lane: NoLane,
                    action: update.action,
                    eagerReducer: update.eagerReducer,
                    eagerState: update.eagerState,
                    next: null
                  };
                  newBaseQueueLast = newBaseQueueLast.next = _clone;
                }
                if (update.eagerReducer === reducer) {
                  newState = update.eagerState;
                } else {
                  var action = update.action;
                  newState = reducer(newState, action);
                }
              }
              update = update.next;
            } while (update !== null && update !== first);
            if (newBaseQueueLast === null) {
              newBaseState = newState;
            } else {
              newBaseQueueLast.next = newBaseQueueFirst;
            }
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            hook.baseState = newBaseState;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = newState;
          }
          var dispatch = queue.dispatch;
          return [hook.memoizedState, dispatch];
        }
        function rerenderReducer(reducer, initialArg, init) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (!(queue !== null)) {
            {
              throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
          }
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch;
          var lastRenderPhaseUpdate = queue.pending;
          var newState = hook.memoizedState;
          if (lastRenderPhaseUpdate !== null) {
            queue.pending = null;
            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            var update = firstRenderPhaseUpdate;
            do {
              var action = update.action;
              newState = reducer(newState, action);
              update = update.next;
            } while (update !== firstRenderPhaseUpdate);
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            if (hook.baseQueue === null) {
              hook.baseState = newState;
            }
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function readFromUnsubcribedMutableSource(root2, source, getSnapshot) {
          {
            warnAboutMultipleRenderersDEV(source);
          }
          var getVersion = source._getVersion;
          var version = getVersion(source._source);
          var isSafeToReadFromSource = false;
          var currentRenderVersion = getWorkInProgressVersion(source);
          if (currentRenderVersion !== null) {
            isSafeToReadFromSource = currentRenderVersion === version;
          } else {
            isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root2.mutableReadLanes);
            if (isSafeToReadFromSource) {
              setWorkInProgressVersion(source, version);
            }
          }
          if (isSafeToReadFromSource) {
            var snapshot = getSnapshot(source._source);
            {
              if (typeof snapshot === "function") {
                error("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
              }
            }
            return snapshot;
          } else {
            markSourceAsDirty(source);
            {
              {
                throw Error("Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue.");
              }
            }
          }
        }
        function useMutableSource(hook, source, getSnapshot, subscribe) {
          var root2 = getWorkInProgressRoot();
          if (!(root2 !== null)) {
            {
              throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
          }
          var getVersion = source._getVersion;
          var version = getVersion(source._source);
          var dispatcher = ReactCurrentDispatcher$1.current;
          var _dispatcher$useState = dispatcher.useState(function() {
            return readFromUnsubcribedMutableSource(root2, source, getSnapshot);
          }), currentSnapshot = _dispatcher$useState[0], setSnapshot = _dispatcher$useState[1];
          var snapshot = currentSnapshot;
          var stateHook = workInProgressHook;
          var memoizedState = hook.memoizedState;
          var refs = memoizedState.refs;
          var prevGetSnapshot = refs.getSnapshot;
          var prevSource = memoizedState.source;
          var prevSubscribe = memoizedState.subscribe;
          var fiber = currentlyRenderingFiber$1;
          hook.memoizedState = {
            refs,
            source,
            subscribe
          };
          dispatcher.useEffect(function() {
            refs.getSnapshot = getSnapshot;
            refs.setSnapshot = setSnapshot;
            var maybeNewVersion = getVersion(source._source);
            if (!objectIs(version, maybeNewVersion)) {
              var maybeNewSnapshot = getSnapshot(source._source);
              {
                if (typeof maybeNewSnapshot === "function") {
                  error("Mutable source should not return a function as the snapshot value. Functions may close over mutable values and cause tearing.");
                }
              }
              if (!objectIs(snapshot, maybeNewSnapshot)) {
                setSnapshot(maybeNewSnapshot);
                var lane = requestUpdateLane(fiber);
                markRootMutableRead(root2, lane);
              }
              markRootEntangled(root2, root2.mutableReadLanes);
            }
          }, [getSnapshot, source, subscribe]);
          dispatcher.useEffect(function() {
            var handleChange = function() {
              var latestGetSnapshot = refs.getSnapshot;
              var latestSetSnapshot = refs.setSnapshot;
              try {
                latestSetSnapshot(latestGetSnapshot(source._source));
                var lane = requestUpdateLane(fiber);
                markRootMutableRead(root2, lane);
              } catch (error2) {
                latestSetSnapshot(function() {
                  throw error2;
                });
              }
            };
            var unsubscribe = subscribe(source._source, handleChange);
            {
              if (typeof unsubscribe !== "function") {
                error("Mutable source subscribe function must return an unsubscribe function.");
              }
            }
            return unsubscribe;
          }, [source, subscribe]);
          if (!objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe)) {
            var newQueue = {
              pending: null,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: snapshot
            };
            newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue);
            stateHook.queue = newQueue;
            stateHook.baseQueue = null;
            snapshot = readFromUnsubcribedMutableSource(root2, source, getSnapshot);
            stateHook.memoizedState = stateHook.baseState = snapshot;
          }
          return snapshot;
        }
        function mountMutableSource(source, getSnapshot, subscribe) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = {
            refs: {
              getSnapshot,
              setSnapshot: null
            },
            source,
            subscribe
          };
          return useMutableSource(hook, source, getSnapshot, subscribe);
        }
        function updateMutableSource(source, getSnapshot, subscribe) {
          var hook = updateWorkInProgressHook();
          return useMutableSource(hook, source, getSnapshot, subscribe);
        }
        function mountState(initialState) {
          var hook = mountWorkInProgressHook();
          if (typeof initialState === "function") {
            initialState = initialState();
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = hook.queue = {
            pending: null,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch];
        }
        function updateState(initialState) {
          return updateReducer(basicStateReducer);
        }
        function rerenderState(initialState) {
          return rerenderReducer(basicStateReducer);
        }
        function pushEffect(tag, create, destroy, deps) {
          var effect = {
            tag,
            create,
            destroy,
            deps,
            next: null
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var lastEffect = componentUpdateQueue.lastEffect;
            if (lastEffect === null) {
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var firstEffect = lastEffect.next;
              lastEffect.next = effect;
              effect.next = firstEffect;
              componentUpdateQueue.lastEffect = effect;
            }
          }
          return effect;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          var ref = {
            current: initialValue
          };
          {
            Object.seal(ref);
          }
          hook.memoizedState = ref;
          return ref;
        }
        function updateRef(initialValue) {
          var hook = updateWorkInProgressHook();
          return hook.memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var destroy = void 0;
          if (currentHook !== null) {
            var prevEffect = currentHook.memoizedState;
            destroy = prevEffect.destroy;
            if (nextDeps !== null) {
              var prevDeps = prevEffect.deps;
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                pushEffect(hookFlags, create, destroy, nextDeps);
                return;
              }
            }
          }
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
        }
        function mountEffect(create, deps) {
          {
            if (typeof jest !== "undefined") {
              warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
            }
          }
          return mountEffectImpl(Update | Passive, Passive$1, create, deps);
        }
        function updateEffect(create, deps) {
          {
            if (typeof jest !== "undefined") {
              warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
            }
          }
          return updateEffectImpl(Update | Passive, Passive$1, create, deps);
        }
        function mountLayoutEffect(create, deps) {
          return mountEffectImpl(Update, Layout, create, deps);
        }
        function updateLayoutEffect(create, deps) {
          return updateEffectImpl(Update, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if (typeof ref === "function") {
            var refCallback = ref;
            var _inst = create();
            refCallback(_inst);
            return function() {
              refCallback(null);
            };
          } else if (ref !== null && ref !== void 0) {
            var refObject = ref;
            {
              if (!refObject.hasOwnProperty("current")) {
                error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
              }
            }
            var _inst2 = create();
            refObject.current = _inst2;
            return function() {
              refObject.current = null;
            };
          }
        }
        function mountImperativeHandle(ref, create, deps) {
          {
            if (typeof create !== "function") {
              error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          return mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function updateImperativeHandle(ref, create, deps) {
          {
            if (typeof create !== "function") {
              error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
        }
        function mountDebugValue(value, formatterFn) {
        }
        var updateDebugValue = mountDebugValue;
        function mountCallback(callback, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function mountDeferredValue(value) {
          var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];
          mountEffect(function() {
            var prevTransition = ReactCurrentBatchConfig$1.transition;
            ReactCurrentBatchConfig$1.transition = 1;
            try {
              setValue(value);
            } finally {
              ReactCurrentBatchConfig$1.transition = prevTransition;
            }
          }, [value]);
          return prevValue;
        }
        function updateDeferredValue(value) {
          var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];
          updateEffect(function() {
            var prevTransition = ReactCurrentBatchConfig$1.transition;
            ReactCurrentBatchConfig$1.transition = 1;
            try {
              setValue(value);
            } finally {
              ReactCurrentBatchConfig$1.transition = prevTransition;
            }
          }, [value]);
          return prevValue;
        }
        function rerenderDeferredValue(value) {
          var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];
          updateEffect(function() {
            var prevTransition = ReactCurrentBatchConfig$1.transition;
            ReactCurrentBatchConfig$1.transition = 1;
            try {
              setValue(value);
            } finally {
              ReactCurrentBatchConfig$1.transition = prevTransition;
            }
          }, [value]);
          return prevValue;
        }
        function startTransition(setPending, callback) {
          var priorityLevel = getCurrentPriorityLevel();
          {
            runWithPriority$1(priorityLevel < UserBlockingPriority$2 ? UserBlockingPriority$2 : priorityLevel, function() {
              setPending(true);
            });
            runWithPriority$1(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function() {
              var prevTransition = ReactCurrentBatchConfig$1.transition;
              ReactCurrentBatchConfig$1.transition = 1;
              try {
                setPending(false);
                callback();
              } finally {
                ReactCurrentBatchConfig$1.transition = prevTransition;
              }
            });
          }
        }
        function mountTransition() {
          var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1];
          var start2 = startTransition.bind(null, setPending);
          mountRef(start2);
          return [start2, isPending];
        }
        function updateTransition() {
          var _updateState2 = updateState(), isPending = _updateState2[0];
          var startRef = updateRef();
          var start2 = startRef.current;
          return [start2, isPending];
        }
        function rerenderTransition() {
          var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0];
          var startRef = updateRef();
          var start2 = startRef.current;
          return [start2, isPending];
        }
        var isUpdatingOpaqueValueInRenderPhase = false;
        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
          {
            return isUpdatingOpaqueValueInRenderPhase;
          }
        }
        function warnOnOpaqueIdentifierAccessInDEV(fiber) {
          {
            var name2 = getComponentName(fiber.type) || "Unknown";
            if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name2]) {
              error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
              didWarnAboutUseOpaqueIdentifier[name2] = true;
            }
          }
        }
        function mountOpaqueIdentifier() {
          var makeId = makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1));
          if (getIsHydrating()) {
            var didUpgrade = false;
            var fiber = currentlyRenderingFiber$1;
            var readValue = function() {
              if (!didUpgrade) {
                didUpgrade = true;
                {
                  isUpdatingOpaqueValueInRenderPhase = true;
                  setId(makeId());
                  isUpdatingOpaqueValueInRenderPhase = false;
                  warnOnOpaqueIdentifierAccessInDEV(fiber);
                }
              }
              {
                {
                  throw Error("The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.");
                }
              }
            };
            var id = makeOpaqueHydratingObject(readValue);
            var setId = mountState(id)[1];
            if ((currentlyRenderingFiber$1.mode & BlockingMode) === NoMode) {
              currentlyRenderingFiber$1.flags |= Update | Passive;
              pushEffect(HasEffect | Passive$1, function() {
                setId(makeId());
              }, void 0, null);
            }
            return id;
          } else {
            var _id = makeId();
            mountState(_id);
            return _id;
          }
        }
        function updateOpaqueIdentifier() {
          var id = updateState()[0];
          return id;
        }
        function rerenderOpaqueIdentifier() {
          var id = rerenderState()[0];
          return id;
        }
        function dispatchAction(fiber, queue, action) {
          {
            if (typeof arguments[3] === "function") {
              error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = {
            lane,
            action,
            eagerReducer: null,
            eagerState: null,
            next: null
          };
          var pending = queue.pending;
          if (pending === null) {
            update.next = update;
          } else {
            update.next = pending.next;
            pending.next = update;
          }
          queue.pending = update;
          var alternate = fiber.alternate;
          if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          } else {
            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
              var lastRenderedReducer = queue.lastRenderedReducer;
              if (lastRenderedReducer !== null) {
                var prevDispatcher;
                {
                  prevDispatcher = ReactCurrentDispatcher$1.current;
                  ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                }
                try {
                  var currentState = queue.lastRenderedState;
                  var eagerState = lastRenderedReducer(currentState, action);
                  update.eagerReducer = lastRenderedReducer;
                  update.eagerState = eagerState;
                  if (objectIs(eagerState, currentState)) {
                    return;
                  }
                } catch (error2) {
                } finally {
                  {
                    ReactCurrentDispatcher$1.current = prevDispatcher;
                  }
                }
              }
            }
            {
              if (typeof jest !== "undefined") {
                warnIfNotScopedWithMatchingAct(fiber);
                warnIfNotCurrentlyActingUpdatesInDev(fiber);
              }
            }
            scheduleUpdateOnFiber(fiber, lane, eventTime);
          }
        }
        var ContextOnlyDispatcher = {
          readContext,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useMutableSource: throwInvalidHookError,
          useOpaqueIdentifier: throwInvalidHookError,
          unstable_isNewReconciler: enableNewReconciler
        };
        var HooksDispatcherOnMountInDEV = null;
        var HooksDispatcherOnMountWithHookTypesInDEV = null;
        var HooksDispatcherOnUpdateInDEV = null;
        var HooksDispatcherOnRerenderInDEV = null;
        var InvalidNestedHooksDispatcherOnMountInDEV = null;
        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        {
          var warnInvalidContextAccess = function() {
            error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          };
          var warnInvalidHookAccess = function() {
            error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          };
          HooksDispatcherOnMountInDEV = {
            readContext: function(context, observedBits) {
              return readContext(context, observedBits);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountCallback(callback, deps);
            },
            useContext: function(context, observedBits) {
              currentHookNameInDev = "useContext";
              mountHookTypesDev();
              return readContext(context, observedBits);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountImperativeHandle(ref, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              mountHookTypesDev();
              return mountMutableSource(source, getSnapshot, subscribe);
            },
            useOpaqueIdentifier: function() {
              currentHookNameInDev = "useOpaqueIdentifier";
              mountHookTypesDev();
              return mountOpaqueIdentifier();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnMountWithHookTypesInDEV = {
            readContext: function(context, observedBits) {
              return readContext(context, observedBits);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context, observedBits) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context, observedBits);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return mountImperativeHandle(ref, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return mountMutableSource(source, getSnapshot, subscribe);
            },
            useOpaqueIdentifier: function() {
              currentHookNameInDev = "useOpaqueIdentifier";
              updateHookTypesDev();
              return mountOpaqueIdentifier();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnUpdateInDEV = {
            readContext: function(context, observedBits) {
              return readContext(context, observedBits);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context, observedBits) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context, observedBits);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource(source, getSnapshot, subscribe);
            },
            useOpaqueIdentifier: function() {
              currentHookNameInDev = "useOpaqueIdentifier";
              updateHookTypesDev();
              return updateOpaqueIdentifier();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnRerenderInDEV = {
            readContext: function(context, observedBits) {
              return readContext(context, observedBits);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context, observedBits) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context, observedBits);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource(source, getSnapshot, subscribe);
            },
            useOpaqueIdentifier: function() {
              currentHookNameInDev = "useOpaqueIdentifier";
              updateHookTypesDev();
              return rerenderOpaqueIdentifier();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnMountInDEV = {
            readContext: function(context, observedBits) {
              warnInvalidContextAccess();
              return readContext(context, observedBits);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context, observedBits) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return readContext(context, observedBits);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountImperativeHandle(ref, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountMutableSource(source, getSnapshot, subscribe);
            },
            useOpaqueIdentifier: function() {
              currentHookNameInDev = "useOpaqueIdentifier";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountOpaqueIdentifier();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnUpdateInDEV = {
            readContext: function(context, observedBits) {
              warnInvalidContextAccess();
              return readContext(context, observedBits);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context, observedBits) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context, observedBits);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource(source, getSnapshot, subscribe);
            },
            useOpaqueIdentifier: function() {
              currentHookNameInDev = "useOpaqueIdentifier";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateOpaqueIdentifier();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnRerenderInDEV = {
            readContext: function(context, observedBits) {
              warnInvalidContextAccess();
              return readContext(context, observedBits);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context, observedBits) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context, observedBits);
            },
            useEffect: function(create, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create, deps);
            },
            useImperativeHandle: function(ref, create, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create, deps);
            },
            useLayoutEffect: function(create, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create, deps);
            },
            useMemo: function(create, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource(source, getSnapshot, subscribe);
            },
            useOpaqueIdentifier: function() {
              currentHookNameInDev = "useOpaqueIdentifier";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderOpaqueIdentifier();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
        }
        var now$1 = Scheduler.unstable_now;
        var commitTime = 0;
        var profilerStartTime = -1;
        function getCommitTime() {
          return commitTime;
        }
        function recordCommitTime() {
          commitTime = now$1();
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now$1();
          if (fiber.actualStartTime < 0) {
            fiber.actualStartTime = now$1();
          }
        }
        function stopProfilerTimerIfRunning(fiber) {
          profilerStartTime = -1;
        }
        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
          if (profilerStartTime >= 0) {
            var elapsedTime = now$1() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            if (overrideBaseTime) {
              fiber.selfBaseDuration = elapsedTime;
            }
            profilerStartTime = -1;
          }
        }
        function transferActualDuration(fiber) {
          var child = fiber.child;
          while (child) {
            fiber.actualDuration += child.actualDuration;
            child = child.sibling;
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var didReceiveUpdate = false;
        var didWarnAboutBadClass;
        var didWarnAboutModulePatternComponent;
        var didWarnAboutContextTypeOnFunctionComponent;
        var didWarnAboutGetDerivedStateOnFunctionComponent;
        var didWarnAboutFunctionRefs;
        var didWarnAboutReassigningProps;
        var didWarnAboutRevealOrder;
        var didWarnAboutTailOptions;
        {
          didWarnAboutBadClass = {};
          didWarnAboutModulePatternComponent = {};
          didWarnAboutContextTypeOnFunctionComponent = {};
          didWarnAboutGetDerivedStateOnFunctionComponent = {};
          didWarnAboutFunctionRefs = {};
          didWarnAboutReassigningProps = false;
          didWarnAboutRevealOrder = {};
          didWarnAboutTailOptions = {};
        }
        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
          if (current2 === null) {
            workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
          }
        }
        function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        }
        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component));
              }
            }
          }
          var render2 = Component.render;
          var ref = workInProgress2.ref;
          var nextChildren;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
            if (workInProgress2.mode & StrictMode) {
              disableLogs();
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
              } finally {
                reenableLogs();
              }
            }
            setIsRendering(false);
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current2, workInProgress2, Component, nextProps, updateLanes, renderLanes2) {
          if (current2 === null) {
            var type = Component.type;
            if (isSimpleFunctionComponent(type) && Component.compare === null && Component.defaultProps === void 0) {
              var resolvedType = type;
              {
                resolvedType = resolveFunctionForHotReloading(type);
              }
              workInProgress2.tag = SimpleMemoComponent;
              workInProgress2.type = resolvedType;
              {
                validateFunctionComponentInDev(workInProgress2, type);
              }
              return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, updateLanes, renderLanes2);
            }
            {
              var innerPropTypes = type.propTypes;
              if (innerPropTypes) {
                checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(type));
              }
            }
            var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
            child.ref = workInProgress2.ref;
            child.return = workInProgress2;
            workInProgress2.child = child;
            return child;
          }
          {
            var _type = Component.type;
            var _innerPropTypes = _type.propTypes;
            if (_innerPropTypes) {
              checkPropTypes(_innerPropTypes, nextProps, "prop", getComponentName(_type));
            }
          }
          var currentChild = current2.child;
          if (!includesSomeLane(updateLanes, renderLanes2)) {
            var prevProps = currentChild.memoizedProps;
            var compare2 = Component.compare;
            compare2 = compare2 !== null ? compare2 : shallowEqual;
            if (compare2(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
          }
          workInProgress2.flags |= PerformedWork;
          var newChild = createWorkInProgress(currentChild, nextProps);
          newChild.ref = workInProgress2.ref;
          newChild.return = workInProgress2;
          workInProgress2.child = newChild;
          return newChild;
        }
        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, updateLanes, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerMemoType = workInProgress2.elementType;
              if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                var lazyComponent = outerMemoType;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  outerMemoType = init(payload);
                } catch (x) {
                  outerMemoType = null;
                }
                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(outerPropTypes, nextProps, "prop", getComponentName(outerMemoType));
                }
              }
            }
          }
          if (current2 !== null) {
            var prevProps = current2.memoizedProps;
            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {
              didReceiveUpdate = false;
              if (!includesSomeLane(renderLanes2, updateLanes)) {
                workInProgress2.lanes = current2.lanes;
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              }
            }
          }
          return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
        }
        function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          var prevState = current2 !== null ? current2.memoizedState : null;
          if (nextProps.mode === "hidden" || nextProps.mode === "unstable-defer-without-hiding") {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              var nextState = {
                baseLanes: NoLanes
              };
              workInProgress2.memoizedState = nextState;
              pushRenderLanes(workInProgress2, renderLanes2);
            } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
              var nextBaseLanes;
              if (prevState !== null) {
                var prevBaseLanes = prevState.baseLanes;
                nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
              } else {
                nextBaseLanes = renderLanes2;
              }
              {
                markSpawnedWork(OffscreenLane);
              }
              workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
              var _nextState = {
                baseLanes: nextBaseLanes
              };
              workInProgress2.memoizedState = _nextState;
              pushRenderLanes(workInProgress2, nextBaseLanes);
              return null;
            } else {
              var _nextState2 = {
                baseLanes: NoLanes
              };
              workInProgress2.memoizedState = _nextState2;
              var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
              pushRenderLanes(workInProgress2, subtreeRenderLanes2);
            }
          } else {
            var _subtreeRenderLanes;
            if (prevState !== null) {
              _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
              workInProgress2.memoizedState = null;
            } else {
              _subtreeRenderLanes = renderLanes2;
            }
            pushRenderLanes(workInProgress2, _subtreeRenderLanes);
          }
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        var updateLegacyHiddenComponent = updateOffscreenComponent;
        function updateFragment(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMode(current2, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateProfiler(current2, workInProgress2, renderLanes2) {
          {
            workInProgress2.flags |= Update;
            var stateNode = workInProgress2.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markRef(current2, workInProgress2) {
          var ref = workInProgress2.ref;
          if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
            workInProgress2.flags |= Ref2;
          }
        }
        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component));
              }
            }
          }
          var context;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
            context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          var nextChildren;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
            if (workInProgress2.mode & StrictMode) {
              disableLogs();
              try {
                nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
              } finally {
                reenableLogs();
              }
            }
            setIsRendering(false);
          }
          if (current2 !== null && !didReceiveUpdate) {
            bailoutHooks(current2, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component.propTypes;
              if (innerPropTypes) {
                checkPropTypes(innerPropTypes, nextProps, "prop", getComponentName(Component));
              }
            }
          }
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var instance = workInProgress2.stateNode;
          var shouldUpdate;
          if (instance === null) {
            if (current2 !== null) {
              current2.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
            constructClassInstance(workInProgress2, Component, nextProps);
            mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
            shouldUpdate = true;
          } else if (current2 === null) {
            shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          } else {
            shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
          }
          var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
          {
            var inst = workInProgress2.stateNode;
            if (shouldUpdate && inst.props !== nextProps) {
              if (!didWarnAboutReassigningProps) {
                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentName(workInProgress2.type) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          return nextUnitOfWork;
        }
        function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
          markRef(current2, workInProgress2);
          var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (!shouldUpdate && !didCaptureError) {
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component, false);
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          var instance = workInProgress2.stateNode;
          ReactCurrentOwner$1.current = workInProgress2;
          var nextChildren;
          if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
            nextChildren = null;
            {
              stopProfilerTimerIfRunning();
            }
          } else {
            {
              setIsRendering(true);
              nextChildren = instance.render();
              if (workInProgress2.mode & StrictMode) {
                disableLogs();
                try {
                  instance.render();
                } finally {
                  reenableLogs();
                }
              }
              setIsRendering(false);
            }
          }
          workInProgress2.flags |= PerformedWork;
          if (current2 !== null && didCaptureError) {
            forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          workInProgress2.memoizedState = instance.state;
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component, true);
          }
          return workInProgress2.child;
        }
        function pushHostRootContext(workInProgress2) {
          var root2 = workInProgress2.stateNode;
          if (root2.pendingContext) {
            pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
          } else if (root2.context) {
            pushTopLevelContextObject(workInProgress2, root2.context, false);
          }
          pushHostContainer(workInProgress2, root2.containerInfo);
        }
        function updateHostRoot(current2, workInProgress2, renderLanes2) {
          pushHostRootContext(workInProgress2);
          var updateQueue = workInProgress2.updateQueue;
          if (!(current2 !== null && updateQueue !== null)) {
            {
              throw Error("If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          var nextProps = workInProgress2.pendingProps;
          var prevState = workInProgress2.memoizedState;
          var prevChildren = prevState !== null ? prevState.element : null;
          cloneUpdateQueue(current2, workInProgress2);
          processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
          var nextState = workInProgress2.memoizedState;
          var nextChildren = nextState.element;
          if (nextChildren === prevChildren) {
            resetHydrationState();
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          var root2 = workInProgress2.stateNode;
          if (root2.hydrate && enterHydrationState(workInProgress2)) {
            {
              var mutableSourceEagerHydrationData = root2.mutableSourceEagerHydrationData;
              if (mutableSourceEagerHydrationData != null) {
                for (var i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
                  var mutableSource = mutableSourceEagerHydrationData[i];
                  var version = mutableSourceEagerHydrationData[i + 1];
                  setWorkInProgressVersion(mutableSource, version);
                }
              }
            }
            var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            workInProgress2.child = child;
            var node = child;
            while (node) {
              node.flags = node.flags & ~Placement | Hydrating;
              node = node.sibling;
            }
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            resetHydrationState();
          }
          return workInProgress2.child;
        }
        function updateHostComponent(current2, workInProgress2, renderLanes2) {
          pushHostContext(workInProgress2);
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          var type = workInProgress2.type;
          var nextProps = workInProgress2.pendingProps;
          var prevProps = current2 !== null ? current2.memoizedProps : null;
          var nextChildren = nextProps.children;
          var isDirectTextChild = shouldSetTextContent(type, nextProps);
          if (isDirectTextChild) {
            nextChildren = null;
          } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
            workInProgress2.flags |= ContentReset;
          }
          markRef(current2, workInProgress2);
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostText(current2, workInProgress2) {
          if (current2 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          return null;
        }
        function mountLazyComponent(_current, workInProgress2, elementType, updateLanes, renderLanes2) {
          if (_current !== null) {
            _current.alternate = null;
            workInProgress2.alternate = null;
            workInProgress2.flags |= Placement;
          }
          var props = workInProgress2.pendingProps;
          var lazyComponent = elementType;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;
          var Component = init(payload);
          workInProgress2.type = Component;
          var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
          var resolvedProps = resolveDefaultProps(Component, props);
          var child;
          switch (resolvedTag) {
            case FunctionComponent: {
              {
                validateFunctionComponentInDev(workInProgress2, Component);
                workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
              }
              child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ClassComponent: {
              {
                workInProgress2.type = Component = resolveClassForHotReloading(Component);
              }
              child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case ForwardRef: {
              {
                workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
              }
              child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
              return child;
            }
            case MemoComponent: {
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = Component.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(outerPropTypes, resolvedProps, "prop", getComponentName(Component));
                  }
                }
              }
              child = updateMemoComponent(null, workInProgress2, Component, resolveDefaultProps(Component.type, resolvedProps), updateLanes, renderLanes2);
              return child;
            }
          }
          var hint = "";
          {
            if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
              hint = " Did you wrap a component in React.lazy() more than once?";
            }
          }
          {
            {
              throw Error("Element type is invalid. Received a promise that resolves to: " + Component + ". Lazy element type must resolve to a class or function." + hint);
            }
          }
        }
        function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
          if (_current !== null) {
            _current.alternate = null;
            workInProgress2.alternate = null;
            workInProgress2.flags |= Placement;
          }
          workInProgress2.tag = ClassComponent;
          var hasContext;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          constructClassInstance(workInProgress2, Component, nextProps);
          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
        }
        function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
          if (_current !== null) {
            _current.alternate = null;
            workInProgress2.alternate = null;
            workInProgress2.flags |= Placement;
          }
          var props = workInProgress2.pendingProps;
          var context;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
            context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var value;
          {
            if (Component.prototype && typeof Component.prototype.render === "function") {
              var componentName = getComponentName(Component) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
            if (workInProgress2.mode & StrictMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
            }
            setIsRendering(true);
            ReactCurrentOwner$1.current = workInProgress2;
            value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
            setIsRendering(false);
          }
          workInProgress2.flags |= PerformedWork;
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentName(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
            {
              var _componentName2 = getComponentName(Component) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            workInProgress2.tag = ClassComponent;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            var hasContext = false;
            if (isContextProvider(Component)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
            initializeUpdateQueue(workInProgress2);
            var getDerivedStateFromProps = Component.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, Component, getDerivedStateFromProps, props);
            }
            adoptClassInstance(workInProgress2, value);
            mountClassInstance(workInProgress2, Component, props, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
          } else {
            workInProgress2.tag = FunctionComponent;
            {
              if (workInProgress2.mode & StrictMode) {
                disableLogs();
                try {
                  value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                } finally {
                  reenableLogs();
                }
              }
            }
            reconcileChildren(null, workInProgress2, value, renderLanes2);
            {
              validateFunctionComponentInDev(workInProgress2, Component);
            }
            return workInProgress2.child;
          }
        }
        function validateFunctionComponentInDev(workInProgress2, Component) {
          {
            if (Component) {
              if (Component.childContextTypes) {
                error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
              }
            }
            if (workInProgress2.ref !== null) {
              var info = "";
              var ownerName = getCurrentFiberOwnerNameInDevOrNull();
              if (ownerName) {
                info += "\n\nCheck the render method of `" + ownerName + "`.";
              }
              var warningKey = ownerName || workInProgress2._debugID || "";
              var debugSource = workInProgress2._debugSource;
              if (debugSource) {
                warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
              }
              if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
              }
            }
            if (typeof Component.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentName(Component) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component.contextType === "object" && Component.contextType !== null) {
              var _componentName4 = getComponentName(Component) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        var SUSPENDED_MARKER = {
          dehydrated: null,
          retryLane: NoLane
        };
        function mountSuspenseOffscreenState(renderLanes2) {
          return {
            baseLanes: renderLanes2
          };
        }
        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
          return {
            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2)
          };
        }
        function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            var suspenseState = current2.memoizedState;
            if (suspenseState === null) {
              return false;
            }
          }
          return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        }
        function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
          return removeLanes(current2.childLanes, renderLanes2);
        }
        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          {
            if (shouldSuspend(workInProgress2)) {
              workInProgress2.flags |= DidCapture;
            }
          }
          var suspenseContext = suspenseStackCursor.current;
          var showFallback = false;
          var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
            showFallback = true;
            workInProgress2.flags &= ~DidCapture;
          } else {
            if (current2 === null || current2.memoizedState !== null) {
              if (nextProps.fallback !== void 0 && nextProps.unstable_avoidThisFallback !== true) {
                suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
              }
            }
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          pushSuspenseContext(workInProgress2, suspenseContext);
          if (current2 === null) {
            if (nextProps.fallback !== void 0) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            if (showFallback) {
              var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var primaryChildFragment = workInProgress2.child;
              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackFragment;
            } else if (typeof nextProps.unstable_expectedLoadTime === "number") {
              var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var _primaryChildFragment = workInProgress2.child;
              _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              workInProgress2.lanes = SomeRetryLane;
              {
                markSpawnedWork(SomeRetryLane);
              }
              return _fallbackFragment;
            } else {
              return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren, renderLanes2);
            }
          } else {
            var prevState = current2.memoizedState;
            if (prevState !== null) {
              if (showFallback) {
                var _nextFallbackChildren2 = nextProps.fallback;
                var _nextPrimaryChildren2 = nextProps.children;
                var _fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes2);
                var _primaryChildFragment3 = workInProgress2.child;
                var prevOffscreenState = current2.child.memoizedState;
                _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return _fallbackChildFragment;
              } else {
                var _nextPrimaryChildren3 = nextProps.children;
                var _primaryChildFragment4 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren3, renderLanes2);
                workInProgress2.memoizedState = null;
                return _primaryChildFragment4;
              }
            } else {
              if (showFallback) {
                var _nextFallbackChildren3 = nextProps.fallback;
                var _nextPrimaryChildren4 = nextProps.children;
                var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes2);
                var _primaryChildFragment5 = workInProgress2.child;
                var _prevOffscreenState = current2.child.memoizedState;
                _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes2);
                _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return _fallbackChildFragment2;
              } else {
                var _nextPrimaryChildren5 = nextProps.children;
                var _primaryChildFragment6 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren5, renderLanes2);
                workInProgress2.memoizedState = null;
                return _primaryChildFragment6;
              }
            }
          }
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes2, null);
          primaryChildFragment.return = workInProgress2;
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var progressedPrimaryFragment = workInProgress2.child;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          var fallbackChildFragment;
          if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = 0;
              primaryChildFragment.treeBaseDuration = 0;
            }
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          } else {
            primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null);
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          }
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function createWorkInProgressOffscreenFiber(current2, offscreenProps) {
          return createWorkInProgress(current2, offscreenProps);
        }
        function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
            mode: "visible",
            children: primaryChildren
          });
          if ((workInProgress2.mode & BlockingMode) === NoMode) {
            primaryChildFragment.lanes = renderLanes2;
          }
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = null;
          if (currentFallbackChildFragment !== null) {
            currentFallbackChildFragment.nextEffect = null;
            currentFallbackChildFragment.flags = Deletion;
            workInProgress2.firstEffect = workInProgress2.lastEffect = currentFallbackChildFragment;
          }
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var currentPrimaryChildFragment = current2.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          if ((mode & BlockingMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {
            var progressedPrimaryFragment = workInProgress2.child;
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
              primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
            }
            var progressedLastEffect = primaryChildFragment.lastEffect;
            if (progressedLastEffect !== null) {
              workInProgress2.firstEffect = primaryChildFragment.firstEffect;
              workInProgress2.lastEffect = progressedLastEffect;
              progressedLastEffect.nextEffect = null;
            } else {
              workInProgress2.firstEffect = workInProgress2.lastEffect = null;
            }
          } else {
            primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
          }
          var fallbackChildFragment;
          if (currentFallbackChildFragment !== null) {
            fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
          } else {
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
          }
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function scheduleWorkOnFiber(fiber, renderLanes2) {
          fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
          }
          scheduleWorkOnParentPath(fiber.return, renderLanes2);
        }
        function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
          var node = firstChild;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state = node.memoizedState;
              if (state !== null) {
                scheduleWorkOnFiber(node, renderLanes2);
              }
            } else if (node.tag === SuspenseListComponent) {
              scheduleWorkOnFiber(node, renderLanes2);
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === workInProgress2) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress2) {
                return;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        function findLastContentRow(firstChild) {
          var row = firstChild;
          var lastContentRow = null;
          while (row !== null) {
            var currentRow = row.alternate;
            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              lastContentRow = row;
            }
            row = row.sibling;
          }
          return lastContentRow;
        }
        function validateRevealOrder(revealOrder) {
          {
            if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
              didWarnAboutRevealOrder[revealOrder] = true;
              if (typeof revealOrder === "string") {
                switch (revealOrder.toLowerCase()) {
                  case "together":
                  case "forwards":
                  case "backwards": {
                    error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  case "forward":
                  case "backward": {
                    error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  default:
                    error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                    break;
                }
              } else {
                error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
              }
            }
          }
        }
        function validateTailOptions(tailMode, revealOrder) {
          {
            if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
              if (tailMode !== "collapsed" && tailMode !== "hidden") {
                didWarnAboutTailOptions[tailMode] = true;
                error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
              } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                didWarnAboutTailOptions[tailMode] = true;
                error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
              }
            }
          }
        }
        function validateSuspenseListNestedChild(childSlot, index2) {
          {
            var isArray2 = Array.isArray(childSlot);
            var isIterable = !isArray2 && typeof getIteratorFn(childSlot) === "function";
            if (isArray2 || isIterable) {
              var type = isArray2 ? "array" : "iterable";
              error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type);
              return false;
            }
          }
          return true;
        }
        function validateSuspenseListChildren(children, revealOrder) {
          {
            if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
              if (Array.isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                  if (!validateSuspenseListNestedChild(children[i], i)) {
                    return;
                  }
                }
              } else {
                var iteratorFn = getIteratorFn(children);
                if (typeof iteratorFn === "function") {
                  var childrenIterator = iteratorFn.call(children);
                  if (childrenIterator) {
                    var step = childrenIterator.next();
                    var _i = 0;
                    for (; !step.done; step = childrenIterator.next()) {
                      if (!validateSuspenseListNestedChild(step.value, _i)) {
                        return;
                      }
                      _i++;
                    }
                  }
                } else {
                  error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                }
              }
            }
          }
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
          var renderState = workInProgress2.memoizedState;
          if (renderState === null) {
            workInProgress2.memoizedState = {
              isBackwards,
              rendering: null,
              renderingStartTime: 0,
              last: lastContentRow,
              tail,
              tailMode,
              lastEffect: lastEffectBeforeRendering
            };
          } else {
            renderState.isBackwards = isBackwards;
            renderState.rendering = null;
            renderState.renderingStartTime = 0;
            renderState.last = lastContentRow;
            renderState.tail = tail;
            renderState.tailMode = tailMode;
            renderState.lastEffect = lastEffectBeforeRendering;
          }
        }
        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var revealOrder = nextProps.revealOrder;
          var tailMode = nextProps.tail;
          var newChildren = nextProps.children;
          validateRevealOrder(revealOrder);
          validateTailOptions(tailMode, revealOrder);
          validateSuspenseListChildren(newChildren, revealOrder);
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          var suspenseContext = suspenseStackCursor.current;
          var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          if (shouldForceFallback) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
            workInProgress2.flags |= DidCapture;
          } else {
            var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
            if (didSuspendBefore) {
              propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }
          pushSuspenseContext(workInProgress2, suspenseContext);
          if ((workInProgress2.mode & BlockingMode) === NoMode) {
            workInProgress2.memoizedState = null;
          } else {
            switch (revealOrder) {
              case "forwards": {
                var lastContentRow = findLastContentRow(workInProgress2.child);
                var tail;
                if (lastContentRow === null) {
                  tail = workInProgress2.child;
                  workInProgress2.child = null;
                } else {
                  tail = lastContentRow.sibling;
                  lastContentRow.sibling = null;
                }
                initSuspenseListRenderState(workInProgress2, false, tail, lastContentRow, tailMode, workInProgress2.lastEffect);
                break;
              }
              case "backwards": {
                var _tail = null;
                var row = workInProgress2.child;
                workInProgress2.child = null;
                while (row !== null) {
                  var currentRow = row.alternate;
                  if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                    workInProgress2.child = row;
                    break;
                  }
                  var nextRow = row.sibling;
                  row.sibling = _tail;
                  _tail = row;
                  row = nextRow;
                }
                initSuspenseListRenderState(workInProgress2, true, _tail, null, tailMode, workInProgress2.lastEffect);
                break;
              }
              case "together": {
                initSuspenseListRenderState(workInProgress2, false, null, null, void 0, workInProgress2.lastEffect);
                break;
              }
              default: {
                workInProgress2.memoizedState = null;
              }
            }
          }
          return workInProgress2.child;
        }
        function updatePortalComponent(current2, workInProgress2, renderLanes2) {
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          var nextChildren = workInProgress2.pendingProps;
          if (current2 === null) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
        function updateContextProvider(current2, workInProgress2, renderLanes2) {
          var providerType = workInProgress2.type;
          var context = providerType._context;
          var newProps = workInProgress2.pendingProps;
          var oldProps = workInProgress2.memoizedProps;
          var newValue = newProps.value;
          {
            if (!("value" in newProps)) {
              if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
              }
            }
            var providerPropTypes = workInProgress2.type.propTypes;
            if (providerPropTypes) {
              checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
            }
          }
          pushProvider(workInProgress2, newValue);
          if (oldProps !== null) {
            var oldValue = oldProps.value;
            var changedBits = calculateChangedBits(context, newValue, oldValue);
            if (changedBits === 0) {
              if (oldProps.children === newProps.children && !hasContextChanged()) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            } else {
              propagateContextChange(workInProgress2, context, changedBits, renderLanes2);
            }
          }
          var newChildren = newProps.children;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingContextAsConsumer = false;
        function updateContextConsumer(current2, workInProgress2, renderLanes2) {
          var context = workInProgress2.type;
          {
            if (context._context === void 0) {
              if (context !== context.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context = context._context;
            }
          }
          var newProps = workInProgress2.pendingProps;
          var render2 = newProps.children;
          {
            if (typeof render2 !== "function") {
              error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var newValue = readContext(context, newProps.unstable_observedBits);
          var newChildren;
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            newChildren = render2(newValue);
            setIsRendering(false);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markWorkInProgressReceivedUpdate() {
          didReceiveUpdate = true;
        }
        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
          if (current2 !== null) {
            workInProgress2.dependencies = current2.dependencies;
          }
          {
            stopProfilerTimerIfRunning();
          }
          markSkippedUpdateLanes(workInProgress2.lanes);
          if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
            return null;
          } else {
            cloneChildFibers(current2, workInProgress2);
            return workInProgress2.child;
          }
        }
        function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
          {
            var returnFiber = oldWorkInProgress.return;
            if (returnFiber === null) {
              throw new Error("Cannot swap the root fiber.");
            }
            current2.alternate = null;
            oldWorkInProgress.alternate = null;
            newWorkInProgress.index = oldWorkInProgress.index;
            newWorkInProgress.sibling = oldWorkInProgress.sibling;
            newWorkInProgress.return = oldWorkInProgress.return;
            newWorkInProgress.ref = oldWorkInProgress.ref;
            if (oldWorkInProgress === returnFiber.child) {
              returnFiber.child = newWorkInProgress;
            } else {
              var prevSibling = returnFiber.child;
              if (prevSibling === null) {
                throw new Error("Expected parent to have a child.");
              }
              while (prevSibling.sibling !== oldWorkInProgress) {
                prevSibling = prevSibling.sibling;
                if (prevSibling === null) {
                  throw new Error("Expected to find the previous sibling.");
                }
              }
              prevSibling.sibling = newWorkInProgress;
            }
            var last = returnFiber.lastEffect;
            if (last !== null) {
              last.nextEffect = current2;
              returnFiber.lastEffect = current2;
            } else {
              returnFiber.firstEffect = returnFiber.lastEffect = current2;
            }
            current2.nextEffect = null;
            current2.flags = Deletion;
            newWorkInProgress.flags |= Placement;
            return newWorkInProgress;
          }
        }
        function beginWork(current2, workInProgress2, renderLanes2) {
          var updateLanes = workInProgress2.lanes;
          {
            if (workInProgress2._debugNeedsRemount && current2 !== null) {
              return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
            }
          }
          if (current2 !== null) {
            var oldProps = current2.memoizedProps;
            var newProps = workInProgress2.pendingProps;
            if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {
              didReceiveUpdate = true;
            } else if (!includesSomeLane(renderLanes2, updateLanes)) {
              didReceiveUpdate = false;
              switch (workInProgress2.tag) {
                case HostRoot:
                  pushHostRootContext(workInProgress2);
                  resetHydrationState();
                  break;
                case HostComponent:
                  pushHostContext(workInProgress2);
                  break;
                case ClassComponent: {
                  var Component = workInProgress2.type;
                  if (isContextProvider(Component)) {
                    pushContextProvider(workInProgress2);
                  }
                  break;
                }
                case HostPortal:
                  pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                  break;
                case ContextProvider: {
                  var newValue = workInProgress2.memoizedProps.value;
                  pushProvider(workInProgress2, newValue);
                  break;
                }
                case Profiler:
                  {
                    var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                    if (hasChildWork) {
                      workInProgress2.flags |= Update;
                    }
                    var stateNode = workInProgress2.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                  }
                  break;
                case SuspenseComponent: {
                  var state = workInProgress2.memoizedState;
                  if (state !== null) {
                    var primaryChildFragment = workInProgress2.child;
                    var primaryChildLanes = primaryChildFragment.childLanes;
                    if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                      return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                    } else {
                      pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                      var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                      if (child !== null) {
                        return child.sibling;
                      } else {
                        return null;
                      }
                    }
                  } else {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  }
                  break;
                }
                case SuspenseListComponent: {
                  var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                  var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                  if (didSuspendBefore) {
                    if (_hasChildWork) {
                      return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                    }
                    workInProgress2.flags |= DidCapture;
                  }
                  var renderState = workInProgress2.memoizedState;
                  if (renderState !== null) {
                    renderState.rendering = null;
                    renderState.tail = null;
                    renderState.lastEffect = null;
                  }
                  pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                  if (_hasChildWork) {
                    break;
                  } else {
                    return null;
                  }
                }
                case OffscreenComponent:
                case LegacyHiddenComponent: {
                  workInProgress2.lanes = NoLanes;
                  return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
                }
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            } else {
              if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              } else {
                didReceiveUpdate = false;
              }
            }
          } else {
            didReceiveUpdate = false;
          }
          workInProgress2.lanes = NoLanes;
          switch (workInProgress2.tag) {
            case IndeterminateComponent: {
              return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
            }
            case LazyComponent: {
              var elementType = workInProgress2.elementType;
              return mountLazyComponent(current2, workInProgress2, elementType, updateLanes, renderLanes2);
            }
            case FunctionComponent: {
              var _Component = workInProgress2.type;
              var unresolvedProps = workInProgress2.pendingProps;
              var resolvedProps = workInProgress2.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
              return updateFunctionComponent(current2, workInProgress2, _Component, resolvedProps, renderLanes2);
            }
            case ClassComponent: {
              var _Component2 = workInProgress2.type;
              var _unresolvedProps = workInProgress2.pendingProps;
              var _resolvedProps = workInProgress2.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);
              return updateClassComponent(current2, workInProgress2, _Component2, _resolvedProps, renderLanes2);
            }
            case HostRoot:
              return updateHostRoot(current2, workInProgress2, renderLanes2);
            case HostComponent:
              return updateHostComponent(current2, workInProgress2, renderLanes2);
            case HostText:
              return updateHostText(current2, workInProgress2);
            case SuspenseComponent:
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            case HostPortal:
              return updatePortalComponent(current2, workInProgress2, renderLanes2);
            case ForwardRef: {
              var type = workInProgress2.type;
              var _unresolvedProps2 = workInProgress2.pendingProps;
              var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
              return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
            }
            case Fragment:
              return updateFragment(current2, workInProgress2, renderLanes2);
            case Mode:
              return updateMode(current2, workInProgress2, renderLanes2);
            case Profiler:
              return updateProfiler(current2, workInProgress2, renderLanes2);
            case ContextProvider:
              return updateContextProvider(current2, workInProgress2, renderLanes2);
            case ContextConsumer:
              return updateContextConsumer(current2, workInProgress2, renderLanes2);
            case MemoComponent: {
              var _type2 = workInProgress2.type;
              var _unresolvedProps3 = workInProgress2.pendingProps;
              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = _type2.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(outerPropTypes, _resolvedProps3, "prop", getComponentName(_type2));
                  }
                }
              }
              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
              return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, updateLanes, renderLanes2);
            }
            case SimpleMemoComponent: {
              return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, updateLanes, renderLanes2);
            }
            case IncompleteClassComponent: {
              var _Component3 = workInProgress2.type;
              var _unresolvedProps4 = workInProgress2.pendingProps;
              var _resolvedProps4 = workInProgress2.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);
              return mountIncompleteClassComponent(current2, workInProgress2, _Component3, _resolvedProps4, renderLanes2);
            }
            case SuspenseListComponent: {
              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
            }
            case FundamentalComponent: {
              break;
            }
            case ScopeComponent: {
              break;
            }
            case Block: {
              break;
            }
            case OffscreenComponent: {
              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
            }
            case LegacyHiddenComponent: {
              return updateLegacyHiddenComponent(current2, workInProgress2, renderLanes2);
            }
          }
          {
            {
              throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= Update;
        }
        function markRef$1(workInProgress2) {
          workInProgress2.flags |= Ref2;
        }
        var appendAllChildren;
        var updateHostContainer;
        var updateHostComponent$1;
        var updateHostText$1;
        {
          appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
            var node = workInProgress2.child;
            while (node !== null) {
              if (node.tag === HostComponent || node.tag === HostText) {
                appendInitialChild(parent, node.stateNode);
              } else if (node.tag === HostPortal)
                ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          };
          updateHostContainer = function(workInProgress2) {
          };
          updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
            var oldProps = current2.memoizedProps;
            if (oldProps === newProps) {
              return;
            }
            var instance = workInProgress2.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
            workInProgress2.updateQueue = updatePayload;
            if (updatePayload) {
              markUpdate(workInProgress2);
            }
          };
          updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
            if (oldText !== newText) {
              markUpdate(workInProgress2);
            }
          };
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (getIsHydrating()) {
            return;
          }
          switch (renderState.tailMode) {
            case "hidden": {
              var tailNode = renderState.tail;
              var lastTailNode = null;
              while (tailNode !== null) {
                if (tailNode.alternate !== null) {
                  lastTailNode = tailNode;
                }
                tailNode = tailNode.sibling;
              }
              if (lastTailNode === null) {
                renderState.tail = null;
              } else {
                lastTailNode.sibling = null;
              }
              break;
            }
            case "collapsed": {
              var _tailNode = renderState.tail;
              var _lastTailNode = null;
              while (_tailNode !== null) {
                if (_tailNode.alternate !== null) {
                  _lastTailNode = _tailNode;
                }
                _tailNode = _tailNode.sibling;
              }
              if (_lastTailNode === null) {
                if (!hasRenderedATailFallback && renderState.tail !== null) {
                  renderState.tail.sibling = null;
                } else {
                  renderState.tail = null;
                }
              } else {
                _lastTailNode.sibling = null;
              }
              break;
            }
          }
        }
        function completeWork(current2, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case LazyComponent:
            case SimpleMemoComponent:
            case FunctionComponent:
            case ForwardRef:
            case Fragment:
            case Mode:
            case Profiler:
            case ContextConsumer:
            case MemoComponent:
              return null;
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              return null;
            }
            case HostRoot: {
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              var fiberRoot = workInProgress2.stateNode;
              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }
              if (current2 === null || current2.child === null) {
                var wasHydrated = popHydrationState(workInProgress2);
                if (wasHydrated) {
                  markUpdate(workInProgress2);
                } else if (!fiberRoot.hydrate) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              updateHostContainer(workInProgress2);
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              var rootContainerInstance = getRootHostContainer();
              var type = workInProgress2.type;
              if (current2 !== null && workInProgress2.stateNode != null) {
                updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                if (current2.ref !== workInProgress2.ref) {
                  markRef$1(workInProgress2);
                }
              } else {
                if (!newProps) {
                  if (!(workInProgress2.stateNode !== null)) {
                    {
                      throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                  }
                  return null;
                }
                var currentHostContext = getHostContext();
                var _wasHydrated = popHydrationState(workInProgress2);
                if (_wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                  appendAllChildren(instance, workInProgress2, false, false);
                  workInProgress2.stateNode = instance;
                  if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                    markUpdate(workInProgress2);
                  }
                }
                if (workInProgress2.ref !== null) {
                  markRef$1(workInProgress2);
                }
              }
              return null;
            }
            case HostText: {
              var newText = newProps;
              if (current2 && workInProgress2.stateNode != null) {
                var oldText = current2.memoizedProps;
                updateHostText$1(current2, workInProgress2, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  if (!(workInProgress2.stateNode !== null)) {
                    {
                      throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                  }
                }
                var _rootContainerInstance = getRootHostContainer();
                var _currentHostContext = getHostContext();
                var _wasHydrated2 = popHydrationState(workInProgress2);
                if (_wasHydrated2) {
                  if (prepareToHydrateHostTextInstance(workInProgress2)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                }
              }
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var nextState = workInProgress2.memoizedState;
              if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                workInProgress2.lanes = renderLanes2;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = false;
              if (current2 === null) {
                if (workInProgress2.memoizedProps.fallback !== void 0) {
                  popHydrationState(workInProgress2);
                }
              } else {
                var prevState = current2.memoizedState;
                prevDidTimeout = prevState !== null;
              }
              if (nextDidTimeout && !prevDidTimeout) {
                if ((workInProgress2.mode & BlockingMode) !== NoMode) {
                  var hasInvisibleChildContext = current2 === null && workInProgress2.memoizedProps.unstable_avoidThisFallback !== true;
                  if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                    renderDidSuspend();
                  } else {
                    renderDidSuspendDelayIfPossible();
                  }
                }
              }
              {
                if (nextDidTimeout || prevDidTimeout) {
                  workInProgress2.flags |= Update;
                }
              }
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              updateHostContainer(workInProgress2);
              if (current2 === null) {
                preparePortalMount(workInProgress2.stateNode.containerInfo);
              }
              return null;
            case ContextProvider:
              popProvider(workInProgress2);
              return null;
            case IncompleteClassComponent: {
              var _Component = workInProgress2.type;
              if (isContextProvider(_Component)) {
                popContext(workInProgress2);
              }
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              var renderState = workInProgress2.memoizedState;
              if (renderState === null) {
                return null;
              }
              var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
              var renderedTail = renderState.rendering;
              if (renderedTail === null) {
                if (!didSuspendAlready) {
                  var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                  if (!cannotBeSuspended) {
                    var row = workInProgress2.child;
                    while (row !== null) {
                      var suspended = findFirstSuspended(row);
                      if (suspended !== null) {
                        didSuspendAlready = true;
                        workInProgress2.flags |= DidCapture;
                        cutOffTailIfNeeded(renderState, false);
                        var newThennables = suspended.updateQueue;
                        if (newThennables !== null) {
                          workInProgress2.updateQueue = newThennables;
                          workInProgress2.flags |= Update;
                        }
                        if (renderState.lastEffect === null) {
                          workInProgress2.firstEffect = null;
                        }
                        workInProgress2.lastEffect = renderState.lastEffect;
                        resetChildFibers(workInProgress2, renderLanes2);
                        pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                        return workInProgress2.child;
                      }
                      row = row.sibling;
                    }
                  }
                  if (renderState.tail !== null && now() > getRenderTargetTime()) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                    {
                      markSpawnedWork(SomeRetryLane);
                    }
                  }
                } else {
                  cutOffTailIfNeeded(renderState, false);
                }
              } else {
                if (!didSuspendAlready) {
                  var _suspended = findFirstSuspended(renderedTail);
                  if (_suspended !== null) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    var _newThennables = _suspended.updateQueue;
                    if (_newThennables !== null) {
                      workInProgress2.updateQueue = _newThennables;
                      workInProgress2.flags |= Update;
                    }
                    cutOffTailIfNeeded(renderState, true);
                    if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                      var lastEffect = workInProgress2.lastEffect = renderState.lastEffect;
                      if (lastEffect !== null) {
                        lastEffect.nextEffect = null;
                      }
                      return null;
                    }
                  } else if (now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                    {
                      markSpawnedWork(SomeRetryLane);
                    }
                  }
                }
                if (renderState.isBackwards) {
                  renderedTail.sibling = workInProgress2.child;
                  workInProgress2.child = renderedTail;
                } else {
                  var previousSibling = renderState.last;
                  if (previousSibling !== null) {
                    previousSibling.sibling = renderedTail;
                  } else {
                    workInProgress2.child = renderedTail;
                  }
                  renderState.last = renderedTail;
                }
              }
              if (renderState.tail !== null) {
                var next = renderState.tail;
                renderState.rendering = next;
                renderState.tail = next.sibling;
                renderState.lastEffect = workInProgress2.lastEffect;
                renderState.renderingStartTime = now();
                next.sibling = null;
                var suspenseContext = suspenseStackCursor.current;
                if (didSuspendAlready) {
                  suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                } else {
                  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                }
                pushSuspenseContext(workInProgress2, suspenseContext);
                return next;
              }
              return null;
            }
            case FundamentalComponent: {
              break;
            }
            case ScopeComponent: {
              break;
            }
            case Block:
              break;
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              popRenderLanes(workInProgress2);
              if (current2 !== null) {
                var _nextState = workInProgress2.memoizedState;
                var _prevState = current2.memoizedState;
                var prevIsHidden = _prevState !== null;
                var nextIsHidden = _nextState !== null;
                if (prevIsHidden !== nextIsHidden && newProps.mode !== "unstable-defer-without-hiding") {
                  workInProgress2.flags |= Update;
                }
              }
              return null;
            }
          }
          {
            {
              throw Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function unwindWork(workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case ClassComponent: {
              var Component = workInProgress2.type;
              if (isContextProvider(Component)) {
                popContext(workInProgress2);
              }
              var flags = workInProgress2.flags;
              if (flags & ShouldCapture) {
                workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case HostRoot: {
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              var _flags = workInProgress2.flags;
              if (!((_flags & DidCapture) === NoFlags)) {
                {
                  throw Error("The root failed to unmount after an error. This is likely a bug in React. Please file an issue.");
                }
              }
              workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
              return workInProgress2;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var _flags2 = workInProgress2.flags;
              if (_flags2 & ShouldCapture) {
                workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              return null;
            case ContextProvider:
              popProvider(workInProgress2);
              return null;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(workInProgress2);
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(interruptedWork) {
          switch (interruptedWork.tag) {
            case ClassComponent: {
              var childContextTypes = interruptedWork.type.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                popContext(interruptedWork);
              }
              break;
            }
            case HostRoot: {
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              resetWorkInProgressVersions();
              break;
            }
            case HostComponent: {
              popHostContext(interruptedWork);
              break;
            }
            case HostPortal:
              popHostContainer(interruptedWork);
              break;
            case SuspenseComponent:
              popSuspenseContext(interruptedWork);
              break;
            case SuspenseListComponent:
              popSuspenseContext(interruptedWork);
              break;
            case ContextProvider:
              popProvider(interruptedWork);
              break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(interruptedWork);
              break;
          }
        }
        function createCapturedValue(value, source) {
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
        }
        function showErrorDialog(boundary, errorInfo) {
          return true;
        }
        function logCapturedError(boundary, errorInfo) {
          try {
            var logError = showErrorDialog(boundary, errorInfo);
            if (logError === false) {
              return;
            }
            var error2 = errorInfo.value;
            if (true) {
              var source = errorInfo.source;
              var stack = errorInfo.stack;
              var componentStack = stack !== null ? stack : "";
              if (error2 != null && error2._suppressLogging) {
                if (boundary.tag === ClassComponent) {
                  return;
                }
                console["error"](error2);
              }
              var componentName = source ? getComponentName(source.type) : null;
              var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
              var errorBoundaryMessage;
              var errorBoundaryName = getComponentName(boundary.type);
              if (errorBoundaryName) {
                errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
              } else {
                errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
              }
              var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
              console["error"](combinedMessage);
            } else {
              console["error"](error2);
            }
          } catch (e) {
            setTimeout(function() {
              throw e;
            });
          }
        }
        var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
        function createRootErrorUpdate(fiber, errorInfo, lane) {
          var update = createUpdate(NoTimestamp, lane);
          update.tag = CaptureUpdate;
          update.payload = {
            element: null
          };
          var error2 = errorInfo.value;
          update.callback = function() {
            onUncaughtError(error2);
            logCapturedError(fiber, errorInfo);
          };
          return update;
        }
        function createClassErrorUpdate(fiber, errorInfo, lane) {
          var update = createUpdate(NoTimestamp, lane);
          update.tag = CaptureUpdate;
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if (typeof getDerivedStateFromError === "function") {
            var error$1 = errorInfo.value;
            update.payload = function() {
              logCapturedError(fiber, errorInfo);
              return getDerivedStateFromError(error$1);
            };
          }
          var inst = fiber.stateNode;
          if (inst !== null && typeof inst.componentDidCatch === "function") {
            update.callback = function callback() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              if (typeof getDerivedStateFromError !== "function") {
                markLegacyErrorBoundaryAsFailed(this);
                logCapturedError(fiber, errorInfo);
              }
              var error$12 = errorInfo.value;
              var stack = errorInfo.stack;
              this.componentDidCatch(error$12, {
                componentStack: stack !== null ? stack : ""
              });
              {
                if (typeof getDerivedStateFromError !== "function") {
                  if (!includesSomeLane(fiber.lanes, SyncLane)) {
                    error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || "Unknown");
                  }
                }
              }
            };
          } else {
            update.callback = function() {
              markFailedErrorBoundaryForHotReloading(fiber);
            };
          }
          return update;
        }
        function attachPingListener(root2, wakeable, lanes) {
          var pingCache = root2.pingCache;
          var threadIDs;
          if (pingCache === null) {
            pingCache = root2.pingCache = new PossiblyWeakMap$1();
            threadIDs = new Set();
            pingCache.set(wakeable, threadIDs);
          } else {
            threadIDs = pingCache.get(wakeable);
            if (threadIDs === void 0) {
              threadIDs = new Set();
              pingCache.set(wakeable, threadIDs);
            }
          }
          if (!threadIDs.has(lanes)) {
            threadIDs.add(lanes);
            var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
            wakeable.then(ping, ping);
          }
        }
        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= Incomplete;
          sourceFiber.firstEffect = sourceFiber.lastEffect = null;
          if (value !== null && typeof value === "object" && typeof value.then === "function") {
            var wakeable = value;
            if ((sourceFiber.mode & BlockingMode) === NoMode) {
              var currentSource = sourceFiber.alternate;
              if (currentSource) {
                sourceFiber.updateQueue = currentSource.updateQueue;
                sourceFiber.memoizedState = currentSource.memoizedState;
                sourceFiber.lanes = currentSource.lanes;
              } else {
                sourceFiber.updateQueue = null;
                sourceFiber.memoizedState = null;
              }
            }
            var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext);
            var _workInProgress = returnFiber;
            do {
              if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
                var wakeables = _workInProgress.updateQueue;
                if (wakeables === null) {
                  var updateQueue = new Set();
                  updateQueue.add(wakeable);
                  _workInProgress.updateQueue = updateQueue;
                } else {
                  wakeables.add(wakeable);
                }
                if ((_workInProgress.mode & BlockingMode) === NoMode) {
                  _workInProgress.flags |= DidCapture;
                  sourceFiber.flags |= ForceUpdateForLegacySuspense;
                  sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                  if (sourceFiber.tag === ClassComponent) {
                    var currentSourceFiber = sourceFiber.alternate;
                    if (currentSourceFiber === null) {
                      sourceFiber.tag = IncompleteClassComponent;
                    } else {
                      var update = createUpdate(NoTimestamp, SyncLane);
                      update.tag = ForceUpdate;
                      enqueueUpdate(sourceFiber, update);
                    }
                  }
                  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
                  return;
                }
                attachPingListener(root2, wakeable, rootRenderLanes);
                _workInProgress.flags |= ShouldCapture;
                _workInProgress.lanes = rootRenderLanes;
                return;
              }
              _workInProgress = _workInProgress.return;
            } while (_workInProgress !== null);
            value = new Error((getComponentName(sourceFiber.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
          }
          renderDidError();
          value = createCapturedValue(value, sourceFiber);
          var workInProgress2 = returnFiber;
          do {
            switch (workInProgress2.tag) {
              case HostRoot: {
                var _errorInfo = value;
                workInProgress2.flags |= ShouldCapture;
                var lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var _update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                enqueueCapturedUpdate(workInProgress2, _update);
                return;
              }
              case ClassComponent:
                var errorInfo = value;
                var ctor = workInProgress2.type;
                var instance = workInProgress2.stateNode;
                if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                  workInProgress2.flags |= ShouldCapture;
                  var _lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                  var _update2 = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                  enqueueCapturedUpdate(workInProgress2, _update2);
                  return;
                }
                break;
            }
            workInProgress2 = workInProgress2.return;
          } while (workInProgress2 !== null);
        }
        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        {
          didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
        }
        var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
        var callComponentWillUnmountWithTimer = function(current2, instance) {
          instance.props = current2.memoizedProps;
          instance.state = current2.memoizedState;
          {
            instance.componentWillUnmount();
          }
        };
        function safelyCallComponentWillUnmount(current2, instance) {
          {
            invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current2, instance);
            if (hasCaughtError()) {
              var unmountError = clearCaughtError();
              captureCommitPhaseError(current2, unmountError);
            }
          }
        }
        function safelyDetachRef(current2) {
          var ref = current2.ref;
          if (ref !== null) {
            if (typeof ref === "function") {
              {
                invokeGuardedCallback(null, ref, null, null);
                if (hasCaughtError()) {
                  var refError = clearCaughtError();
                  captureCommitPhaseError(current2, refError);
                }
              }
            } else {
              ref.current = null;
            }
          }
        }
        function safelyCallDestroy(current2, destroy) {
          {
            invokeGuardedCallback(null, destroy, null);
            if (hasCaughtError()) {
              var error2 = clearCaughtError();
              captureCommitPhaseError(current2, error2);
            }
          }
        }
        function commitBeforeMutationLifeCycles(current2, finishedWork) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent:
            case Block: {
              return;
            }
            case ClassComponent: {
              if (finishedWork.flags & Snapshot) {
                if (current2 !== null) {
                  var prevProps = current2.memoizedProps;
                  var prevState = current2.memoizedState;
                  var instance = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                    }
                  }
                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                    if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                    }
                  }
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                }
              }
              return;
            }
            case HostRoot: {
              {
                if (finishedWork.flags & Snapshot) {
                  var root2 = finishedWork.stateNode;
                  clearContainer(root2.containerInfo);
                }
              }
              return;
            }
            case HostComponent:
            case HostText:
            case HostPortal:
            case IncompleteClassComponent:
              return;
          }
          {
            {
              throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function commitHookEffectListUnmount(tag, finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & tag) === tag) {
                var destroy = effect.destroy;
                effect.destroy = void 0;
                if (destroy !== void 0) {
                  destroy();
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitHookEffectListMount(tag, finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & tag) === tag) {
                var create = effect.create;
                effect.destroy = create();
                {
                  var destroy = effect.destroy;
                  if (destroy !== void 0 && typeof destroy !== "function") {
                    var addendum = void 0;
                    if (destroy === null) {
                      addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                    } else if (typeof destroy.then === "function") {
                      addendum = "\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                    } else {
                      addendum = " You returned: " + destroy;
                    }
                    error("An effect function must not return anything besides a function, which is used for clean-up.%s", addendum);
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function schedulePassiveEffects(finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              var _effect = effect, next = _effect.next, tag = _effect.tag;
              if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {
                enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
                enqueuePendingPassiveHookEffectMount(finishedWork, effect);
              }
              effect = next;
            } while (effect !== firstEffect);
          }
        }
        function commitLifeCycles(finishedRoot, current2, finishedWork, committedLanes) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent:
            case Block: {
              {
                commitHookEffectListMount(Layout | HasEffect, finishedWork);
              }
              schedulePassiveEffects(finishedWork);
              return;
            }
            case ClassComponent: {
              var instance = finishedWork.stateNode;
              if (finishedWork.flags & Update) {
                if (current2 === null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                    }
                  }
                  {
                    instance.componentDidMount();
                  }
                } else {
                  var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                  var prevState = current2.memoizedState;
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                      }
                    }
                  }
                  {
                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                  }
                }
              }
              var updateQueue = finishedWork.updateQueue;
              if (updateQueue !== null) {
                {
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                    if (instance.props !== finishedWork.memoizedProps) {
                      error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                    }
                    if (instance.state !== finishedWork.memoizedState) {
                      error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentName(finishedWork.type) || "instance");
                    }
                  }
                }
                commitUpdateQueue(finishedWork, updateQueue, instance);
              }
              return;
            }
            case HostRoot: {
              var _updateQueue = finishedWork.updateQueue;
              if (_updateQueue !== null) {
                var _instance = null;
                if (finishedWork.child !== null) {
                  switch (finishedWork.child.tag) {
                    case HostComponent:
                      _instance = getPublicInstance(finishedWork.child.stateNode);
                      break;
                    case ClassComponent:
                      _instance = finishedWork.child.stateNode;
                      break;
                  }
                }
                commitUpdateQueue(finishedWork, _updateQueue, _instance);
              }
              return;
            }
            case HostComponent: {
              var _instance2 = finishedWork.stateNode;
              if (current2 === null && finishedWork.flags & Update) {
                var type = finishedWork.type;
                var props = finishedWork.memoizedProps;
                commitMount(_instance2, type, props);
              }
              return;
            }
            case HostText: {
              return;
            }
            case HostPortal: {
              return;
            }
            case Profiler: {
              {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                var effectDuration = finishedWork.stateNode.effectDuration;
                var commitTime2 = getCommitTime();
                if (typeof onRender === "function") {
                  {
                    onRender(finishedWork.memoizedProps.id, current2 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2, finishedRoot.memoizedInteractions);
                  }
                }
              }
              return;
            }
            case SuspenseComponent: {
              commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              return;
            }
            case SuspenseListComponent:
            case IncompleteClassComponent:
            case FundamentalComponent:
            case ScopeComponent:
            case OffscreenComponent:
            case LegacyHiddenComponent:
              return;
          }
          {
            {
              throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function hideOrUnhideAllChildren(finishedWork, isHidden) {
          {
            var node = finishedWork;
            while (true) {
              if (node.tag === HostComponent) {
                var instance = node.stateNode;
                if (isHidden) {
                  hideInstance(instance);
                } else {
                  unhideInstance(node.stateNode, node.memoizedProps);
                }
              } else if (node.tag === HostText) {
                var _instance3 = node.stateNode;
                if (isHidden) {
                  hideTextInstance(_instance3);
                } else {
                  unhideTextInstance(_instance3, node.memoizedProps);
                }
              } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === finishedWork) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (ref !== null) {
            var instance = finishedWork.stateNode;
            var instanceToUse;
            switch (finishedWork.tag) {
              case HostComponent:
                instanceToUse = getPublicInstance(instance);
                break;
              default:
                instanceToUse = instance;
            }
            if (typeof ref === "function") {
              ref(instanceToUse);
            } else {
              {
                if (!ref.hasOwnProperty("current")) {
                  error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentName(finishedWork.type));
                }
              }
              ref.current = instanceToUse;
            }
          }
        }
        function commitDetachRef(current2) {
          var currentRef = current2.ref;
          if (currentRef !== null) {
            if (typeof currentRef === "function") {
              currentRef(null);
            } else {
              currentRef.current = null;
            }
          }
        }
        function commitUnmount(finishedRoot, current2, renderPriorityLevel) {
          onCommitUnmount(current2);
          switch (current2.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent:
            case Block: {
              var updateQueue = current2.updateQueue;
              if (updateQueue !== null) {
                var lastEffect = updateQueue.lastEffect;
                if (lastEffect !== null) {
                  var firstEffect = lastEffect.next;
                  var effect = firstEffect;
                  do {
                    var _effect2 = effect, destroy = _effect2.destroy, tag = _effect2.tag;
                    if (destroy !== void 0) {
                      if ((tag & Passive$1) !== NoFlags$1) {
                        enqueuePendingPassiveHookEffectUnmount(current2, effect);
                      } else {
                        {
                          safelyCallDestroy(current2, destroy);
                        }
                      }
                    }
                    effect = effect.next;
                  } while (effect !== firstEffect);
                }
              }
              return;
            }
            case ClassComponent: {
              safelyDetachRef(current2);
              var instance = current2.stateNode;
              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(current2, instance);
              }
              return;
            }
            case HostComponent: {
              safelyDetachRef(current2);
              return;
            }
            case HostPortal: {
              {
                unmountHostComponents(finishedRoot, current2);
              }
              return;
            }
            case FundamentalComponent: {
              return;
            }
            case DehydratedFragment: {
              return;
            }
            case ScopeComponent: {
              return;
            }
          }
        }
        function commitNestedUnmounts(finishedRoot, root2, renderPriorityLevel) {
          var node = root2;
          while (true) {
            commitUnmount(finishedRoot, node);
            if (node.child !== null && node.tag !== HostPortal) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === root2) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === root2) {
                return;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        function detachFiberMutation(fiber) {
          fiber.alternate = null;
          fiber.child = null;
          fiber.dependencies = null;
          fiber.firstEffect = null;
          fiber.lastEffect = null;
          fiber.memoizedProps = null;
          fiber.memoizedState = null;
          fiber.pendingProps = null;
          fiber.return = null;
          fiber.updateQueue = null;
          {
            fiber._debugOwner = null;
          }
        }
        function getHostParentFiber(fiber) {
          var parent = fiber.return;
          while (parent !== null) {
            if (isHostParent(parent)) {
              return parent;
            }
            parent = parent.return;
          }
          {
            {
              throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function isHostParent(fiber) {
          return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
        }
        function getHostSibling(fiber) {
          var node = fiber;
          siblings:
            while (true) {
              while (node.sibling === null) {
                if (node.return === null || isHostParent(node.return)) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
              while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                if (node.flags & Placement) {
                  continue siblings;
                }
                if (node.child === null || node.tag === HostPortal) {
                  continue siblings;
                } else {
                  node.child.return = node;
                  node = node.child;
                }
              }
              if (!(node.flags & Placement)) {
                return node.stateNode;
              }
            }
        }
        function commitPlacement(finishedWork) {
          var parentFiber = getHostParentFiber(finishedWork);
          var parent;
          var isContainer;
          var parentStateNode = parentFiber.stateNode;
          switch (parentFiber.tag) {
            case HostComponent:
              parent = parentStateNode;
              isContainer = false;
              break;
            case HostRoot:
              parent = parentStateNode.containerInfo;
              isContainer = true;
              break;
            case HostPortal:
              parent = parentStateNode.containerInfo;
              isContainer = true;
              break;
            case FundamentalComponent:
            default: {
              {
                throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          if (parentFiber.flags & ContentReset) {
            resetTextContent(parent);
            parentFiber.flags &= ~ContentReset;
          }
          var before = getHostSibling(finishedWork);
          if (isContainer) {
            insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
          } else {
            insertOrAppendPlacementNode(finishedWork, before, parent);
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost || enableFundamentalAPI) {
            var stateNode = isHost ? node.stateNode : node.stateNode.instance;
            if (before) {
              insertInContainerBefore(parent, stateNode, before);
            } else {
              appendChildToContainer(parent, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNodeIntoContainer(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost || enableFundamentalAPI) {
            var stateNode = isHost ? node.stateNode : node.stateNode.instance;
            if (before) {
              insertBefore(parent, stateNode, before);
            } else {
              appendChild(parent, stateNode);
            }
          } else if (tag === HostPortal)
            ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNode(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNode(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        function unmountHostComponents(finishedRoot, current2, renderPriorityLevel) {
          var node = current2;
          var currentParentIsValid = false;
          var currentParent;
          var currentParentIsContainer;
          while (true) {
            if (!currentParentIsValid) {
              var parent = node.return;
              findParent:
                while (true) {
                  if (!(parent !== null)) {
                    {
                      throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
                    }
                  }
                  var parentStateNode = parent.stateNode;
                  switch (parent.tag) {
                    case HostComponent:
                      currentParent = parentStateNode;
                      currentParentIsContainer = false;
                      break findParent;
                    case HostRoot:
                      currentParent = parentStateNode.containerInfo;
                      currentParentIsContainer = true;
                      break findParent;
                    case HostPortal:
                      currentParent = parentStateNode.containerInfo;
                      currentParentIsContainer = true;
                      break findParent;
                  }
                  parent = parent.return;
                }
              currentParentIsValid = true;
            }
            if (node.tag === HostComponent || node.tag === HostText) {
              commitNestedUnmounts(finishedRoot, node);
              if (currentParentIsContainer) {
                removeChildFromContainer(currentParent, node.stateNode);
              } else {
                removeChild(currentParent, node.stateNode);
              }
            } else if (node.tag === HostPortal) {
              if (node.child !== null) {
                currentParent = node.stateNode.containerInfo;
                currentParentIsContainer = true;
                node.child.return = node;
                node = node.child;
                continue;
              }
            } else {
              commitUnmount(finishedRoot, node);
              if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
            }
            if (node === current2) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === current2) {
                return;
              }
              node = node.return;
              if (node.tag === HostPortal) {
                currentParentIsValid = false;
              }
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        function commitDeletion(finishedRoot, current2, renderPriorityLevel) {
          {
            unmountHostComponents(finishedRoot, current2);
          }
          var alternate = current2.alternate;
          detachFiberMutation(current2);
          if (alternate !== null) {
            detachFiberMutation(alternate);
          }
        }
        function commitWork(current2, finishedWork) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent:
            case Block: {
              {
                commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
              }
              return;
            }
            case ClassComponent: {
              return;
            }
            case HostComponent: {
              var instance = finishedWork.stateNode;
              if (instance != null) {
                var newProps = finishedWork.memoizedProps;
                var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                var type = finishedWork.type;
                var updatePayload = finishedWork.updateQueue;
                finishedWork.updateQueue = null;
                if (updatePayload !== null) {
                  commitUpdate(instance, updatePayload, type, oldProps, newProps);
                }
              }
              return;
            }
            case HostText: {
              if (!(finishedWork.stateNode !== null)) {
                {
                  throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              var textInstance = finishedWork.stateNode;
              var newText = finishedWork.memoizedProps;
              var oldText = current2 !== null ? current2.memoizedProps : newText;
              commitTextUpdate(textInstance, oldText, newText);
              return;
            }
            case HostRoot: {
              {
                var _root = finishedWork.stateNode;
                if (_root.hydrate) {
                  _root.hydrate = false;
                  commitHydratedContainer(_root.containerInfo);
                }
              }
              return;
            }
            case Profiler: {
              return;
            }
            case SuspenseComponent: {
              commitSuspenseComponent(finishedWork);
              attachSuspenseRetryListeners(finishedWork);
              return;
            }
            case SuspenseListComponent: {
              attachSuspenseRetryListeners(finishedWork);
              return;
            }
            case IncompleteClassComponent: {
              return;
            }
            case FundamentalComponent: {
              break;
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              var newState = finishedWork.memoizedState;
              var isHidden = newState !== null;
              hideOrUnhideAllChildren(finishedWork, isHidden);
              return;
            }
          }
          {
            {
              throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function commitSuspenseComponent(finishedWork) {
          var newState = finishedWork.memoizedState;
          if (newState !== null) {
            markCommitTimeOfFallback();
            {
              var primaryChildParent = finishedWork.child;
              hideOrUnhideAllChildren(primaryChildParent, true);
            }
          }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          var newState = finishedWork.memoizedState;
          if (newState === null) {
            var current2 = finishedWork.alternate;
            if (current2 !== null) {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var suspenseInstance = prevState.dehydrated;
                if (suspenseInstance !== null) {
                  commitHydratedSuspenseInstance(suspenseInstance);
                }
              }
            }
          }
        }
        function attachSuspenseRetryListeners(finishedWork) {
          var wakeables = finishedWork.updateQueue;
          if (wakeables !== null) {
            finishedWork.updateQueue = null;
            var retryCache = finishedWork.stateNode;
            if (retryCache === null) {
              retryCache = finishedWork.stateNode = new PossiblyWeakSet();
            }
            wakeables.forEach(function(wakeable) {
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              if (!retryCache.has(wakeable)) {
                {
                  if (wakeable.__reactDoNotTraceInteractions !== true) {
                    retry = tracing.unstable_wrap(retry);
                  }
                }
                retryCache.add(wakeable);
                wakeable.then(retry, retry);
              }
            });
          }
        }
        function isSuspenseBoundaryBeingHidden(current2, finishedWork) {
          if (current2 !== null) {
            var oldState = current2.memoizedState;
            if (oldState === null || oldState.dehydrated !== null) {
              var newState = finishedWork.memoizedState;
              return newState !== null && newState.dehydrated === null;
            }
          }
          return false;
        }
        function commitResetTextContent(current2) {
          resetTextContent(current2.stateNode);
        }
        var COMPONENT_TYPE = 0;
        var HAS_PSEUDO_CLASS_TYPE = 1;
        var ROLE_TYPE = 2;
        var TEST_NAME_TYPE = 3;
        var TEXT_TYPE = 4;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor$1 = Symbol.for;
          COMPONENT_TYPE = symbolFor$1("selector.component");
          HAS_PSEUDO_CLASS_TYPE = symbolFor$1("selector.has_pseudo_class");
          ROLE_TYPE = symbolFor$1("selector.role");
          TEST_NAME_TYPE = symbolFor$1("selector.test_id");
          TEXT_TYPE = symbolFor$1("selector.text");
        }
        var commitHooks = [];
        function onCommitRoot$1() {
          {
            commitHooks.forEach(function(commitHook) {
              return commitHook();
            });
          }
        }
        var ceil = Math.ceil;
        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
        var NoContext = 0;
        var BatchedContext = 1;
        var EventContext = 2;
        var DiscreteEventContext = 4;
        var LegacyUnbatchedContext = 8;
        var RenderContext = 16;
        var CommitContext = 32;
        var RetryAfterError = 64;
        var RootIncomplete = 0;
        var RootFatalErrored = 1;
        var RootErrored = 2;
        var RootSuspended = 3;
        var RootSuspendedWithDelay = 4;
        var RootCompleted = 5;
        var executionContext = NoContext;
        var workInProgressRoot = null;
        var workInProgress = null;
        var workInProgressRootRenderLanes = NoLanes;
        var subtreeRenderLanes = NoLanes;
        var subtreeRenderLanesCursor = createCursor(NoLanes);
        var workInProgressRootExitStatus = RootIncomplete;
        var workInProgressRootFatalError = null;
        var workInProgressRootIncludedLanes = NoLanes;
        var workInProgressRootSkippedLanes = NoLanes;
        var workInProgressRootUpdatedLanes = NoLanes;
        var workInProgressRootPingedLanes = NoLanes;
        var mostRecentlyUpdatedRoot = null;
        var globalMostRecentFallbackTime = 0;
        var FALLBACK_THROTTLE_MS = 500;
        var workInProgressRootRenderTargetTime = Infinity;
        var RENDER_TIMEOUT_MS = 500;
        function resetRenderTimer() {
          workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
        }
        function getRenderTargetTime() {
          return workInProgressRootRenderTargetTime;
        }
        var nextEffect = null;
        var hasUncaughtError = false;
        var firstUncaughtError = null;
        var legacyErrorBoundariesThatAlreadyFailed = null;
        var rootDoesHavePassiveEffects = false;
        var rootWithPendingPassiveEffects = null;
        var pendingPassiveEffectsRenderPriority = NoPriority$1;
        var pendingPassiveEffectsLanes = NoLanes;
        var pendingPassiveHookEffectsMount = [];
        var pendingPassiveHookEffectsUnmount = [];
        var rootsWithPendingDiscreteUpdates = null;
        var NESTED_UPDATE_LIMIT = 50;
        var nestedUpdateCount = 0;
        var rootWithNestedUpdates = null;
        var NESTED_PASSIVE_UPDATE_LIMIT = 50;
        var nestedPassiveUpdateCount = 0;
        var spawnedWorkDuringRender = null;
        var currentEventTime = NoTimestamp;
        var currentEventWipLanes = NoLanes;
        var currentEventPendingLanes = NoLanes;
        var isFlushingPassiveEffects = false;
        var focusedInstanceHandle = null;
        var shouldFireAfterActiveInstanceBlur = false;
        function getWorkInProgressRoot() {
          return workInProgressRoot;
        }
        function requestEventTime() {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            return now();
          }
          if (currentEventTime !== NoTimestamp) {
            return currentEventTime;
          }
          currentEventTime = now();
          return currentEventTime;
        }
        function requestUpdateLane(fiber) {
          var mode = fiber.mode;
          if ((mode & BlockingMode) === NoMode) {
            return SyncLane;
          } else if ((mode & ConcurrentMode) === NoMode) {
            return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
          }
          if (currentEventWipLanes === NoLanes) {
            currentEventWipLanes = workInProgressRootIncludedLanes;
          }
          var isTransition = requestCurrentTransition() !== NoTransition;
          if (isTransition) {
            if (currentEventPendingLanes !== NoLanes) {
              currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes;
            }
            return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
          }
          var schedulerPriority = getCurrentPriorityLevel();
          var lane;
          if ((executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$2) {
            lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
          } else {
            var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);
            lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
          }
          return lane;
        }
        function requestRetryLane(fiber) {
          var mode = fiber.mode;
          if ((mode & BlockingMode) === NoMode) {
            return SyncLane;
          } else if ((mode & ConcurrentMode) === NoMode) {
            return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
          }
          if (currentEventWipLanes === NoLanes) {
            currentEventWipLanes = workInProgressRootIncludedLanes;
          }
          return findRetryLane(currentEventWipLanes);
        }
        function scheduleUpdateOnFiber(fiber, lane, eventTime) {
          checkForNestedUpdates();
          warnAboutRenderPhaseUpdatesInDEV(fiber);
          var root2 = markUpdateLaneFromFiberToRoot(fiber, lane);
          if (root2 === null) {
            warnAboutUpdateOnUnmountedFiberInDEV(fiber);
            return null;
          }
          markRootUpdated(root2, lane, eventTime);
          if (root2 === workInProgressRoot) {
            {
              workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);
            }
            if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
              markRootSuspended$1(root2, workInProgressRootRenderLanes);
            }
          }
          var priorityLevel = getCurrentPriorityLevel();
          if (lane === SyncLane) {
            if ((executionContext & LegacyUnbatchedContext) !== NoContext && (executionContext & (RenderContext | CommitContext)) === NoContext) {
              schedulePendingInteractions(root2, lane);
              performSyncWorkOnRoot(root2);
            } else {
              ensureRootIsScheduled(root2, eventTime);
              schedulePendingInteractions(root2, lane);
              if (executionContext === NoContext) {
                resetRenderTimer();
                flushSyncCallbackQueue();
              }
            }
          } else {
            if ((executionContext & DiscreteEventContext) !== NoContext && (priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1)) {
              if (rootsWithPendingDiscreteUpdates === null) {
                rootsWithPendingDiscreteUpdates = new Set([root2]);
              } else {
                rootsWithPendingDiscreteUpdates.add(root2);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
            schedulePendingInteractions(root2, lane);
          }
          mostRecentlyUpdatedRoot = root2;
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
          var alternate = sourceFiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, lane);
          }
          {
            if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
              warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
            }
          }
          var node = sourceFiber;
          var parent = sourceFiber.return;
          while (parent !== null) {
            parent.childLanes = mergeLanes(parent.childLanes, lane);
            alternate = parent.alternate;
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, lane);
            } else {
              {
                if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                  warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                }
              }
            }
            node = parent;
            parent = parent.return;
          }
          if (node.tag === HostRoot) {
            var root2 = node.stateNode;
            return root2;
          } else {
            return null;
          }
        }
        function ensureRootIsScheduled(root2, currentTime) {
          var existingCallbackNode = root2.callbackNode;
          markStarvedLanesAsExpired(root2, currentTime);
          var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          var newCallbackPriority = returnNextLanesPriority();
          if (nextLanes === NoLanes) {
            if (existingCallbackNode !== null) {
              cancelCallback(existingCallbackNode);
              root2.callbackNode = null;
              root2.callbackPriority = NoLanePriority;
            }
            return;
          }
          if (existingCallbackNode !== null) {
            var existingCallbackPriority = root2.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority) {
              return;
            }
            cancelCallback(existingCallbackNode);
          }
          var newCallbackNode;
          if (newCallbackPriority === SyncLanePriority) {
            newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
          } else if (newCallbackPriority === SyncBatchedLanePriority) {
            newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root2));
          } else {
            var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
            newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
          }
          root2.callbackPriority = newCallbackPriority;
          root2.callbackNode = newCallbackNode;
        }
        function performConcurrentWorkOnRoot(root2) {
          currentEventTime = NoTimestamp;
          currentEventWipLanes = NoLanes;
          currentEventPendingLanes = NoLanes;
          if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
            {
              throw Error("Should not already be working.");
            }
          }
          var originalCallbackNode = root2.callbackNode;
          var didFlushPassiveEffects = flushPassiveEffects();
          if (didFlushPassiveEffects) {
            if (root2.callbackNode !== originalCallbackNode) {
              return null;
            }
          }
          var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (lanes === NoLanes) {
            return null;
          }
          var exitStatus = renderRootConcurrent(root2, lanes);
          if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
            prepareFreshStack(root2, NoLanes);
          } else if (exitStatus !== RootIncomplete) {
            if (exitStatus === RootErrored) {
              executionContext |= RetryAfterError;
              if (root2.hydrate) {
                root2.hydrate = false;
                clearContainer(root2.containerInfo);
              }
              lanes = getLanesToRetrySynchronouslyOnError(root2);
              if (lanes !== NoLanes) {
                exitStatus = renderRootSync(root2, lanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now());
              throw fatalError;
            }
            var finishedWork = root2.current.alternate;
            root2.finishedWork = finishedWork;
            root2.finishedLanes = lanes;
            finishConcurrentRender(root2, exitStatus, lanes);
          }
          ensureRootIsScheduled(root2, now());
          if (root2.callbackNode === originalCallbackNode) {
            return performConcurrentWorkOnRoot.bind(null, root2);
          }
          return null;
        }
        function finishConcurrentRender(root2, exitStatus, lanes) {
          switch (exitStatus) {
            case RootIncomplete:
            case RootFatalErrored: {
              {
                {
                  throw Error("Root did not complete. This is a bug in React.");
                }
              }
            }
            case RootErrored: {
              commitRoot(root2);
              break;
            }
            case RootSuspended: {
              markRootSuspended$1(root2, lanes);
              if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
                var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                if (msUntilTimeout > 10) {
                  var nextLanes = getNextLanes(root2, NoLanes);
                  if (nextLanes !== NoLanes) {
                    break;
                  }
                  var suspendedLanes = root2.suspendedLanes;
                  if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                    var eventTime = requestEventTime();
                    markRootPinged(root2, suspendedLanes);
                    break;
                  }
                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2), msUntilTimeout);
                  break;
                }
              }
              commitRoot(root2);
              break;
            }
            case RootSuspendedWithDelay: {
              markRootSuspended$1(root2, lanes);
              if (includesOnlyTransitions(lanes)) {
                break;
              }
              if (!shouldForceFlushFallbacksInDEV()) {
                var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                var eventTimeMs = mostRecentEventTime;
                var timeElapsedMs = now() - eventTimeMs;
                var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                if (_msUntilTimeout > 10) {
                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2), _msUntilTimeout);
                  break;
                }
              }
              commitRoot(root2);
              break;
            }
            case RootCompleted: {
              commitRoot(root2);
              break;
            }
            default: {
              {
                {
                  throw Error("Unknown root exit status.");
                }
              }
            }
          }
        }
        function markRootSuspended$1(root2, suspendedLanes) {
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
          markRootSuspended(root2, suspendedLanes);
        }
        function performSyncWorkOnRoot(root2) {
          if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
            {
              throw Error("Should not already be working.");
            }
          }
          flushPassiveEffects();
          var lanes;
          var exitStatus;
          if (root2 === workInProgressRoot && includesSomeLane(root2.expiredLanes, workInProgressRootRenderLanes)) {
            lanes = workInProgressRootRenderLanes;
            exitStatus = renderRootSync(root2, lanes);
            if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
              lanes = getNextLanes(root2, lanes);
              exitStatus = renderRootSync(root2, lanes);
            }
          } else {
            lanes = getNextLanes(root2, NoLanes);
            exitStatus = renderRootSync(root2, lanes);
          }
          if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
            executionContext |= RetryAfterError;
            if (root2.hydrate) {
              root2.hydrate = false;
              clearContainer(root2.containerInfo);
            }
            lanes = getLanesToRetrySynchronouslyOnError(root2);
            if (lanes !== NoLanes) {
              exitStatus = renderRootSync(root2, lanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root2, NoLanes);
            markRootSuspended$1(root2, lanes);
            ensureRootIsScheduled(root2, now());
            throw fatalError;
          }
          var finishedWork = root2.current.alternate;
          root2.finishedWork = finishedWork;
          root2.finishedLanes = lanes;
          commitRoot(root2);
          ensureRootIsScheduled(root2, now());
          return null;
        }
        function flushDiscreteUpdates() {
          if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                error("unstable_flushDiscreteUpdates: Cannot flush updates when React is already rendering.");
              }
            }
            return;
          }
          flushPendingDiscreteUpdates();
          flushPassiveEffects();
        }
        function flushPendingDiscreteUpdates() {
          if (rootsWithPendingDiscreteUpdates !== null) {
            var roots = rootsWithPendingDiscreteUpdates;
            rootsWithPendingDiscreteUpdates = null;
            roots.forEach(function(root2) {
              markDiscreteUpdatesExpired(root2);
              ensureRootIsScheduled(root2, now());
            });
          }
          flushSyncCallbackQueue();
        }
        function batchedUpdates$1(fn, a) {
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          try {
            return fn(a);
          } finally {
            executionContext = prevExecutionContext;
            if (executionContext === NoContext) {
              resetRenderTimer();
              flushSyncCallbackQueue();
            }
          }
        }
        function batchedEventUpdates$1(fn, a) {
          var prevExecutionContext = executionContext;
          executionContext |= EventContext;
          try {
            return fn(a);
          } finally {
            executionContext = prevExecutionContext;
            if (executionContext === NoContext) {
              resetRenderTimer();
              flushSyncCallbackQueue();
            }
          }
        }
        function discreteUpdates$1(fn, a, b, c, d) {
          var prevExecutionContext = executionContext;
          executionContext |= DiscreteEventContext;
          {
            try {
              return runWithPriority$1(UserBlockingPriority$2, fn.bind(null, a, b, c, d));
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext) {
                resetRenderTimer();
                flushSyncCallbackQueue();
              }
            }
          }
        }
        function unbatchedUpdates(fn, a) {
          var prevExecutionContext = executionContext;
          executionContext &= ~BatchedContext;
          executionContext |= LegacyUnbatchedContext;
          try {
            return fn(a);
          } finally {
            executionContext = prevExecutionContext;
            if (executionContext === NoContext) {
              resetRenderTimer();
              flushSyncCallbackQueue();
            }
          }
        }
        function flushSync(fn, a) {
          var prevExecutionContext = executionContext;
          if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
            {
              error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
            }
            return fn(a);
          }
          executionContext |= BatchedContext;
          {
            try {
              if (fn) {
                return runWithPriority$1(ImmediatePriority$1, fn.bind(null, a));
              } else {
                return void 0;
              }
            } finally {
              executionContext = prevExecutionContext;
              flushSyncCallbackQueue();
            }
          }
        }
        function pushRenderLanes(fiber, lanes) {
          push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
          subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
          workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
        }
        function popRenderLanes(fiber) {
          subtreeRenderLanes = subtreeRenderLanesCursor.current;
          pop(subtreeRenderLanesCursor, fiber);
        }
        function prepareFreshStack(root2, lanes) {
          root2.finishedWork = null;
          root2.finishedLanes = NoLanes;
          var timeoutHandle = root2.timeoutHandle;
          if (timeoutHandle !== noTimeout) {
            root2.timeoutHandle = noTimeout;
            cancelTimeout(timeoutHandle);
          }
          if (workInProgress !== null) {
            var interruptedWork = workInProgress.return;
            while (interruptedWork !== null) {
              unwindInterruptedWork(interruptedWork);
              interruptedWork = interruptedWork.return;
            }
          }
          workInProgressRoot = root2;
          workInProgress = createWorkInProgress(root2.current, null);
          workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
          workInProgressRootExitStatus = RootIncomplete;
          workInProgressRootFatalError = null;
          workInProgressRootSkippedLanes = NoLanes;
          workInProgressRootUpdatedLanes = NoLanes;
          workInProgressRootPingedLanes = NoLanes;
          {
            spawnedWorkDuringRender = null;
          }
          {
            ReactStrictModeWarnings.discardPendingWarnings();
          }
        }
        function handleError(root2, thrownValue) {
          do {
            var erroredWork = workInProgress;
            try {
              resetContextDependencies();
              resetHooksAfterThrow();
              resetCurrentFiber();
              ReactCurrentOwner$2.current = null;
              if (erroredWork === null || erroredWork.return === null) {
                workInProgressRootExitStatus = RootFatalErrored;
                workInProgressRootFatalError = thrownValue;
                workInProgress = null;
                return;
              }
              if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
              }
              throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
              completeUnitOfWork(erroredWork);
            } catch (yetAnotherThrownValue) {
              thrownValue = yetAnotherThrownValue;
              if (workInProgress === erroredWork && erroredWork !== null) {
                erroredWork = erroredWork.return;
                workInProgress = erroredWork;
              } else {
                erroredWork = workInProgress;
              }
              continue;
            }
            return;
          } while (true);
        }
        function pushDispatcher() {
          var prevDispatcher = ReactCurrentDispatcher$2.current;
          ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
          if (prevDispatcher === null) {
            return ContextOnlyDispatcher;
          } else {
            return prevDispatcher;
          }
        }
        function popDispatcher(prevDispatcher) {
          ReactCurrentDispatcher$2.current = prevDispatcher;
        }
        function pushInteractions(root2) {
          {
            var prevInteractions = tracing.__interactionsRef.current;
            tracing.__interactionsRef.current = root2.memoizedInteractions;
            return prevInteractions;
          }
        }
        function popInteractions(prevInteractions) {
          {
            tracing.__interactionsRef.current = prevInteractions;
          }
        }
        function markCommitTimeOfFallback() {
          globalMostRecentFallbackTime = now();
        }
        function markSkippedUpdateLanes(lane) {
          workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
        }
        function renderDidSuspend() {
          if (workInProgressRootExitStatus === RootIncomplete) {
            workInProgressRootExitStatus = RootSuspended;
          }
        }
        function renderDidSuspendDelayIfPossible() {
          if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {
            workInProgressRootExitStatus = RootSuspendedWithDelay;
          }
          if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes))) {
            markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
          }
        }
        function renderDidError() {
          if (workInProgressRootExitStatus !== RootCompleted) {
            workInProgressRootExitStatus = RootErrored;
          }
        }
        function renderHasNotSuspendedYet() {
          return workInProgressRootExitStatus === RootIncomplete;
        }
        function renderRootSync(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            prepareFreshStack(root2, lanes);
            startWorkOnPendingInteractions(root2, lanes);
          }
          var prevInteractions = pushInteractions(root2);
          do {
            try {
              workLoopSync();
              break;
            } catch (thrownValue) {
              handleError(root2, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          {
            popInteractions(prevInteractions);
          }
          executionContext = prevExecutionContext;
          popDispatcher(prevDispatcher);
          if (workInProgress !== null) {
            {
              {
                throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
        function workLoopSync() {
          while (workInProgress !== null) {
            performUnitOfWork(workInProgress);
          }
        }
        function renderRootConcurrent(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            resetRenderTimer();
            prepareFreshStack(root2, lanes);
            startWorkOnPendingInteractions(root2, lanes);
          }
          var prevInteractions = pushInteractions(root2);
          do {
            try {
              workLoopConcurrent();
              break;
            } catch (thrownValue) {
              handleError(root2, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          {
            popInteractions(prevInteractions);
          }
          popDispatcher(prevDispatcher);
          executionContext = prevExecutionContext;
          if (workInProgress !== null) {
            return RootIncomplete;
          } else {
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
        }
        function workLoopConcurrent() {
          while (workInProgress !== null && !shouldYield()) {
            performUnitOfWork(workInProgress);
          }
        }
        function performUnitOfWork(unitOfWork) {
          var current2 = unitOfWork.alternate;
          setCurrentFiber(unitOfWork);
          var next;
          if ((unitOfWork.mode & ProfileMode) !== NoMode) {
            startProfilerTimer(unitOfWork);
            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
          } else {
            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
          }
          resetCurrentFiber();
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          if (next === null) {
            completeUnitOfWork(unitOfWork);
          } else {
            workInProgress = next;
          }
          ReactCurrentOwner$2.current = null;
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            var current2 = completedWork.alternate;
            var returnFiber = completedWork.return;
            if ((completedWork.flags & Incomplete) === NoFlags) {
              setCurrentFiber(completedWork);
              var next = void 0;
              if ((completedWork.mode & ProfileMode) === NoMode) {
                next = completeWork(current2, completedWork, subtreeRenderLanes);
              } else {
                startProfilerTimer(completedWork);
                next = completeWork(current2, completedWork, subtreeRenderLanes);
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              }
              resetCurrentFiber();
              if (next !== null) {
                workInProgress = next;
                return;
              }
              resetChildLanes(completedWork);
              if (returnFiber !== null && (returnFiber.flags & Incomplete) === NoFlags) {
                if (returnFiber.firstEffect === null) {
                  returnFiber.firstEffect = completedWork.firstEffect;
                }
                if (completedWork.lastEffect !== null) {
                  if (returnFiber.lastEffect !== null) {
                    returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
                  }
                  returnFiber.lastEffect = completedWork.lastEffect;
                }
                var flags = completedWork.flags;
                if (flags > PerformedWork) {
                  if (returnFiber.lastEffect !== null) {
                    returnFiber.lastEffect.nextEffect = completedWork;
                  } else {
                    returnFiber.firstEffect = completedWork;
                  }
                  returnFiber.lastEffect = completedWork;
                }
              }
            } else {
              var _next = unwindWork(completedWork);
              if (_next !== null) {
                _next.flags &= HostEffectMask;
                workInProgress = _next;
                return;
              }
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                var actualDuration = completedWork.actualDuration;
                var child = completedWork.child;
                while (child !== null) {
                  actualDuration += child.actualDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
              }
              if (returnFiber !== null) {
                returnFiber.firstEffect = returnFiber.lastEffect = null;
                returnFiber.flags |= Incomplete;
              }
            }
            var siblingFiber = completedWork.sibling;
            if (siblingFiber !== null) {
              workInProgress = siblingFiber;
              return;
            }
            completedWork = returnFiber;
            workInProgress = completedWork;
          } while (completedWork !== null);
          if (workInProgressRootExitStatus === RootIncomplete) {
            workInProgressRootExitStatus = RootCompleted;
          }
        }
        function resetChildLanes(completedWork) {
          if ((completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes) {
            return;
          }
          var newChildLanes = NoLanes;
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            var actualDuration = completedWork.actualDuration;
            var treeBaseDuration = completedWork.selfBaseDuration;
            var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;
            var child = completedWork.child;
            while (child !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
              if (shouldBubbleActualDurations) {
                actualDuration += child.actualDuration;
              }
              treeBaseDuration += child.treeBaseDuration;
              child = child.sibling;
            }
            var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;
            if (isTimedOutSuspense) {
              var primaryChildFragment = completedWork.child;
              if (primaryChildFragment !== null) {
                treeBaseDuration -= primaryChildFragment.treeBaseDuration;
              }
            }
            completedWork.actualDuration = actualDuration;
            completedWork.treeBaseDuration = treeBaseDuration;
          } else {
            var _child = completedWork.child;
            while (_child !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
              _child = _child.sibling;
            }
          }
          completedWork.childLanes = newChildLanes;
        }
        function commitRoot(root2) {
          var renderPriorityLevel = getCurrentPriorityLevel();
          runWithPriority$1(ImmediatePriority$1, commitRootImpl.bind(null, root2, renderPriorityLevel));
          return null;
        }
        function commitRootImpl(root2, renderPriorityLevel) {
          do {
            flushPassiveEffects();
          } while (rootWithPendingPassiveEffects !== null);
          flushRenderPhaseStrictModeWarningsInDEV();
          if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
            {
              throw Error("Should not already be working.");
            }
          }
          var finishedWork = root2.finishedWork;
          var lanes = root2.finishedLanes;
          if (finishedWork === null) {
            return null;
          }
          root2.finishedWork = null;
          root2.finishedLanes = NoLanes;
          if (!(finishedWork !== root2.current)) {
            {
              throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          root2.callbackNode = null;
          var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
          markRootFinished(root2, remainingLanes);
          if (rootsWithPendingDiscreteUpdates !== null) {
            if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root2)) {
              rootsWithPendingDiscreteUpdates.delete(root2);
            }
          }
          if (root2 === workInProgressRoot) {
            workInProgressRoot = null;
            workInProgress = null;
            workInProgressRootRenderLanes = NoLanes;
          }
          var firstEffect;
          if (finishedWork.flags > PerformedWork) {
            if (finishedWork.lastEffect !== null) {
              finishedWork.lastEffect.nextEffect = finishedWork;
              firstEffect = finishedWork.firstEffect;
            } else {
              firstEffect = finishedWork;
            }
          } else {
            firstEffect = finishedWork.firstEffect;
          }
          if (firstEffect !== null) {
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            var prevInteractions = pushInteractions(root2);
            ReactCurrentOwner$2.current = null;
            focusedInstanceHandle = prepareForCommit(root2.containerInfo);
            shouldFireAfterActiveInstanceBlur = false;
            nextEffect = firstEffect;
            do {
              {
                invokeGuardedCallback(null, commitBeforeMutationEffects, null);
                if (hasCaughtError()) {
                  if (!(nextEffect !== null)) {
                    {
                      throw Error("Should be working on an effect.");
                    }
                  }
                  var error2 = clearCaughtError();
                  captureCommitPhaseError(nextEffect, error2);
                  nextEffect = nextEffect.nextEffect;
                }
              }
            } while (nextEffect !== null);
            focusedInstanceHandle = null;
            {
              recordCommitTime();
            }
            nextEffect = firstEffect;
            do {
              {
                invokeGuardedCallback(null, commitMutationEffects, null, root2, renderPriorityLevel);
                if (hasCaughtError()) {
                  if (!(nextEffect !== null)) {
                    {
                      throw Error("Should be working on an effect.");
                    }
                  }
                  var _error = clearCaughtError();
                  captureCommitPhaseError(nextEffect, _error);
                  nextEffect = nextEffect.nextEffect;
                }
              }
            } while (nextEffect !== null);
            resetAfterCommit(root2.containerInfo);
            root2.current = finishedWork;
            nextEffect = firstEffect;
            do {
              {
                invokeGuardedCallback(null, commitLayoutEffects, null, root2, lanes);
                if (hasCaughtError()) {
                  if (!(nextEffect !== null)) {
                    {
                      throw Error("Should be working on an effect.");
                    }
                  }
                  var _error2 = clearCaughtError();
                  captureCommitPhaseError(nextEffect, _error2);
                  nextEffect = nextEffect.nextEffect;
                }
              }
            } while (nextEffect !== null);
            nextEffect = null;
            requestPaint();
            {
              popInteractions(prevInteractions);
            }
            executionContext = prevExecutionContext;
          } else {
            root2.current = finishedWork;
            {
              recordCommitTime();
            }
          }
          var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
          if (rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = false;
            rootWithPendingPassiveEffects = root2;
            pendingPassiveEffectsLanes = lanes;
            pendingPassiveEffectsRenderPriority = renderPriorityLevel;
          } else {
            nextEffect = firstEffect;
            while (nextEffect !== null) {
              var nextNextEffect = nextEffect.nextEffect;
              nextEffect.nextEffect = null;
              if (nextEffect.flags & Deletion) {
                detachFiberAfterEffects(nextEffect);
              }
              nextEffect = nextNextEffect;
            }
          }
          remainingLanes = root2.pendingLanes;
          if (remainingLanes !== NoLanes) {
            {
              if (spawnedWorkDuringRender !== null) {
                var expirationTimes = spawnedWorkDuringRender;
                spawnedWorkDuringRender = null;
                for (var i = 0; i < expirationTimes.length; i++) {
                  scheduleInteractions(root2, expirationTimes[i], root2.memoizedInteractions);
                }
              }
              schedulePendingInteractions(root2, remainingLanes);
            }
          } else {
            legacyErrorBoundariesThatAlreadyFailed = null;
          }
          {
            if (!rootDidHavePassiveEffects) {
              finishPendingInteractions(root2, lanes);
            }
          }
          if (remainingLanes === SyncLane) {
            if (root2 === rootWithNestedUpdates) {
              nestedUpdateCount++;
            } else {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = root2;
            }
          } else {
            nestedUpdateCount = 0;
          }
          onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
          {
            onCommitRoot$1();
          }
          ensureRootIsScheduled(root2, now());
          if (hasUncaughtError) {
            hasUncaughtError = false;
            var _error3 = firstUncaughtError;
            firstUncaughtError = null;
            throw _error3;
          }
          if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
            return null;
          }
          flushSyncCallbackQueue();
          return null;
        }
        function commitBeforeMutationEffects() {
          while (nextEffect !== null) {
            var current2 = nextEffect.alternate;
            if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
              if ((nextEffect.flags & Deletion) !== NoFlags) {
                if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
                  shouldFireAfterActiveInstanceBlur = true;
                }
              } else {
                if (nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current2, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle)) {
                  shouldFireAfterActiveInstanceBlur = true;
                }
              }
            }
            var flags = nextEffect.flags;
            if ((flags & Snapshot) !== NoFlags) {
              setCurrentFiber(nextEffect);
              commitBeforeMutationLifeCycles(current2, nextEffect);
              resetCurrentFiber();
            }
            if ((flags & Passive) !== NoFlags) {
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                scheduleCallback(NormalPriority$1, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
            nextEffect = nextEffect.nextEffect;
          }
        }
        function commitMutationEffects(root2, renderPriorityLevel) {
          while (nextEffect !== null) {
            setCurrentFiber(nextEffect);
            var flags = nextEffect.flags;
            if (flags & ContentReset) {
              commitResetTextContent(nextEffect);
            }
            if (flags & Ref2) {
              var current2 = nextEffect.alternate;
              if (current2 !== null) {
                commitDetachRef(current2);
              }
            }
            var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);
            switch (primaryFlags) {
              case Placement: {
                commitPlacement(nextEffect);
                nextEffect.flags &= ~Placement;
                break;
              }
              case PlacementAndUpdate: {
                commitPlacement(nextEffect);
                nextEffect.flags &= ~Placement;
                var _current = nextEffect.alternate;
                commitWork(_current, nextEffect);
                break;
              }
              case Hydrating: {
                nextEffect.flags &= ~Hydrating;
                break;
              }
              case HydratingAndUpdate: {
                nextEffect.flags &= ~Hydrating;
                var _current2 = nextEffect.alternate;
                commitWork(_current2, nextEffect);
                break;
              }
              case Update: {
                var _current3 = nextEffect.alternate;
                commitWork(_current3, nextEffect);
                break;
              }
              case Deletion: {
                commitDeletion(root2, nextEffect);
                break;
              }
            }
            resetCurrentFiber();
            nextEffect = nextEffect.nextEffect;
          }
        }
        function commitLayoutEffects(root2, committedLanes) {
          while (nextEffect !== null) {
            setCurrentFiber(nextEffect);
            var flags = nextEffect.flags;
            if (flags & (Update | Callback)) {
              var current2 = nextEffect.alternate;
              commitLifeCycles(root2, current2, nextEffect);
            }
            {
              if (flags & Ref2) {
                commitAttachRef(nextEffect);
              }
            }
            resetCurrentFiber();
            nextEffect = nextEffect.nextEffect;
          }
        }
        function flushPassiveEffects() {
          if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
            var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;
            pendingPassiveEffectsRenderPriority = NoPriority$1;
            {
              return runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);
            }
          }
          return false;
        }
        function enqueuePendingPassiveHookEffectMount(fiber, effect) {
          pendingPassiveHookEffectsMount.push(effect, fiber);
          if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            scheduleCallback(NormalPriority$1, function() {
              flushPassiveEffects();
              return null;
            });
          }
        }
        function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
          pendingPassiveHookEffectsUnmount.push(effect, fiber);
          {
            fiber.flags |= PassiveUnmountPendingDev;
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.flags |= PassiveUnmountPendingDev;
            }
          }
          if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            scheduleCallback(NormalPriority$1, function() {
              flushPassiveEffects();
              return null;
            });
          }
        }
        function invokePassiveEffectCreate(effect) {
          var create = effect.create;
          effect.destroy = create();
        }
        function flushPassiveEffectsImpl() {
          if (rootWithPendingPassiveEffects === null) {
            return false;
          }
          var root2 = rootWithPendingPassiveEffects;
          var lanes = pendingPassiveEffectsLanes;
          rootWithPendingPassiveEffects = null;
          pendingPassiveEffectsLanes = NoLanes;
          if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
            {
              throw Error("Cannot flush passive effects while already rendering.");
            }
          }
          {
            isFlushingPassiveEffects = true;
          }
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          var prevInteractions = pushInteractions(root2);
          var unmountEffects = pendingPassiveHookEffectsUnmount;
          pendingPassiveHookEffectsUnmount = [];
          for (var i = 0; i < unmountEffects.length; i += 2) {
            var _effect = unmountEffects[i];
            var fiber = unmountEffects[i + 1];
            var destroy = _effect.destroy;
            _effect.destroy = void 0;
            {
              fiber.flags &= ~PassiveUnmountPendingDev;
              var alternate = fiber.alternate;
              if (alternate !== null) {
                alternate.flags &= ~PassiveUnmountPendingDev;
              }
            }
            if (typeof destroy === "function") {
              {
                setCurrentFiber(fiber);
                {
                  invokeGuardedCallback(null, destroy, null);
                }
                if (hasCaughtError()) {
                  if (!(fiber !== null)) {
                    {
                      throw Error("Should be working on an effect.");
                    }
                  }
                  var error2 = clearCaughtError();
                  captureCommitPhaseError(fiber, error2);
                }
                resetCurrentFiber();
              }
            }
          }
          var mountEffects = pendingPassiveHookEffectsMount;
          pendingPassiveHookEffectsMount = [];
          for (var _i = 0; _i < mountEffects.length; _i += 2) {
            var _effect2 = mountEffects[_i];
            var _fiber = mountEffects[_i + 1];
            {
              setCurrentFiber(_fiber);
              {
                invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
              }
              if (hasCaughtError()) {
                if (!(_fiber !== null)) {
                  {
                    throw Error("Should be working on an effect.");
                  }
                }
                var _error4 = clearCaughtError();
                captureCommitPhaseError(_fiber, _error4);
              }
              resetCurrentFiber();
            }
          }
          var effect = root2.current.firstEffect;
          while (effect !== null) {
            var nextNextEffect = effect.nextEffect;
            effect.nextEffect = null;
            if (effect.flags & Deletion) {
              detachFiberAfterEffects(effect);
            }
            effect = nextNextEffect;
          }
          {
            popInteractions(prevInteractions);
            finishPendingInteractions(root2, lanes);
          }
          {
            isFlushingPassiveEffects = false;
          }
          executionContext = prevExecutionContext;
          flushSyncCallbackQueue();
          nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
          return true;
        }
        function isAlreadyFailedLegacyErrorBoundary(instance) {
          return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
        }
        function markLegacyErrorBoundaryAsFailed(instance) {
          if (legacyErrorBoundariesThatAlreadyFailed === null) {
            legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
          } else {
            legacyErrorBoundariesThatAlreadyFailed.add(instance);
          }
        }
        function prepareToThrowUncaughtError(error2) {
          if (!hasUncaughtError) {
            hasUncaughtError = true;
            firstUncaughtError = error2;
          }
        }
        var onUncaughtError = prepareToThrowUncaughtError;
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
          var errorInfo = createCapturedValue(error2, sourceFiber);
          var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
          enqueueUpdate(rootFiber, update);
          var eventTime = requestEventTime();
          var root2 = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);
          if (root2 !== null) {
            markRootUpdated(root2, SyncLane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
            schedulePendingInteractions(root2, SyncLane);
          }
        }
        function captureCommitPhaseError(sourceFiber, error2) {
          if (sourceFiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error2);
            return;
          }
          var fiber = sourceFiber.return;
          while (fiber !== null) {
            if (fiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error2);
              return;
            } else if (fiber.tag === ClassComponent) {
              var ctor = fiber.type;
              var instance = fiber.stateNode;
              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                var errorInfo = createCapturedValue(error2, sourceFiber);
                var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                enqueueUpdate(fiber, update);
                var eventTime = requestEventTime();
                var root2 = markUpdateLaneFromFiberToRoot(fiber, SyncLane);
                if (root2 !== null) {
                  markRootUpdated(root2, SyncLane, eventTime);
                  ensureRootIsScheduled(root2, eventTime);
                  schedulePendingInteractions(root2, SyncLane);
                } else {
                  if (typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                    try {
                      instance.componentDidCatch(error2, errorInfo);
                    } catch (errorToIgnore) {
                    }
                  }
                }
                return;
              }
            }
            fiber = fiber.return;
          }
        }
        function pingSuspendedRoot(root2, wakeable, pingedLanes) {
          var pingCache = root2.pingCache;
          if (pingCache !== null) {
            pingCache.delete(wakeable);
          }
          var eventTime = requestEventTime();
          markRootPinged(root2, pingedLanes);
          if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
              prepareFreshStack(root2, NoLanes);
            } else {
              workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
            }
          }
          ensureRootIsScheduled(root2, eventTime);
          schedulePendingInteractions(root2, pingedLanes);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          if (retryLane === NoLane) {
            retryLane = requestRetryLane(boundaryFiber);
          }
          var eventTime = requestEventTime();
          var root2 = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);
          if (root2 !== null) {
            markRootUpdated(root2, retryLane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
            schedulePendingInteractions(root2, retryLane);
          }
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = NoLane;
          var retryCache;
          {
            retryCache = boundaryFiber.stateNode;
          }
          if (retryCache !== null) {
            retryCache.delete(wakeable);
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function jnd(timeElapsed) {
          return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
        }
        function checkForNestedUpdates() {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = null;
            {
              {
                throw Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
              }
            }
          }
          {
            if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
              nestedPassiveUpdateCount = 0;
              error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
            }
          }
        }
        function flushRenderPhaseStrictModeWarningsInDEV() {
          {
            ReactStrictModeWarnings.flushLegacyContextWarning();
            {
              ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
            }
          }
        }
        var didWarnStateUpdateForNotYetMountedComponent = null;
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          {
            if ((executionContext & RenderContext) !== NoContext) {
              return;
            }
            if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {
              return;
            }
            var tag = fiber.tag;
            if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
              return;
            }
            var componentName = getComponentName(fiber.type) || "ReactComponent";
            if (didWarnStateUpdateForNotYetMountedComponent !== null) {
              if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                return;
              }
              didWarnStateUpdateForNotYetMountedComponent.add(componentName);
            } else {
              didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);
            }
            var previousFiber = current;
            try {
              setCurrentFiber(fiber);
              error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
        var didWarnStateUpdateForUnmountedComponent = null;
        function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
          {
            var tag = fiber.tag;
            if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
              return;
            }
            if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {
              return;
            }
            var componentName = getComponentName(fiber.type) || "ReactComponent";
            if (didWarnStateUpdateForUnmountedComponent !== null) {
              if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
                return;
              }
              didWarnStateUpdateForUnmountedComponent.add(componentName);
            } else {
              didWarnStateUpdateForUnmountedComponent = new Set([componentName]);
            }
            if (isFlushingPassiveEffects)
              ;
            else {
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error("Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in %s.", tag === ClassComponent ? "the componentWillUnmount method" : "a useEffect cleanup function");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
        }
        var beginWork$1;
        {
          var dummyFiber = null;
          beginWork$1 = function(current2, unitOfWork, lanes) {
            var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
            try {
              return beginWork(current2, unitOfWork, lanes);
            } catch (originalError) {
              if (originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                throw originalError;
              }
              resetContextDependencies();
              resetHooksAfterThrow();
              unwindInterruptedWork(unitOfWork);
              assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
              if (unitOfWork.mode & ProfileMode) {
                startProfilerTimer(unitOfWork);
              }
              invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
              if (hasCaughtError()) {
                var replayError = clearCaughtError();
                throw replayError;
              } else {
                throw originalError;
              }
            }
          };
        }
        var didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent;
        {
          didWarnAboutUpdateInRenderForAnotherComponent = new Set();
        }
        function warnAboutRenderPhaseUpdatesInDEV(fiber) {
          {
            if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || "Unknown";
                  var dedupeKey = renderingComponentName;
                  if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                    var setStateComponentName = getComponentName(fiber.type) || "Unknown";
                    error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                  }
                  break;
                }
                case ClassComponent: {
                  if (!didWarnAboutUpdateInRender) {
                    error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                    didWarnAboutUpdateInRender = true;
                  }
                  break;
                }
              }
            }
          }
        }
        var IsThisRendererActing = {
          current: false
        };
        function warnIfNotScopedWithMatchingAct(fiber) {
          {
            if (IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error("It looks like you're using the wrong act() around your test interactions.\nBe sure to use the matching version of act() corresponding to your renderer:\n\n// for react-dom:\nimport {act} from 'react-dom/test-utils';\n// ...\nact(() => ...);\n\n// for react-test-renderer:\nimport TestRenderer from react-test-renderer';\nconst {act} = TestRenderer;\n// ...\nact(() => ...);");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
        }
        function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
          {
            if ((fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
              error("An update to %s ran an effect, but was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
            }
          }
        }
        function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
          {
            if (executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentName(fiber.type));
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
        }
        var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV;
        var didWarnAboutUnmockedScheduler = false;
        function warnIfUnmockedScheduler(fiber) {
          {
            if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === void 0) {
              if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
                didWarnAboutUnmockedScheduler = true;
                error(`In Concurrent or Sync modes, the "scheduler" module needs to be mocked to guarantee consistent behaviour across tests and browsers. For example, with jest: 
jest.mock('scheduler', () => require('scheduler/unstable_mock'));

For more info, visit https://reactjs.org/link/mock-scheduler`);
              }
            }
          }
        }
        function computeThreadID(root2, lane) {
          return lane * 1e3 + root2.interactionThreadID;
        }
        function markSpawnedWork(lane) {
          if (spawnedWorkDuringRender === null) {
            spawnedWorkDuringRender = [lane];
          } else {
            spawnedWorkDuringRender.push(lane);
          }
        }
        function scheduleInteractions(root2, lane, interactions) {
          if (interactions.size > 0) {
            var pendingInteractionMap = root2.pendingInteractionMap;
            var pendingInteractions = pendingInteractionMap.get(lane);
            if (pendingInteractions != null) {
              interactions.forEach(function(interaction) {
                if (!pendingInteractions.has(interaction)) {
                  interaction.__count++;
                }
                pendingInteractions.add(interaction);
              });
            } else {
              pendingInteractionMap.set(lane, new Set(interactions));
              interactions.forEach(function(interaction) {
                interaction.__count++;
              });
            }
            var subscriber = tracing.__subscriberRef.current;
            if (subscriber !== null) {
              var threadID = computeThreadID(root2, lane);
              subscriber.onWorkScheduled(interactions, threadID);
            }
          }
        }
        function schedulePendingInteractions(root2, lane) {
          scheduleInteractions(root2, lane, tracing.__interactionsRef.current);
        }
        function startWorkOnPendingInteractions(root2, lanes) {
          var interactions = new Set();
          root2.pendingInteractionMap.forEach(function(scheduledInteractions, scheduledLane) {
            if (includesSomeLane(lanes, scheduledLane)) {
              scheduledInteractions.forEach(function(interaction) {
                return interactions.add(interaction);
              });
            }
          });
          root2.memoizedInteractions = interactions;
          if (interactions.size > 0) {
            var subscriber = tracing.__subscriberRef.current;
            if (subscriber !== null) {
              var threadID = computeThreadID(root2, lanes);
              try {
                subscriber.onWorkStarted(interactions, threadID);
              } catch (error2) {
                scheduleCallback(ImmediatePriority$1, function() {
                  throw error2;
                });
              }
            }
          }
        }
        function finishPendingInteractions(root2, committedLanes) {
          var remainingLanesAfterCommit = root2.pendingLanes;
          var subscriber;
          try {
            subscriber = tracing.__subscriberRef.current;
            if (subscriber !== null && root2.memoizedInteractions.size > 0) {
              var threadID = computeThreadID(root2, committedLanes);
              subscriber.onWorkStopped(root2.memoizedInteractions, threadID);
            }
          } catch (error2) {
            scheduleCallback(ImmediatePriority$1, function() {
              throw error2;
            });
          } finally {
            var pendingInteractionMap = root2.pendingInteractionMap;
            pendingInteractionMap.forEach(function(scheduledInteractions, lane) {
              if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
                pendingInteractionMap.delete(lane);
                scheduledInteractions.forEach(function(interaction) {
                  interaction.__count--;
                  if (subscriber !== null && interaction.__count === 0) {
                    try {
                      subscriber.onInteractionScheduledWorkCompleted(interaction);
                    } catch (error2) {
                      scheduleCallback(ImmediatePriority$1, function() {
                        throw error2;
                      });
                    }
                  }
                });
              }
            });
          }
        }
        function shouldForceFlushFallbacksInDEV() {
          return actingUpdatesScopeDepth > 0;
        }
        var actingUpdatesScopeDepth = 0;
        function detachFiberAfterEffects(fiber) {
          fiber.sibling = null;
          fiber.stateNode = null;
        }
        var resolveFamily = null;
        var failedBoundaries = null;
        var setRefreshHandler = function(handler) {
          {
            resolveFamily = handler;
          }
        };
        function resolveFunctionForHotReloading(type) {
          {
            if (resolveFamily === null) {
              return type;
            }
            var family = resolveFamily(type);
            if (family === void 0) {
              return type;
            }
            return family.current;
          }
        }
        function resolveClassForHotReloading(type) {
          return resolveFunctionForHotReloading(type);
        }
        function resolveForwardRefForHotReloading(type) {
          {
            if (resolveFamily === null) {
              return type;
            }
            var family = resolveFamily(type);
            if (family === void 0) {
              if (type !== null && type !== void 0 && typeof type.render === "function") {
                var currentRender = resolveFunctionForHotReloading(type.render);
                if (type.render !== currentRender) {
                  var syntheticType = {
                    $$typeof: REACT_FORWARD_REF_TYPE,
                    render: currentRender
                  };
                  if (type.displayName !== void 0) {
                    syntheticType.displayName = type.displayName;
                  }
                  return syntheticType;
                }
              }
              return type;
            }
            return family.current;
          }
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          {
            if (resolveFamily === null) {
              return false;
            }
            var prevType = fiber.elementType;
            var nextType = element.type;
            var needsCompareFamilies = false;
            var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
            switch (fiber.tag) {
              case ClassComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                }
                break;
              }
              case FunctionComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case ForwardRef: {
                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case MemoComponent:
              case SimpleMemoComponent: {
                if ($$typeofNextType === REACT_MEMO_TYPE) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                  needsCompareFamilies = true;
                }
                break;
              }
              default:
                return false;
            }
            if (needsCompareFamilies) {
              var prevFamily = resolveFamily(prevType);
              if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                return true;
              }
            }
            return false;
          }
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          {
            if (resolveFamily === null) {
              return;
            }
            if (typeof WeakSet !== "function") {
              return;
            }
            if (failedBoundaries === null) {
              failedBoundaries = new WeakSet();
            }
            failedBoundaries.add(fiber);
          }
        }
        var scheduleRefresh = function(root2, update) {
          {
            if (resolveFamily === null) {
              return;
            }
            var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
            flushPassiveEffects();
            flushSync(function() {
              scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
            });
          }
        };
        var scheduleRoot = function(root2, element) {
          {
            if (root2.context !== emptyContextObject) {
              return;
            }
            flushPassiveEffects();
            flushSync(function() {
              updateContainer(element, root2, null, null);
            });
          }
        };
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          {
            var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type;
                break;
              case ForwardRef:
                candidateType = type.render;
                break;
            }
            if (resolveFamily === null) {
              throw new Error("Expected resolveFamily to be set during hot reload.");
            }
            var needsRender = false;
            var needsRemount = false;
            if (candidateType !== null) {
              var family = resolveFamily(candidateType);
              if (family !== void 0) {
                if (staleFamilies.has(family)) {
                  needsRemount = true;
                } else if (updatedFamilies.has(family)) {
                  if (tag === ClassComponent) {
                    needsRemount = true;
                  } else {
                    needsRender = true;
                  }
                }
              }
            }
            if (failedBoundaries !== null) {
              if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                needsRemount = true;
              }
            }
            if (needsRemount) {
              fiber._debugNeedsRemount = true;
            }
            if (needsRemount || needsRender) {
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            }
            if (child !== null && !needsRemount) {
              scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
            }
            if (sibling !== null) {
              scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
            }
          }
        }
        var findHostInstancesForRefresh = function(root2, families) {
          {
            var hostInstances = new Set();
            var types2 = new Set(families.map(function(family) {
              return family.current;
            }));
            findHostInstancesForMatchingFibersRecursively(root2.current, types2, hostInstances);
            return hostInstances;
          }
        };
        function findHostInstancesForMatchingFibersRecursively(fiber, types2, hostInstances) {
          {
            var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type;
                break;
              case ForwardRef:
                candidateType = type.render;
                break;
            }
            var didMatch = false;
            if (candidateType !== null) {
              if (types2.has(candidateType)) {
                didMatch = true;
              }
            }
            if (didMatch) {
              findHostInstancesForFiberShallowly(fiber, hostInstances);
            } else {
              if (child !== null) {
                findHostInstancesForMatchingFibersRecursively(child, types2, hostInstances);
              }
            }
            if (sibling !== null) {
              findHostInstancesForMatchingFibersRecursively(sibling, types2, hostInstances);
            }
          }
        }
        function findHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
            if (foundHostInstances) {
              return;
            }
            var node = fiber;
            while (true) {
              switch (node.tag) {
                case HostComponent:
                  hostInstances.add(node.stateNode);
                  return;
                case HostPortal:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
                case HostRoot:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
              }
              if (node.return === null) {
                throw new Error("Expected to reach root first.");
              }
              node = node.return;
            }
          }
        }
        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var node = fiber;
            var foundHostInstances = false;
            while (true) {
              if (node.tag === HostComponent) {
                foundHostInstances = true;
                hostInstances.add(node.stateNode);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === fiber) {
                return foundHostInstances;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === fiber) {
                  return foundHostInstances;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return false;
        }
        var hasBadMapPolyfill;
        {
          hasBadMapPolyfill = false;
          try {
            var nonExtensibleObject = Object.preventExtensions({});
            new Map([[nonExtensibleObject, null]]);
            new Set([nonExtensibleObject]);
          } catch (e) {
            hasBadMapPolyfill = true;
          }
        }
        var debugCounter = 1;
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.elementType = null;
          this.type = null;
          this.stateNode = null;
          this.return = null;
          this.child = null;
          this.sibling = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.updateQueue = null;
          this.memoizedState = null;
          this.dependencies = null;
          this.mode = mode;
          this.flags = NoFlags;
          this.nextEffect = null;
          this.firstEffect = null;
          this.lastEffect = null;
          this.lanes = NoLanes;
          this.childLanes = NoLanes;
          this.alternate = null;
          {
            this.actualDuration = Number.NaN;
            this.actualStartTime = Number.NaN;
            this.selfBaseDuration = Number.NaN;
            this.treeBaseDuration = Number.NaN;
            this.actualDuration = 0;
            this.actualStartTime = -1;
            this.selfBaseDuration = 0;
            this.treeBaseDuration = 0;
          }
          {
            this._debugID = debugCounter++;
            this._debugSource = null;
            this._debugOwner = null;
            this._debugNeedsRemount = false;
            this._debugHookTypes = null;
            if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
              Object.preventExtensions(this);
            }
          }
        }
        var createFiber = function(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        };
        function shouldConstruct$1(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function isSimpleFunctionComponent(type) {
          return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
        }
        function resolveLazyComponentTag(Component) {
          if (typeof Component === "function") {
            return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
          } else if (Component !== void 0 && Component !== null) {
            var $$typeof = Component.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) {
              return ForwardRef;
            }
            if ($$typeof === REACT_MEMO_TYPE) {
              return MemoComponent;
            }
          }
          return IndeterminateComponent;
        }
        function createWorkInProgress(current2, pendingProps) {
          var workInProgress2 = current2.alternate;
          if (workInProgress2 === null) {
            workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
            workInProgress2.elementType = current2.elementType;
            workInProgress2.type = current2.type;
            workInProgress2.stateNode = current2.stateNode;
            {
              workInProgress2._debugID = current2._debugID;
              workInProgress2._debugSource = current2._debugSource;
              workInProgress2._debugOwner = current2._debugOwner;
              workInProgress2._debugHookTypes = current2._debugHookTypes;
            }
            workInProgress2.alternate = current2;
            current2.alternate = workInProgress2;
          } else {
            workInProgress2.pendingProps = pendingProps;
            workInProgress2.type = current2.type;
            workInProgress2.flags = NoFlags;
            workInProgress2.nextEffect = null;
            workInProgress2.firstEffect = null;
            workInProgress2.lastEffect = null;
            {
              workInProgress2.actualDuration = 0;
              workInProgress2.actualStartTime = -1;
            }
          }
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          var currentDependencies = current2.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          workInProgress2.sibling = current2.sibling;
          workInProgress2.index = current2.index;
          workInProgress2.ref = current2.ref;
          {
            workInProgress2.selfBaseDuration = current2.selfBaseDuration;
            workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          }
          {
            workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case FunctionComponent:
              case SimpleMemoComponent:
                workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                break;
              case ClassComponent:
                workInProgress2.type = resolveClassForHotReloading(current2.type);
                break;
              case ForwardRef:
                workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                break;
            }
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= Placement;
          workInProgress2.nextEffect = null;
          workInProgress2.firstEffect = null;
          workInProgress2.lastEffect = null;
          var current2 = workInProgress2.alternate;
          if (current2 === null) {
            workInProgress2.childLanes = NoLanes;
            workInProgress2.lanes = renderLanes2;
            workInProgress2.child = null;
            workInProgress2.memoizedProps = null;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.dependencies = null;
            workInProgress2.stateNode = null;
            {
              workInProgress2.selfBaseDuration = 0;
              workInProgress2.treeBaseDuration = 0;
            }
          } else {
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            workInProgress2.type = current2.type;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
          }
          return workInProgress2;
        }
        function createHostRootFiber(tag) {
          var mode;
          if (tag === ConcurrentRoot) {
            mode = ConcurrentMode | BlockingMode | StrictMode;
          } else if (tag === BlockingRoot) {
            mode = BlockingMode | StrictMode;
          } else {
            mode = NoMode;
          }
          if (isDevToolsPresent) {
            mode |= ProfileMode;
          }
          return createFiber(HostRoot, null, null, mode);
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
          var fiberTag = IndeterminateComponent;
          var resolvedType = type;
          if (typeof type === "function") {
            if (shouldConstruct$1(type)) {
              fiberTag = ClassComponent;
              {
                resolvedType = resolveClassForHotReloading(resolvedType);
              }
            } else {
              {
                resolvedType = resolveFunctionForHotReloading(resolvedType);
              }
            }
          } else if (typeof type === "string") {
            fiberTag = HostComponent;
          } else {
            getTag:
              switch (type) {
                case REACT_FRAGMENT_TYPE:
                  return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                case REACT_DEBUG_TRACING_MODE_TYPE:
                  fiberTag = Mode;
                  mode |= DebugTracingMode;
                  break;
                case REACT_STRICT_MODE_TYPE:
                  fiberTag = Mode;
                  mode |= StrictMode;
                  break;
                case REACT_PROFILER_TYPE:
                  return createFiberFromProfiler(pendingProps, mode, lanes, key);
                case REACT_SUSPENSE_TYPE:
                  return createFiberFromSuspense(pendingProps, mode, lanes, key);
                case REACT_SUSPENSE_LIST_TYPE:
                  return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                case REACT_OFFSCREEN_TYPE:
                  return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                case REACT_LEGACY_HIDDEN_TYPE:
                  return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);
                case REACT_SCOPE_TYPE:
                default: {
                  if (typeof type === "object" && type !== null) {
                    switch (type.$$typeof) {
                      case REACT_PROVIDER_TYPE:
                        fiberTag = ContextProvider;
                        break getTag;
                      case REACT_CONTEXT_TYPE:
                        fiberTag = ContextConsumer;
                        break getTag;
                      case REACT_FORWARD_REF_TYPE:
                        fiberTag = ForwardRef;
                        {
                          resolvedType = resolveForwardRefForHotReloading(resolvedType);
                        }
                        break getTag;
                      case REACT_MEMO_TYPE:
                        fiberTag = MemoComponent;
                        break getTag;
                      case REACT_LAZY_TYPE:
                        fiberTag = LazyComponent;
                        resolvedType = null;
                        break getTag;
                      case REACT_BLOCK_TYPE:
                        fiberTag = Block;
                        break getTag;
                    }
                  }
                  var info = "";
                  {
                    if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                      info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                    }
                    var ownerName = owner ? getComponentName(owner.type) : null;
                    if (ownerName) {
                      info += "\n\nCheck the render method of `" + ownerName + "`.";
                    }
                  }
                  {
                    {
                      throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type == null ? type : typeof type) + "." + info);
                    }
                  }
                }
              }
          }
          var fiber = createFiber(fiberTag, pendingProps, key, mode);
          fiber.elementType = type;
          fiber.type = resolvedType;
          fiber.lanes = lanes;
          {
            fiber._debugOwner = owner;
          }
          return fiber;
        }
        function createFiberFromElement(element, mode, lanes) {
          var owner = null;
          {
            owner = element._owner;
          }
          var type = element.type;
          var key = element.key;
          var pendingProps = element.props;
          var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
          {
            fiber._debugSource = element._source;
            fiber._debugOwner = element._owner;
          }
          return fiber;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          var fiber = createFiber(Fragment, elements, key, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromProfiler(pendingProps, mode, lanes, key) {
          {
            if (typeof pendingProps.id !== "string") {
              error('Profiler must specify an "id" as a prop');
            }
          }
          var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
          fiber.elementType = REACT_PROFILER_TYPE;
          fiber.type = REACT_PROFILER_TYPE;
          fiber.lanes = lanes;
          {
            fiber.stateNode = {
              effectDuration: 0,
              passiveEffectDuration: 0
            };
          }
          return fiber;
        }
        function createFiberFromSuspense(pendingProps, mode, lanes, key) {
          var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
          fiber.type = REACT_SUSPENSE_TYPE;
          fiber.elementType = REACT_SUSPENSE_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
          var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
          {
            fiber.type = REACT_SUSPENSE_LIST_TYPE;
          }
          fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
          var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
          {
            fiber.type = REACT_OFFSCREEN_TYPE;
          }
          fiber.elementType = REACT_OFFSCREEN_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
          var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode);
          {
            fiber.type = REACT_LEGACY_HIDDEN_TYPE;
          }
          fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromText(content2, mode, lanes) {
          var fiber = createFiber(HostText, content2, null, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromHostInstanceForDeletion() {
          var fiber = createFiber(HostComponent, null, null, NoMode);
          fiber.elementType = "DELETED";
          fiber.type = "DELETED";
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          var pendingProps = portal.children !== null ? portal.children : [];
          var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
          fiber.lanes = lanes;
          fiber.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return fiber;
        }
        function assignFiberPropertiesInDEV(target, source) {
          if (target === null) {
            target = createFiber(IndeterminateComponent, null, null, NoMode);
          }
          target.tag = source.tag;
          target.key = source.key;
          target.elementType = source.elementType;
          target.type = source.type;
          target.stateNode = source.stateNode;
          target.return = source.return;
          target.child = source.child;
          target.sibling = source.sibling;
          target.index = source.index;
          target.ref = source.ref;
          target.pendingProps = source.pendingProps;
          target.memoizedProps = source.memoizedProps;
          target.updateQueue = source.updateQueue;
          target.memoizedState = source.memoizedState;
          target.dependencies = source.dependencies;
          target.mode = source.mode;
          target.flags = source.flags;
          target.nextEffect = source.nextEffect;
          target.firstEffect = source.firstEffect;
          target.lastEffect = source.lastEffect;
          target.lanes = source.lanes;
          target.childLanes = source.childLanes;
          target.alternate = source.alternate;
          {
            target.actualDuration = source.actualDuration;
            target.actualStartTime = source.actualStartTime;
            target.selfBaseDuration = source.selfBaseDuration;
            target.treeBaseDuration = source.treeBaseDuration;
          }
          target._debugID = source._debugID;
          target._debugSource = source._debugSource;
          target._debugOwner = source._debugOwner;
          target._debugNeedsRemount = source._debugNeedsRemount;
          target._debugHookTypes = source._debugHookTypes;
          return target;
        }
        function FiberRootNode(containerInfo, tag, hydrate2) {
          this.tag = tag;
          this.containerInfo = containerInfo;
          this.pendingChildren = null;
          this.current = null;
          this.pingCache = null;
          this.finishedWork = null;
          this.timeoutHandle = noTimeout;
          this.context = null;
          this.pendingContext = null;
          this.hydrate = hydrate2;
          this.callbackNode = null;
          this.callbackPriority = NoLanePriority;
          this.eventTimes = createLaneMap(NoLanes);
          this.expirationTimes = createLaneMap(NoTimestamp);
          this.pendingLanes = NoLanes;
          this.suspendedLanes = NoLanes;
          this.pingedLanes = NoLanes;
          this.expiredLanes = NoLanes;
          this.mutableReadLanes = NoLanes;
          this.finishedLanes = NoLanes;
          this.entangledLanes = NoLanes;
          this.entanglements = createLaneMap(NoLanes);
          {
            this.mutableSourceEagerHydrationData = null;
          }
          {
            this.interactionThreadID = tracing.unstable_getThreadID();
            this.memoizedInteractions = new Set();
            this.pendingInteractionMap = new Map();
          }
          {
            switch (tag) {
              case BlockingRoot:
                this._debugRootType = "createBlockingRoot()";
                break;
              case ConcurrentRoot:
                this._debugRootType = "createRoot()";
                break;
              case LegacyRoot:
                this._debugRootType = "createLegacyRoot()";
                break;
            }
          }
        }
        function createFiberRoot(containerInfo, tag, hydrate2, hydrationCallbacks) {
          var root2 = new FiberRootNode(containerInfo, tag, hydrate2);
          var uninitializedFiber = createHostRootFiber(tag);
          root2.current = uninitializedFiber;
          uninitializedFiber.stateNode = root2;
          initializeUpdateQueue(uninitializedFiber);
          return root2;
        }
        function registerMutableSourceForHydration(root2, mutableSource) {
          var getVersion = mutableSource._getVersion;
          var version = getVersion(mutableSource._source);
          if (root2.mutableSourceEagerHydrationData == null) {
            root2.mutableSourceEagerHydrationData = [mutableSource, version];
          } else {
            root2.mutableSourceEagerHydrationData.push(mutableSource, version);
          }
        }
        function createPortal(children, containerInfo, implementation) {
          var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: key == null ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        var didWarnAboutNestedUpdates;
        var didWarnAboutFindNodeInStrictMode;
        {
          didWarnAboutNestedUpdates = false;
          didWarnAboutFindNodeInStrictMode = {};
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) {
            return emptyContextObject;
          }
          var fiber = get(parentComponent);
          var parentContext = findCurrentUnmaskedContext(fiber);
          if (fiber.tag === ClassComponent) {
            var Component = fiber.type;
            if (isContextProvider(Component)) {
              return processChildContext(fiber, Component, parentContext);
            }
          }
          return parentContext;
        }
        function findHostInstanceWithWarning(component, methodName) {
          {
            var fiber = get(component);
            if (fiber === void 0) {
              if (typeof component.render === "function") {
                {
                  {
                    throw Error("Unable to find node on an unmounted component.");
                  }
                }
              } else {
                {
                  {
                    throw Error("Argument appears to not be a ReactComponent. Keys: " + Object.keys(component));
                  }
                }
              }
            }
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.mode & StrictMode) {
              var componentName = getComponentName(fiber.type) || "Component";
              if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                didWarnAboutFindNodeInStrictMode[componentName] = true;
                var previousFiber = current;
                try {
                  setCurrentFiber(hostFiber);
                  if (fiber.mode & StrictMode) {
                    error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  } else {
                    error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  }
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(previousFiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
            return hostFiber.stateNode;
          }
        }
        function createContainer(containerInfo, tag, hydrate2, hydrationCallbacks) {
          return createFiberRoot(containerInfo, tag, hydrate2);
        }
        function updateContainer(element, container, parentComponent, callback) {
          {
            onScheduleRoot(container, element);
          }
          var current$1 = container.current;
          var eventTime = requestEventTime();
          {
            if (typeof jest !== "undefined") {
              warnIfUnmockedScheduler(current$1);
              warnIfNotScopedWithMatchingAct(current$1);
            }
          }
          var lane = requestUpdateLane(current$1);
          var context = getContextForSubtree(parentComponent);
          if (container.context === null) {
            container.context = context;
          } else {
            container.pendingContext = context;
          }
          {
            if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
              didWarnAboutNestedUpdates = true;
              error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentName(current.type) || "Unknown");
            }
          }
          var update = createUpdate(eventTime, lane);
          update.payload = {
            element
          };
          callback = callback === void 0 ? null : callback;
          if (callback !== null) {
            {
              if (typeof callback !== "function") {
                error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
              }
            }
            update.callback = callback;
          }
          enqueueUpdate(current$1, update);
          scheduleUpdateOnFiber(current$1, lane, eventTime);
          return lane;
        }
        function getPublicRootInstance(container) {
          var containerFiber = container.current;
          if (!containerFiber.child) {
            return null;
          }
          switch (containerFiber.child.tag) {
            case HostComponent:
              return getPublicInstance(containerFiber.child.stateNode);
            default:
              return containerFiber.child.stateNode;
          }
        }
        function markRetryLaneImpl(fiber, retryLane) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState !== null && suspenseState.dehydrated !== null) {
            suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          var alternate = fiber.alternate;
          if (alternate) {
            markRetryLaneImpl(alternate, retryLane);
          }
        }
        function attemptUserBlockingHydration$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var eventTime = requestEventTime();
          var lane = InputDiscreteHydrationLane;
          scheduleUpdateOnFiber(fiber, lane, eventTime);
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function attemptContinuousHydration$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var eventTime = requestEventTime();
          var lane = SelectiveHydrationLane;
          scheduleUpdateOnFiber(fiber, lane, eventTime);
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function attemptHydrationAtCurrentPriority$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          scheduleUpdateOnFiber(fiber, lane, eventTime);
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function runWithPriority$2(priority, fn) {
          try {
            setCurrentUpdateLanePriority(priority);
            return fn();
          } finally {
          }
        }
        function findHostInstanceWithNoPortals(fiber) {
          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
          if (hostFiber === null) {
            return null;
          }
          if (hostFiber.tag === FundamentalComponent) {
            return hostFiber.stateNode.instance;
          }
          return hostFiber.stateNode;
        }
        var shouldSuspendImpl = function(fiber) {
          return false;
        };
        function shouldSuspend(fiber) {
          return shouldSuspendImpl(fiber);
        }
        var overrideHookState = null;
        var overrideHookStateDeletePath = null;
        var overrideHookStateRenamePath = null;
        var overrideProps = null;
        var overridePropsDeletePath = null;
        var overridePropsRenamePath = null;
        var scheduleUpdate = null;
        var setSuspenseHandler = null;
        {
          var copyWithDeleteImpl = function(obj, path, index2) {
            var key = path[index2];
            var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
            if (index2 + 1 === path.length) {
              if (Array.isArray(updated)) {
                updated.splice(key, 1);
              } else {
                delete updated[key];
              }
              return updated;
            }
            updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
            return updated;
          };
          var copyWithDelete = function(obj, path) {
            return copyWithDeleteImpl(obj, path, 0);
          };
          var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
            var oldKey = oldPath[index2];
            var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
            if (index2 + 1 === oldPath.length) {
              var newKey = newPath[index2];
              updated[newKey] = updated[oldKey];
              if (Array.isArray(updated)) {
                updated.splice(oldKey, 1);
              } else {
                delete updated[oldKey];
              }
            } else {
              updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index2 + 1);
            }
            return updated;
          };
          var copyWithRename = function(obj, oldPath, newPath) {
            if (oldPath.length !== newPath.length) {
              warn("copyWithRename() expects paths of the same length");
              return;
            } else {
              for (var i = 0; i < newPath.length - 1; i++) {
                if (oldPath[i] !== newPath[i]) {
                  warn("copyWithRename() expects paths to be the same except for the deepest key");
                  return;
                }
              }
            }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          };
          var copyWithSetImpl = function(obj, path, index2, value) {
            if (index2 >= path.length) {
              return value;
            }
            var key = path[index2];
            var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);
            updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
            return updated;
          };
          var copyWithSet = function(obj, path, value) {
            return copyWithSetImpl(obj, path, 0, value);
          };
          var findHook = function(fiber, id) {
            var currentHook2 = fiber.memoizedState;
            while (currentHook2 !== null && id > 0) {
              currentHook2 = currentHook2.next;
              id--;
            }
            return currentHook2;
          };
          overrideHookState = function(fiber, id, path, value) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithSet(hook.memoizedState, path, value);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = _assign({}, fiber.memoizedProps);
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            }
          };
          overrideHookStateDeletePath = function(fiber, id, path) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithDelete(hook.memoizedState, path);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = _assign({}, fiber.memoizedProps);
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            }
          };
          overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = _assign({}, fiber.memoizedProps);
              scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
            }
          };
          overrideProps = function(fiber, path, value) {
            fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
          };
          overridePropsDeletePath = function(fiber, path) {
            fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
          };
          overridePropsRenamePath = function(fiber, oldPath, newPath) {
            fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
          };
          scheduleUpdate = function(fiber) {
            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
          };
          setSuspenseHandler = function(newShouldSuspendImpl) {
            shouldSuspendImpl = newShouldSuspendImpl;
          };
        }
        function findHostInstanceByFiber(fiber) {
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        function emptyFindFiberByHostInstance(instance) {
          return null;
        }
        function getCurrentFiberForDevTools() {
          return current;
        }
        function injectIntoDevTools(devToolsConfig) {
          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
          var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
          return injectInternals({
            bundleType: devToolsConfig.bundleType,
            version: devToolsConfig.version,
            rendererPackageName: devToolsConfig.rendererPackageName,
            rendererConfig: devToolsConfig.rendererConfig,
            overrideHookState,
            overrideHookStateDeletePath,
            overrideHookStateRenamePath,
            overrideProps,
            overridePropsDeletePath,
            overridePropsRenamePath,
            setSuspenseHandler,
            scheduleUpdate,
            currentDispatcherRef: ReactCurrentDispatcher2,
            findHostInstanceByFiber,
            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
            findHostInstancesForRefresh,
            scheduleRefresh,
            scheduleRoot,
            setRefreshHandler,
            getCurrentFiber: getCurrentFiberForDevTools
          });
        }
        function ReactDOMRoot(container, options2) {
          this._internalRoot = createRootImpl(container, ConcurrentRoot, options2);
        }
        function ReactDOMBlockingRoot(container, tag, options2) {
          this._internalRoot = createRootImpl(container, tag, options2);
        }
        ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function(children) {
          var root2 = this._internalRoot;
          {
            if (typeof arguments[1] === "function") {
              error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            }
            var container = root2.containerInfo;
            if (container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(root2.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                }
              }
            }
          }
          updateContainer(children, root2, null, null);
        };
        ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function() {
          {
            if (typeof arguments[0] === "function") {
              error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            }
          }
          var root2 = this._internalRoot;
          var container = root2.containerInfo;
          updateContainer(null, root2, null, function() {
            unmarkContainerAsRoot(container);
          });
        };
        function createRootImpl(container, tag, options2) {
          var hydrate2 = options2 != null && options2.hydrate === true;
          var hydrationCallbacks = options2 != null && options2.hydrationOptions || null;
          var mutableSources = options2 != null && options2.hydrationOptions != null && options2.hydrationOptions.mutableSources || null;
          var root2 = createContainer(container, tag, hydrate2);
          markContainerAsRoot(root2.current, container);
          var containerNodeType = container.nodeType;
          {
            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(rootContainerElement);
          }
          if (mutableSources) {
            for (var i = 0; i < mutableSources.length; i++) {
              var mutableSource = mutableSources[i];
              registerMutableSourceForHydration(root2, mutableSource);
            }
          }
          return root2;
        }
        function createLegacyRoot(container, options2) {
          return new ReactDOMBlockingRoot(container, LegacyRoot, options2);
        }
        function isValidContainer(node) {
          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
        }
        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
        var topLevelUpdateWarnings;
        var warnedAboutHydrateAPI = false;
        {
          topLevelUpdateWarnings = function(container) {
            if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                }
              }
            }
            var isRootRenderedBySomeReact = !!container._reactRootContainer;
            var rootEl = getReactRootElementInContainer(container);
            var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
            if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
              error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
            }
            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
              error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
            }
          };
        }
        function getReactRootElementInContainer(container) {
          if (!container) {
            return null;
          }
          if (container.nodeType === DOCUMENT_NODE) {
            return container.documentElement;
          } else {
            return container.firstChild;
          }
        }
        function shouldHydrateDueToLegacyHeuristic(container) {
          var rootElement = getReactRootElementInContainer(container);
          return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
        }
        function legacyCreateRootFromDOMContainer(container, forceHydrate) {
          var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
          if (!shouldHydrate) {
            var warned = false;
            var rootSibling;
            while (rootSibling = container.lastChild) {
              {
                if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
                  warned = true;
                  error("render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.");
                }
              }
              container.removeChild(rootSibling);
            }
          }
          {
            if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
              warnedAboutHydrateAPI = true;
              warn("render(): Calling ReactDOM.render() to hydrate server-rendered markup will stop working in React v18. Replace the ReactDOM.render() call with ReactDOM.hydrate() if you want React to attach to the server HTML.");
            }
          }
          return createLegacyRoot(container, shouldHydrate ? {
            hydrate: true
          } : void 0);
        }
        function warnOnInvalidCallback$1(callback, callerName) {
          {
            if (callback !== null && typeof callback !== "function") {
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          }
        }
        function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
          {
            topLevelUpdateWarnings(container);
            warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
          }
          var root2 = container._reactRootContainer;
          var fiberRoot;
          if (!root2) {
            root2 = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
            fiberRoot = root2._internalRoot;
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(fiberRoot);
                originalCallback.call(instance);
              };
            }
            unbatchedUpdates(function() {
              updateContainer(children, fiberRoot, parentComponent, callback);
            });
          } else {
            fiberRoot = root2._internalRoot;
            if (typeof callback === "function") {
              var _originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(fiberRoot);
                _originalCallback.call(instance);
              };
            }
            updateContainer(children, fiberRoot, parentComponent, callback);
          }
          return getPublicRootInstance(fiberRoot);
        }
        function findDOMNode(componentOrElement) {
          {
            var owner = ReactCurrentOwner$3.current;
            if (owner !== null && owner.stateNode !== null) {
              var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
              if (!warnedAboutRefsInRender) {
                error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentName(owner.type) || "A component");
              }
              owner.stateNode._warnedAboutRefsInRender = true;
            }
          }
          if (componentOrElement == null) {
            return null;
          }
          if (componentOrElement.nodeType === ELEMENT_NODE) {
            return componentOrElement;
          }
          {
            return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
          }
        }
        function hydrate(element, container, callback) {
          if (!isValidContainer(container)) {
            {
              throw Error("Target container is not a DOM element.");
            }
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call createRoot(container, {hydrate: true}).render(element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
        }
        function render(element, container, callback) {
          if (!isValidContainer(container)) {
            {
              throw Error("Target container is not a DOM element.");
            }
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.render(element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
        }
        function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          if (!isValidContainer(containerNode)) {
            {
              throw Error("Target container is not a DOM element.");
            }
          }
          if (!(parentComponent != null && has(parentComponent))) {
            {
              throw Error("parentComponent must be a valid React Component");
            }
          }
          return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
        }
        function unmountComponentAtNode(container) {
          if (!isValidContainer(container)) {
            {
              throw Error("unmountComponentAtNode(...): Target container is not a DOM element.");
            }
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?");
            }
          }
          if (container._reactRootContainer) {
            {
              var rootEl = getReactRootElementInContainer(container);
              var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
              if (renderedByDifferentReact) {
                error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
              }
            }
            unbatchedUpdates(function() {
              legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                container._reactRootContainer = null;
                unmarkContainerAsRoot(container);
              });
            });
            return true;
          } else {
            {
              var _rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
              var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;
              if (hasNonRootReactChild) {
                error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
              }
            }
            return false;
          }
        }
        setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);
        setAttemptContinuousHydration(attemptContinuousHydration$1);
        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
        setAttemptHydrationAtPriority(runWithPriority$2);
        var didWarnAboutUnstableCreatePortal = false;
        {
          if (typeof Map !== "function" || Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
            error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          }
        }
        setRestoreImplementation(restoreControlledState$3);
        setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);
        function createPortal$1(children, container) {
          var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (!isValidContainer(container)) {
            {
              throw Error("Target container is not a DOM element.");
            }
          }
          return createPortal(children, container, null, key);
        }
        function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
        }
        function unstable_createPortal(children, container) {
          var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          {
            if (!didWarnAboutUnstableCreatePortal) {
              didWarnAboutUnstableCreatePortal = true;
              warn('The ReactDOM.unstable_createPortal() alias has been deprecated, and will be removed in React 18+. Update your code to use ReactDOM.createPortal() instead. It has the exact same API, but without the "unstable_" prefix.');
            }
          }
          return createPortal$1(children, container, key);
        }
        var Internals = {
          Events: [
            getInstanceFromNode,
            getNodeFromInstance,
            getFiberCurrentPropsFromNode,
            enqueueStateRestore,
            restoreStateIfNeeded,
            flushPassiveEffects,
            IsThisRendererActing
          ]
        };
        var foundDevTools = injectIntoDevTools({
          findFiberByHostInstance: getClosestInstanceFromNode,
          bundleType: 1,
          version: ReactVersion,
          rendererPackageName: "react-dom"
        });
        {
          if (!foundDevTools && canUseDOM && window.top === window.self) {
            if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
              var protocol = window.location.protocol;
              if (/^(https?|file):$/.test(protocol)) {
                console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
              }
            }
          }
        }
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
        exports.createPortal = createPortal$1;
        exports.findDOMNode = findDOMNode;
        exports.flushSync = flushSync;
        exports.hydrate = hydrate;
        exports.render = render;
        exports.unmountComponentAtNode = unmountComponentAtNode;
        exports.unstable_batchedUpdates = batchedUpdates$1;
        exports.unstable_createPortal = unstable_createPortal;
        exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module) {
    "use strict";
    if (false) {
      checkDCE();
      module.exports = null;
    } else {
      module.exports = require_react_dom_development();
    }
  }
});

// node_modules/reactex/node_modules/@orcid/bibtex-parse-js/bibtexParse.js
var require_bibtexParse = __commonJS({
  "node_modules/reactex/node_modules/@orcid/bibtex-parse-js/bibtexParse.js"(exports) {
    (function(exports2) {
      function BibtexParser() {
        this.months = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
        this.notKey = [",", "{", "}", " ", "="];
        this.pos = 0;
        this.input = "";
        this.entries = new Array();
        this.currentEntry = "";
        this.setInput = function(t2) {
          this.input = t2;
        };
        this.getEntries = function() {
          return this.entries;
        };
        this.isWhitespace = function(s) {
          return s == " " || s == "\r" || s == "	" || s == "\n";
        };
        this.match = function(s, canCommentOut) {
          if (canCommentOut == void 0 || canCommentOut == null)
            canCommentOut = true;
          this.skipWhitespace(canCommentOut);
          if (this.input.substring(this.pos, this.pos + s.length) == s) {
            this.pos += s.length;
          } else {
            throw TypeError("Token mismatch: match", "expected " + s + ", found " + this.input.substring(this.pos));
          }
          ;
          this.skipWhitespace(canCommentOut);
        };
        this.tryMatch = function(s, canCommentOut) {
          if (canCommentOut == void 0 || canCommentOut == null)
            canCommentOut = true;
          this.skipWhitespace(canCommentOut);
          if (this.input.substring(this.pos, this.pos + s.length) == s) {
            return true;
          } else {
            return false;
          }
          ;
          this.skipWhitespace(canCommentOut);
        };
        this.matchAt = function() {
          while (this.input.length > this.pos && this.input[this.pos] != "@") {
            this.pos++;
          }
          ;
          if (this.input[this.pos] == "@") {
            return true;
          }
          ;
          return false;
        };
        this.skipWhitespace = function(canCommentOut) {
          while (this.isWhitespace(this.input[this.pos])) {
            this.pos++;
          }
          ;
          if (this.input[this.pos] == "%" && canCommentOut == true) {
            while (this.input[this.pos] != "\n") {
              this.pos++;
            }
            ;
            this.skipWhitespace(canCommentOut);
          }
          ;
        };
        this.value_braces = function() {
          var bracecount = 0;
          this.match("{", false);
          var start2 = this.pos;
          var escaped = false;
          while (true) {
            if (!escaped) {
              if (this.input[this.pos] == "}") {
                if (bracecount > 0) {
                  bracecount--;
                } else {
                  var end = this.pos;
                  this.match("}", false);
                  return this.input.substring(start2, end);
                }
                ;
              } else if (this.input[this.pos] == "{") {
                bracecount++;
              } else if (this.pos >= this.input.length - 1) {
                throw TypeError("Unterminated value: value_braces");
              }
              ;
            }
            ;
            if (this.input[this.pos] == "\\" && escaped == false)
              escaped = true;
            else
              escaped = false;
            this.pos++;
          }
          ;
        };
        this.value_comment = function() {
          var str = "";
          var brcktCnt = 0;
          while (!(this.tryMatch("}", false) && brcktCnt == 0)) {
            str = str + this.input[this.pos];
            if (this.input[this.pos] == "{")
              brcktCnt++;
            if (this.input[this.pos] == "}")
              brcktCnt--;
            if (this.pos >= this.input.length - 1) {
              throw TypeError("Unterminated value: value_comment", +this.input.substring(start));
            }
            ;
            this.pos++;
          }
          ;
          return str;
        };
        this.value_quotes = function() {
          this.match('"', false);
          var start2 = this.pos;
          var escaped = false;
          while (true) {
            if (!escaped) {
              if (this.input[this.pos] == '"') {
                var end = this.pos;
                this.match('"', false);
                return this.input.substring(start2, end);
              } else if (this.pos >= this.input.length - 1) {
                throw TypeError("Unterminated value: value_quotes", this.input.substring(start2));
              }
              ;
            }
            if (this.input[this.pos] == "\\" && escaped == false)
              escaped = true;
            else
              escaped = false;
            this.pos++;
          }
          ;
        };
        this.single_value = function() {
          var start2 = this.pos;
          if (this.tryMatch("{")) {
            return this.value_braces();
          } else if (this.tryMatch('"')) {
            return this.value_quotes();
          } else {
            var k = this.key();
            if (k.match("^[0-9]+$"))
              return k;
            else if (this.months.indexOf(k.toLowerCase()) >= 0)
              return k.toLowerCase();
            else
              throw "Value expected: single_value" + this.input.substring(start2) + " for key: " + k;
          }
          ;
        };
        this.value = function() {
          var values = [];
          values.push(this.single_value());
          while (this.tryMatch("#")) {
            this.match("#");
            values.push(this.single_value());
          }
          ;
          return values.join("");
        };
        this.key = function(optional) {
          var start2 = this.pos;
          while (true) {
            if (this.pos >= this.input.length) {
              throw TypeError("Runaway key: key");
            }
            ;
            if (this.notKey.indexOf(this.input[this.pos]) >= 0) {
              if (optional && this.input[this.pos] != ",") {
                this.pos = start2;
                return null;
              }
              ;
              return this.input.substring(start2, this.pos);
            } else {
              this.pos++;
            }
            ;
          }
          ;
        };
        this.key_equals_value = function() {
          var key = this.key();
          if (this.tryMatch("=")) {
            this.match("=");
            var val = this.value();
            key = key.trim();
            return [key, val];
          } else {
            throw TypeError("Value expected, equals sign missing: key_equals_value", this.input.substring(this.pos));
          }
          ;
        };
        this.key_value_list = function() {
          var kv = this.key_equals_value();
          this.currentEntry["entryTags"] = {};
          this.currentEntry["entryTags"][kv[0]] = kv[1];
          while (this.tryMatch(",")) {
            this.match(",");
            if (this.tryMatch("}")) {
              break;
            }
            ;
            kv = this.key_equals_value();
            this.currentEntry["entryTags"][kv[0]] = kv[1];
          }
          ;
        };
        this.entry_body = function(d) {
          this.currentEntry = {};
          this.currentEntry["citationKey"] = this.key(true);
          this.currentEntry["entryType"] = d.substring(1);
          if (this.currentEntry["citationKey"] != null) {
            this.match(",");
          }
          this.key_value_list();
          this.entries.push(this.currentEntry);
        };
        this.directive = function() {
          this.match("@");
          return "@" + this.key();
        };
        this.preamble = function() {
          this.currentEntry = {};
          this.currentEntry["entryType"] = "PREAMBLE";
          this.currentEntry["entry"] = this.value_comment();
          this.entries.push(this.currentEntry);
        };
        this.comment = function() {
          this.currentEntry = {};
          this.currentEntry["entryType"] = "COMMENT";
          this.currentEntry["entry"] = this.value_comment();
          this.entries.push(this.currentEntry);
        };
        this.entry = function(d) {
          this.entry_body(d);
        };
        this.alernativeCitationKey = function() {
          this.entries.forEach(function(entry) {
            if (!entry.citationKey && entry.entryTags) {
              entry.citationKey = "";
              if (entry.entryTags.author) {
                entry.citationKey += entry.entryTags.author.split(",")[0] += ", ";
              }
              entry.citationKey += entry.entryTags.year;
            }
          });
        };
        this.bibtex = function() {
          while (this.matchAt()) {
            var d = this.directive();
            this.match("{");
            if (d.toUpperCase() == "@STRING") {
              this.string();
            } else if (d.toUpperCase() == "@PREAMBLE") {
              this.preamble();
            } else if (d.toUpperCase() == "@COMMENT") {
              this.comment();
            } else {
              this.entry(d);
            }
            this.match("}");
          }
          ;
          this.alernativeCitationKey();
        };
      }
      ;
      exports2.toJSON = function(bibtex) {
        var b = new BibtexParser();
        b.setInput(bibtex);
        b.bibtex();
        return b.entries;
      };
      exports2.toBibtex = function(json, compact) {
        if (compact === void 0)
          compact = true;
        var out = "";
        var entrysep = ",";
        var indent = "";
        if (!compact) {
          entrysep = ",\n";
          indent = "    ";
        }
        for (var i in json) {
          out += "@" + json[i].entryType;
          out += "{";
          if (json[i].citationKey)
            out += json[i].citationKey + entrysep;
          if (json[i].entry)
            out += json[i].entry;
          if (json[i].entryTags) {
            var tags2 = indent;
            for (var jdx in json[i].entryTags) {
              if (tags2.trim().length != 0)
                tags2 += entrysep + indent;
              tags2 += jdx + (compact ? "={" : " = {") + json[i].entryTags[jdx] + "}";
            }
            out += tags2;
          }
          out += compact ? "}\n" : "\n}\n\n";
        }
        return out;
      };
    })(typeof exports === "undefined" ? exports["bibtexParse"] = {} : exports);
  }
});

// node_modules/reactex/node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/reactex/node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string2) {
        return string2.split("");
      }
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string2) {
        return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string2) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string2)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _4.defaults(root.Object(), context, _4.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end = view.end, length = end - start2, index = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash2(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash2.prototype.clear = hashClear;
        Hash2.prototype["delete"] = hashDelete;
        Hash2.prototype.get = hashGet;
        Hash2.prototype.has = hashHas;
        Hash2.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash2(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash2()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack2(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack2.prototype.clear = stackClear;
        Stack2.prototype["delete"] = stackDelete;
        Stack2.prototype.get = stackGet;
        Stack2.prototype.has = stackHas;
        Stack2.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number2, lower, upper) {
          if (number2 === number2) {
            if (upper !== undefined2) {
              number2 = number2 <= upper ? number2 : upper;
            }
            if (lower !== undefined2) {
              number2 = number2 >= lower ? number2 : lower;
            }
          }
          return number2;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack2());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start2, end) {
          var length = array.length;
          start2 = toInteger(start2);
          if (start2 < 0) {
            start2 = -start2 > length ? 0 : length + start2;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start2 > end ? 0 : toLength(end);
          while (start2 < end) {
            array[start2++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number2, start2, end) {
          return number2 >= nativeMin(start2, end) && number2 < nativeMax(start2, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack2());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack2());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack2());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack2();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack2());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start2, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start2;
            start2 += step;
          }
          return result2;
        }
        function baseRepeat(string2, n) {
          var result2 = "";
          if (!string2 || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string2;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string2 += string2;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start2) {
          return setToString(overRest(func, start2, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string2) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string2),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start2, end) {
          var index = -1, length = array.length;
          if (start2 < 0) {
            start2 = -start2 > length ? 0 : length + start2;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start2 > end ? 0 : end - start2 >>> 0;
          start2 >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start2];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start2, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start2 && end >= length ? array : baseSlice(array, start2, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string2) {
            string2 = toString(string2);
            var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string2) {
            return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator2, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator2(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start2, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
              end = step = undefined2;
            }
            start2 = toFinite(start2);
            if (end === undefined2) {
              end = start2;
              start2 = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start2 < end ? 1 : -1 : toFinite(step);
            return baseRange(start2, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator2) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator2(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number2, precision) {
            number2 = toNumber(number2);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number2)) {
              var pair2 = (toString(number2) + "e").split("e"), value = func(pair2[0] + "e" + (+pair2[1] + precision));
              pair2 = (toString(value) + "e").split("e");
              return +(pair2[0] + "e" + (+pair2[1] - precision));
            }
            return func(number2);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten2), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start2, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start2 += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start2 + size2);
                break;
              case "takeRight":
                start2 = nativeMax(start2, end - size2);
                break;
            }
          }
          return { "start": start2, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start2, transform2) {
          start2 = nativeMax(start2 === undefined2 ? func.length - 1 : start2, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start2 + index];
            }
            index = -1;
            var otherArgs = Array2(start2 + 1);
            while (++index < start2) {
              otherArgs[index] = args[index];
            }
            otherArgs[start2] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string2) {
          var result2 = [];
          if (string2.charCodeAt(0) === 46) {
            result2.push("");
          }
          string2.replace(rePropName, function(match, number2, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair2) {
            var value = "_." + pair2[0];
            if (bitmask & pair2[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start2, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
            start2 = 0;
            end = length;
          }
          return baseFill(array, value, start2, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten2(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair2 = pairs[index];
            result2[pair2[0]] = pair2[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove2(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start2, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start2, end)) {
            start2 = 0;
            end = length;
          } else {
            start2 = start2 == null ? 0 : toInteger(start2);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start2, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
            return this.thru(interceptor);
          }
          value = value.slice(start2, +start2 + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find2 = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 === undefined2 ? start2 : toInteger(start2);
          return baseRest(func, start2);
        }
        function spread(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
          return baseRest(function(args) {
            var array = args[start2], otherArgs = castSlice(args, 0, start2);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number2, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number2), lower, upper);
        }
        function inRange(number2, start2, end) {
          start2 = toFinite(start2);
          if (end === undefined2) {
            end = start2;
            start2 = 0;
          } else {
            end = toFinite(end);
          }
          number2 = toNumber(number2);
          return baseInRange(number2, start2, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string2) {
          return upperFirst(toString(string2).toLowerCase());
        }
        function deburr(string2) {
          string2 = toString(string2);
          return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string2, target, position) {
          string2 = toString(string2);
          target = baseToString(target);
          var length = string2.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string2.slice(position, end) == target;
        }
        function escape(string2) {
          string2 = toString(string2);
          return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
        }
        function escapeRegExp(string2) {
          string2 = toString(string2);
          return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          if (!length || strLength >= length) {
            return string2;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
        }
        function padStart(string2, length, chars) {
          string2 = toString(string2);
          length = toInteger(length);
          var strLength = length ? stringSize(string2) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
        }
        function parseInt2(string2, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string2).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string2, n, guard) {
          if (guard ? isIterateeCall(string2, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string2), n);
        }
        function replace() {
          var args = arguments, string2 = toString(args[0]);
          return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string2, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string2 = toString(string2);
          if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string2)) {
              return castSlice(stringToArray(string2), 0, limit);
            }
          }
          return string2.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string2, target, position) {
          string2 = toString(string2);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
          target = baseToString(target);
          return string2.slice(position, position + target.length) == target;
        }
        function template(string2, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string2, options, guard)) {
            options = undefined2;
          }
          string2 = toString(string2);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string2.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string2, chars, guard) {
          string2 = toString(string2);
          if (string2 && (guard || chars === undefined2)) {
            return baseTrim(string2);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start2, end).join("");
        }
        function trimEnd(string2, chars, guard) {
          string2 = toString(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.slice(0, trimmedEndIndex(string2) + 1);
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string2, chars, guard) {
          string2 = toString(string2);
          if (string2 && (guard || chars === undefined2)) {
            return string2.replace(reTrimStart, "");
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), start2 = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start2).join("");
        }
        function truncate(string2, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string2 = toString(string2);
          var strLength = string2.length;
          if (hasUnicode(string2)) {
            var strSymbols = stringToArray(string2);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string2;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string2.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string2.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string2) {
          string2 = toString(string2);
          return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string2, pattern, guard) {
          string2 = toString(string2);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
          }
          return string2.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair2) {
            if (typeof pair2[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair2[0]), pair2[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair2 = pairs[index];
              if (apply(pair2[0], this, args)) {
                return apply(pair2[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults2;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten2;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove2;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find2;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString2;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start2, end) {
          start2 = toInteger(start2);
          var result2 = this;
          if (result2.__filtered__ && (start2 > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start2 < 0) {
            result2 = result2.takeRight(-start2);
          } else if (start2) {
            result2 = result2.drop(start2);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _4 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _4;
        define(function() {
          return _4;
        });
      } else if (freeModule) {
        (freeModule.exports = _4)._ = _4;
        freeExports._ = _4;
      } else {
        root._ = _4;
      }
    }).call(exports);
  }
});

// node_modules/reactex/node_modules/katex/dist/katex.js
var require_katex = __commonJS({
  "node_modules/reactex/node_modules/katex/dist/katex.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["katex"] = factory();
      else
        root["katex"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return function() {
        "use strict";
        var __webpack_require__ = {};
        !function() {
          __webpack_require__.d = function(exports2, definition) {
            for (var key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        }();
        !function() {
          __webpack_require__.o = function(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          };
        }();
        var __webpack_exports__ = {};
        __webpack_require__.d(__webpack_exports__, {
          "default": function() {
            return katex_webpack;
          }
        });
        ;
        var ParseError = function ParseError2(message, token) {
          this.position = void 0;
          var error = "KaTeX parse error: " + message;
          var start2;
          var loc = token && token.loc;
          if (loc && loc.start <= loc.end) {
            var input = loc.lexer.input;
            start2 = loc.start;
            var end = loc.end;
            if (start2 === input.length) {
              error += " at end of input: ";
            } else {
              error += " at position " + (start2 + 1) + ": ";
            }
            var underlined = input.slice(start2, end).replace(/[^]/g, "$&\u0332");
            var left;
            if (start2 > 15) {
              left = "\u2026" + input.slice(start2 - 15, start2);
            } else {
              left = input.slice(0, start2);
            }
            var right;
            if (end + 15 < input.length) {
              right = input.slice(end, end + 15) + "\u2026";
            } else {
              right = input.slice(end);
            }
            error += left + underlined + right;
          }
          var self2 = new Error(error);
          self2.name = "ParseError";
          self2.__proto__ = ParseError2.prototype;
          self2.position = start2;
          return self2;
        };
        ParseError.prototype.__proto__ = Error.prototype;
        var src_ParseError = ParseError;
        ;
        var contains2 = function contains3(list, elem) {
          return list.indexOf(elem) !== -1;
        };
        var deflt = function deflt2(setting, defaultIfUndefined) {
          return setting === void 0 ? defaultIfUndefined : setting;
        };
        var uppercase = /([A-Z])/g;
        var hyphenate = function hyphenate2(str) {
          return str.replace(uppercase, "-$1").toLowerCase();
        };
        var ESCAPE_LOOKUP = {
          "&": "&amp;",
          ">": "&gt;",
          "<": "&lt;",
          '"': "&quot;",
          "'": "&#x27;"
        };
        var ESCAPE_REGEX = /[&><"']/g;
        function utils_escape(text) {
          return String(text).replace(ESCAPE_REGEX, function(match) {
            return ESCAPE_LOOKUP[match];
          });
        }
        var getBaseElem = function getBaseElem2(group) {
          if (group.type === "ordgroup") {
            if (group.body.length === 1) {
              return getBaseElem2(group.body[0]);
            } else {
              return group;
            }
          } else if (group.type === "color") {
            if (group.body.length === 1) {
              return getBaseElem2(group.body[0]);
            } else {
              return group;
            }
          } else if (group.type === "font") {
            return getBaseElem2(group.body);
          } else {
            return group;
          }
        };
        var isCharacterBox = function isCharacterBox2(group) {
          var baseElem = getBaseElem(group);
          return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
        };
        var assert = function assert2(value) {
          if (!value) {
            throw new Error("Expected non-null, but got " + String(value));
          }
          return value;
        };
        var protocolFromUrl = function protocolFromUrl2(url) {
          var protocol = /^\s*([^\\/#]*?)(?::|&#0*58|&#x0*3a)/i.exec(url);
          return protocol != null ? protocol[1] : "_relative";
        };
        var utils = {
          contains: contains2,
          deflt,
          escape: utils_escape,
          hyphenate,
          getBaseElem,
          isCharacterBox,
          protocolFromUrl
        };
        ;
        var Settings = /* @__PURE__ */ function() {
          function Settings2(options) {
            this.displayMode = void 0;
            this.output = void 0;
            this.leqno = void 0;
            this.fleqn = void 0;
            this.throwOnError = void 0;
            this.errorColor = void 0;
            this.macros = void 0;
            this.minRuleThickness = void 0;
            this.colorIsTextColor = void 0;
            this.strict = void 0;
            this.trust = void 0;
            this.maxSize = void 0;
            this.maxExpand = void 0;
            this.globalGroup = void 0;
            options = options || {};
            this.displayMode = utils.deflt(options.displayMode, false);
            this.output = utils.deflt(options.output, "htmlAndMathml");
            this.leqno = utils.deflt(options.leqno, false);
            this.fleqn = utils.deflt(options.fleqn, false);
            this.throwOnError = utils.deflt(options.throwOnError, true);
            this.errorColor = utils.deflt(options.errorColor, "#cc0000");
            this.macros = options.macros || {};
            this.minRuleThickness = Math.max(0, utils.deflt(options.minRuleThickness, 0));
            this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);
            this.strict = utils.deflt(options.strict, "warn");
            this.trust = utils.deflt(options.trust, false);
            this.maxSize = Math.max(0, utils.deflt(options.maxSize, Infinity));
            this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1e3));
            this.globalGroup = utils.deflt(options.globalGroup, false);
          }
          var _proto = Settings2.prototype;
          _proto.reportNonstrict = function reportNonstrict(errorCode, errorMsg, token) {
            var strict = this.strict;
            if (typeof strict === "function") {
              strict = strict(errorCode, errorMsg, token);
            }
            if (!strict || strict === "ignore") {
              return;
            } else if (strict === true || strict === "error") {
              throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
            } else if (strict === "warn") {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
            } else {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
            }
          };
          _proto.useStrictBehavior = function useStrictBehavior(errorCode, errorMsg, token) {
            var strict = this.strict;
            if (typeof strict === "function") {
              try {
                strict = strict(errorCode, errorMsg, token);
              } catch (error) {
                strict = "error";
              }
            }
            if (!strict || strict === "ignore") {
              return false;
            } else if (strict === true || strict === "error") {
              return true;
            } else if (strict === "warn") {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
              return false;
            } else {
              typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
              return false;
            }
          };
          _proto.isTrusted = function isTrusted(context) {
            if (context.url && !context.protocol) {
              context.protocol = utils.protocolFromUrl(context.url);
            }
            var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
            return Boolean(trust);
          };
          return Settings2;
        }();
        ;
        var Style = /* @__PURE__ */ function() {
          function Style2(id, size, cramped) {
            this.id = void 0;
            this.size = void 0;
            this.cramped = void 0;
            this.id = id;
            this.size = size;
            this.cramped = cramped;
          }
          var _proto = Style2.prototype;
          _proto.sup = function sup() {
            return styles[_sup[this.id]];
          };
          _proto.sub = function sub() {
            return styles[_sub[this.id]];
          };
          _proto.fracNum = function fracNum() {
            return styles[_fracNum[this.id]];
          };
          _proto.fracDen = function fracDen() {
            return styles[_fracDen[this.id]];
          };
          _proto.cramp = function cramp() {
            return styles[_cramp[this.id]];
          };
          _proto.text = function text() {
            return styles[_text[this.id]];
          };
          _proto.isTight = function isTight() {
            return this.size >= 2;
          };
          return Style2;
        }();
        var D = 0;
        var Dc = 1;
        var T = 2;
        var Tc = 3;
        var S = 4;
        var Sc = 5;
        var SS = 6;
        var SSc = 7;
        var styles = [new Style(D, 0, false), new Style(Dc, 0, true), new Style(T, 1, false), new Style(Tc, 1, true), new Style(S, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
        var _sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
        var _sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
        var _fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
        var _fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
        var _cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
        var _text = [D, Dc, T, Tc, T, Tc, T, Tc];
        var src_Style = {
          DISPLAY: styles[D],
          TEXT: styles[T],
          SCRIPT: styles[S],
          SCRIPTSCRIPT: styles[SS]
        };
        ;
        var scriptData = [{
          name: "latin",
          blocks: [
            [256, 591],
            [768, 879]
          ]
        }, {
          name: "cyrillic",
          blocks: [[1024, 1279]]
        }, {
          name: "armenian",
          blocks: [[1328, 1423]]
        }, {
          name: "brahmic",
          blocks: [[2304, 4255]]
        }, {
          name: "georgian",
          blocks: [[4256, 4351]]
        }, {
          name: "cjk",
          blocks: [
            [12288, 12543],
            [19968, 40879],
            [65280, 65376]
          ]
        }, {
          name: "hangul",
          blocks: [[44032, 55215]]
        }];
        function scriptFromCodepoint(codepoint) {
          for (var i2 = 0; i2 < scriptData.length; i2++) {
            var script = scriptData[i2];
            for (var _i6 = 0; _i6 < script.blocks.length; _i6++) {
              var block = script.blocks[_i6];
              if (codepoint >= block[0] && codepoint <= block[1]) {
                return script.name;
              }
            }
          }
          return null;
        }
        var allBlocks = [];
        scriptData.forEach(function(s) {
          return s.blocks.forEach(function(b) {
            return allBlocks.push.apply(allBlocks, b);
          });
        });
        function supportedCodepoint(codepoint) {
          for (var i2 = 0; i2 < allBlocks.length; i2 += 2) {
            if (codepoint >= allBlocks[i2] && codepoint <= allBlocks[i2 + 1]) {
              return true;
            }
          }
          return false;
        }
        ;
        var hLinePad = 80;
        var sqrtMain = function sqrtMain2(extraViniculum, hLinePad2) {
          return "M95," + (622 + extraViniculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraViniculum / 2.075 + " -" + extraViniculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraViniculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
        };
        var sqrtSize1 = function sqrtSize12(extraViniculum, hLinePad2) {
          return "M263," + (601 + extraViniculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraViniculum / 2.084 + " -" + extraViniculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraViniculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
        };
        var sqrtSize2 = function sqrtSize22(extraViniculum, hLinePad2) {
          return "M983 " + (10 + extraViniculum + hLinePad2) + "\nl" + extraViniculum / 3.13 + " -" + extraViniculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraViniculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "h-400000z";
        };
        var sqrtSize3 = function sqrtSize32(extraViniculum, hLinePad2) {
          return "M424," + (2398 + extraViniculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraViniculum / 4.223 + " -" + extraViniculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraViniculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraViniculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraViniculum) + "h-400000z";
        };
        var sqrtSize4 = function sqrtSize42(extraViniculum, hLinePad2) {
          return "M473," + (2713 + extraViniculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraViniculum / 5.298 + " -" + extraViniculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraViniculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraViniculum) + " " + hLinePad2 + "h400000v" + (40 + extraViniculum) + "H1017.7z";
        };
        var phasePath = function phasePath2(y) {
          var x = y / 2;
          return "M400000 " + y + " H0 L" + x + " 0 l65 45 L145 " + (y - 80) + " H400000z";
        };
        var sqrtTall = function sqrtTall2(extraViniculum, hLinePad2, viewBoxHeight) {
          var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraViniculum;
          return "M702 " + (extraViniculum + hLinePad2) + "H400000" + (40 + extraViniculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraViniculum) + "H742z";
        };
        var sqrtPath = function sqrtPath2(size, extraViniculum, viewBoxHeight) {
          extraViniculum = 1e3 * extraViniculum;
          var path2 = "";
          switch (size) {
            case "sqrtMain":
              path2 = sqrtMain(extraViniculum, hLinePad);
              break;
            case "sqrtSize1":
              path2 = sqrtSize1(extraViniculum, hLinePad);
              break;
            case "sqrtSize2":
              path2 = sqrtSize2(extraViniculum, hLinePad);
              break;
            case "sqrtSize3":
              path2 = sqrtSize3(extraViniculum, hLinePad);
              break;
            case "sqrtSize4":
              path2 = sqrtSize4(extraViniculum, hLinePad);
              break;
            case "sqrtTall":
              path2 = sqrtTall(extraViniculum, hLinePad, viewBoxHeight);
          }
          return path2;
        };
        var innerPath = function innerPath2(name2, height) {
          switch (name2) {
            case "\u239C":
              return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
            case "\u2223":
              return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
            case "\u2225":
              return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
            case "\u239F":
              return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
            case "\u23A2":
              return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
            case "\u23A5":
              return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
            case "\u23AA":
              return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
            case "\u23D0":
              return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
            case "\u2016":
              return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
            default:
              return "";
          }
        };
        var path = {
          doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
          doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
          leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
          leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
          leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
          leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
          leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
          leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
          leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
          leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
          leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
          lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
          leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
          leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
          leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
          longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
          midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
          midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
          oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
          oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
          oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
          oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
          rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
          rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
          rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
          rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
          rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
          rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
          rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
          rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
          rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
          righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
          rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
          rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
          twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
          twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
          tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
          tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
          tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
          tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
          vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
          widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
          widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
          widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
          widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
          widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
          widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
          widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
          widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
          baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
          rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
          baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
          rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
          shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
          shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
        };
        ;
        var DocumentFragment = /* @__PURE__ */ function() {
          function DocumentFragment2(children) {
            this.children = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            this.children = children;
            this.classes = [];
            this.height = 0;
            this.depth = 0;
            this.maxFontSize = 0;
            this.style = {};
          }
          var _proto = DocumentFragment2.prototype;
          _proto.hasClass = function hasClass(className) {
            return utils.contains(this.classes, className);
          };
          _proto.toNode = function toNode() {
            var frag = document.createDocumentFragment();
            for (var i2 = 0; i2 < this.children.length; i2++) {
              frag.appendChild(this.children[i2].toNode());
            }
            return frag;
          };
          _proto.toMarkup = function toMarkup() {
            var markup = "";
            for (var i2 = 0; i2 < this.children.length; i2++) {
              markup += this.children[i2].toMarkup();
            }
            return markup;
          };
          _proto.toText = function toText() {
            var toText2 = function toText3(child) {
              return child.toText();
            };
            return this.children.map(toText2).join("");
          };
          return DocumentFragment2;
        }();
        ;
        var createClass = function createClass2(classes) {
          return classes.filter(function(cls) {
            return cls;
          }).join(" ");
        };
        var initNode = function initNode2(classes, options, style) {
          this.classes = classes || [];
          this.attributes = {};
          this.height = 0;
          this.depth = 0;
          this.maxFontSize = 0;
          this.style = style || {};
          if (options) {
            if (options.style.isTight()) {
              this.classes.push("mtight");
            }
            var color = options.getColor();
            if (color) {
              this.style.color = color;
            }
          }
        };
        var _toNode = function toNode(tagName) {
          var node = document.createElement(tagName);
          node.className = createClass(this.classes);
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              node.style[style] = this.style[style];
            }
          }
          for (var attr in this.attributes) {
            if (this.attributes.hasOwnProperty(attr)) {
              node.setAttribute(attr, this.attributes[attr]);
            }
          }
          for (var i2 = 0; i2 < this.children.length; i2++) {
            node.appendChild(this.children[i2].toNode());
          }
          return node;
        };
        var _toMarkup = function toMarkup(tagName) {
          var markup = "<" + tagName;
          if (this.classes.length) {
            markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
          }
          var styles2 = "";
          for (var style in this.style) {
            if (this.style.hasOwnProperty(style)) {
              styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
            }
          }
          if (styles2) {
            markup += ' style="' + utils.escape(styles2) + '"';
          }
          for (var attr in this.attributes) {
            if (this.attributes.hasOwnProperty(attr)) {
              markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
            }
          }
          markup += ">";
          for (var i2 = 0; i2 < this.children.length; i2++) {
            markup += this.children[i2].toMarkup();
          }
          markup += "</" + tagName + ">";
          return markup;
        };
        var Span = /* @__PURE__ */ function() {
          function Span2(classes, children, options, style) {
            this.children = void 0;
            this.attributes = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.width = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            initNode.call(this, classes, options, style);
            this.children = children || [];
          }
          var _proto = Span2.prototype;
          _proto.setAttribute = function setAttribute(attribute, value) {
            this.attributes[attribute] = value;
          };
          _proto.hasClass = function hasClass(className) {
            return utils.contains(this.classes, className);
          };
          _proto.toNode = function toNode() {
            return _toNode.call(this, "span");
          };
          _proto.toMarkup = function toMarkup() {
            return _toMarkup.call(this, "span");
          };
          return Span2;
        }();
        var Anchor = /* @__PURE__ */ function() {
          function Anchor2(href, classes, children, options) {
            this.children = void 0;
            this.attributes = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            initNode.call(this, classes, options);
            this.children = children || [];
            this.setAttribute("href", href);
          }
          var _proto2 = Anchor2.prototype;
          _proto2.setAttribute = function setAttribute(attribute, value) {
            this.attributes[attribute] = value;
          };
          _proto2.hasClass = function hasClass(className) {
            return utils.contains(this.classes, className);
          };
          _proto2.toNode = function toNode() {
            return _toNode.call(this, "a");
          };
          _proto2.toMarkup = function toMarkup() {
            return _toMarkup.call(this, "a");
          };
          return Anchor2;
        }();
        var Img = /* @__PURE__ */ function() {
          function Img2(src, alt, style) {
            this.src = void 0;
            this.alt = void 0;
            this.classes = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.maxFontSize = void 0;
            this.style = void 0;
            this.alt = alt;
            this.src = src;
            this.classes = ["mord"];
            this.style = style;
          }
          var _proto3 = Img2.prototype;
          _proto3.hasClass = function hasClass(className) {
            return utils.contains(this.classes, className);
          };
          _proto3.toNode = function toNode() {
            var node = document.createElement("img");
            node.src = this.src;
            node.alt = this.alt;
            node.className = "mord";
            for (var style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                node.style[style] = this.style[style];
              }
            }
            return node;
          };
          _proto3.toMarkup = function toMarkup() {
            var markup = "<img  src='" + this.src + " 'alt='" + this.alt + "' ";
            var styles2 = "";
            for (var style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
              }
            }
            if (styles2) {
              markup += ' style="' + utils.escape(styles2) + '"';
            }
            markup += "'/>";
            return markup;
          };
          return Img2;
        }();
        var iCombinations = {
          "\xEE": "\u0131\u0302",
          "\xEF": "\u0131\u0308",
          "\xED": "\u0131\u0301",
          "\xEC": "\u0131\u0300"
        };
        var SymbolNode = /* @__PURE__ */ function() {
          function SymbolNode2(text, height, depth, italic, skew, width, classes, style) {
            this.text = void 0;
            this.height = void 0;
            this.depth = void 0;
            this.italic = void 0;
            this.skew = void 0;
            this.width = void 0;
            this.maxFontSize = void 0;
            this.classes = void 0;
            this.style = void 0;
            this.text = text;
            this.height = height || 0;
            this.depth = depth || 0;
            this.italic = italic || 0;
            this.skew = skew || 0;
            this.width = width || 0;
            this.classes = classes || [];
            this.style = style || {};
            this.maxFontSize = 0;
            var script = scriptFromCodepoint(this.text.charCodeAt(0));
            if (script) {
              this.classes.push(script + "_fallback");
            }
            if (/[]/.test(this.text)) {
              this.text = iCombinations[this.text];
            }
          }
          var _proto4 = SymbolNode2.prototype;
          _proto4.hasClass = function hasClass(className) {
            return utils.contains(this.classes, className);
          };
          _proto4.toNode = function toNode() {
            var node = document.createTextNode(this.text);
            var span = null;
            if (this.italic > 0) {
              span = document.createElement("span");
              span.style.marginRight = this.italic + "em";
            }
            if (this.classes.length > 0) {
              span = span || document.createElement("span");
              span.className = createClass(this.classes);
            }
            for (var style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                span = span || document.createElement("span");
                span.style[style] = this.style[style];
              }
            }
            if (span) {
              span.appendChild(node);
              return span;
            } else {
              return node;
            }
          };
          _proto4.toMarkup = function toMarkup() {
            var needsSpan = false;
            var markup = "<span";
            if (this.classes.length) {
              needsSpan = true;
              markup += ' class="';
              markup += utils.escape(createClass(this.classes));
              markup += '"';
            }
            var styles2 = "";
            if (this.italic > 0) {
              styles2 += "margin-right:" + this.italic + "em;";
            }
            for (var style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
              }
            }
            if (styles2) {
              needsSpan = true;
              markup += ' style="' + utils.escape(styles2) + '"';
            }
            var escaped = utils.escape(this.text);
            if (needsSpan) {
              markup += ">";
              markup += escaped;
              markup += "</span>";
              return markup;
            } else {
              return escaped;
            }
          };
          return SymbolNode2;
        }();
        var SvgNode = /* @__PURE__ */ function() {
          function SvgNode2(children, attributes) {
            this.children = void 0;
            this.attributes = void 0;
            this.children = children || [];
            this.attributes = attributes || {};
          }
          var _proto5 = SvgNode2.prototype;
          _proto5.toNode = function toNode() {
            var svgNS = "http://www.w3.org/2000/svg";
            var node = document.createElementNS(svgNS, "svg");
            for (var attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                node.setAttribute(attr, this.attributes[attr]);
              }
            }
            for (var i2 = 0; i2 < this.children.length; i2++) {
              node.appendChild(this.children[i2].toNode());
            }
            return node;
          };
          _proto5.toMarkup = function toMarkup() {
            var markup = "<svg";
            for (var attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                markup += " " + attr + "='" + this.attributes[attr] + "'";
              }
            }
            markup += ">";
            for (var i2 = 0; i2 < this.children.length; i2++) {
              markup += this.children[i2].toMarkup();
            }
            markup += "</svg>";
            return markup;
          };
          return SvgNode2;
        }();
        var PathNode = /* @__PURE__ */ function() {
          function PathNode2(pathName, alternate) {
            this.pathName = void 0;
            this.alternate = void 0;
            this.pathName = pathName;
            this.alternate = alternate;
          }
          var _proto6 = PathNode2.prototype;
          _proto6.toNode = function toNode() {
            var svgNS = "http://www.w3.org/2000/svg";
            var node = document.createElementNS(svgNS, "path");
            if (this.alternate) {
              node.setAttribute("d", this.alternate);
            } else {
              node.setAttribute("d", path[this.pathName]);
            }
            return node;
          };
          _proto6.toMarkup = function toMarkup() {
            if (this.alternate) {
              return "<path d='" + this.alternate + "'/>";
            } else {
              return "<path d='" + path[this.pathName] + "'/>";
            }
          };
          return PathNode2;
        }();
        var LineNode = /* @__PURE__ */ function() {
          function LineNode2(attributes) {
            this.attributes = void 0;
            this.attributes = attributes || {};
          }
          var _proto7 = LineNode2.prototype;
          _proto7.toNode = function toNode() {
            var svgNS = "http://www.w3.org/2000/svg";
            var node = document.createElementNS(svgNS, "line");
            for (var attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                node.setAttribute(attr, this.attributes[attr]);
              }
            }
            return node;
          };
          _proto7.toMarkup = function toMarkup() {
            var markup = "<line";
            for (var attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                markup += " " + attr + "='" + this.attributes[attr] + "'";
              }
            }
            markup += "/>";
            return markup;
          };
          return LineNode2;
        }();
        function assertSymbolDomNode(group) {
          if (group instanceof SymbolNode) {
            return group;
          } else {
            throw new Error("Expected symbolNode but got " + String(group) + ".");
          }
        }
        function assertSpan(group) {
          if (group instanceof Span) {
            return group;
          } else {
            throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
          }
        }
        ;
        var fontMetricsData = {
          "AMS-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "65": [0, 0.68889, 0, 0, 0.72222],
            "66": [0, 0.68889, 0, 0, 0.66667],
            "67": [0, 0.68889, 0, 0, 0.72222],
            "68": [0, 0.68889, 0, 0, 0.72222],
            "69": [0, 0.68889, 0, 0, 0.66667],
            "70": [0, 0.68889, 0, 0, 0.61111],
            "71": [0, 0.68889, 0, 0, 0.77778],
            "72": [0, 0.68889, 0, 0, 0.77778],
            "73": [0, 0.68889, 0, 0, 0.38889],
            "74": [0.16667, 0.68889, 0, 0, 0.5],
            "75": [0, 0.68889, 0, 0, 0.77778],
            "76": [0, 0.68889, 0, 0, 0.66667],
            "77": [0, 0.68889, 0, 0, 0.94445],
            "78": [0, 0.68889, 0, 0, 0.72222],
            "79": [0.16667, 0.68889, 0, 0, 0.77778],
            "80": [0, 0.68889, 0, 0, 0.61111],
            "81": [0.16667, 0.68889, 0, 0, 0.77778],
            "82": [0, 0.68889, 0, 0, 0.72222],
            "83": [0, 0.68889, 0, 0, 0.55556],
            "84": [0, 0.68889, 0, 0, 0.66667],
            "85": [0, 0.68889, 0, 0, 0.72222],
            "86": [0, 0.68889, 0, 0, 0.72222],
            "87": [0, 0.68889, 0, 0, 1],
            "88": [0, 0.68889, 0, 0, 0.72222],
            "89": [0, 0.68889, 0, 0, 0.72222],
            "90": [0, 0.68889, 0, 0, 0.66667],
            "107": [0, 0.68889, 0, 0, 0.55556],
            "160": [0, 0, 0, 0, 0.25],
            "165": [0, 0.675, 0.025, 0, 0.75],
            "174": [0.15559, 0.69224, 0, 0, 0.94666],
            "240": [0, 0.68889, 0, 0, 0.55556],
            "295": [0, 0.68889, 0, 0, 0.54028],
            "710": [0, 0.825, 0, 0, 2.33334],
            "732": [0, 0.9, 0, 0, 2.33334],
            "770": [0, 0.825, 0, 0, 2.33334],
            "771": [0, 0.9, 0, 0, 2.33334],
            "989": [0.08167, 0.58167, 0, 0, 0.77778],
            "1008": [0, 0.43056, 0.04028, 0, 0.66667],
            "8245": [0, 0.54986, 0, 0, 0.275],
            "8463": [0, 0.68889, 0, 0, 0.54028],
            "8487": [0, 0.68889, 0, 0, 0.72222],
            "8498": [0, 0.68889, 0, 0, 0.55556],
            "8502": [0, 0.68889, 0, 0, 0.66667],
            "8503": [0, 0.68889, 0, 0, 0.44445],
            "8504": [0, 0.68889, 0, 0, 0.66667],
            "8513": [0, 0.68889, 0, 0, 0.63889],
            "8592": [-0.03598, 0.46402, 0, 0, 0.5],
            "8594": [-0.03598, 0.46402, 0, 0, 0.5],
            "8602": [-0.13313, 0.36687, 0, 0, 1],
            "8603": [-0.13313, 0.36687, 0, 0, 1],
            "8606": [0.01354, 0.52239, 0, 0, 1],
            "8608": [0.01354, 0.52239, 0, 0, 1],
            "8610": [0.01354, 0.52239, 0, 0, 1.11111],
            "8611": [0.01354, 0.52239, 0, 0, 1.11111],
            "8619": [0, 0.54986, 0, 0, 1],
            "8620": [0, 0.54986, 0, 0, 1],
            "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
            "8622": [-0.13313, 0.36687, 0, 0, 1],
            "8624": [0, 0.69224, 0, 0, 0.5],
            "8625": [0, 0.69224, 0, 0, 0.5],
            "8630": [0, 0.43056, 0, 0, 1],
            "8631": [0, 0.43056, 0, 0, 1],
            "8634": [0.08198, 0.58198, 0, 0, 0.77778],
            "8635": [0.08198, 0.58198, 0, 0, 0.77778],
            "8638": [0.19444, 0.69224, 0, 0, 0.41667],
            "8639": [0.19444, 0.69224, 0, 0, 0.41667],
            "8642": [0.19444, 0.69224, 0, 0, 0.41667],
            "8643": [0.19444, 0.69224, 0, 0, 0.41667],
            "8644": [0.1808, 0.675, 0, 0, 1],
            "8646": [0.1808, 0.675, 0, 0, 1],
            "8647": [0.1808, 0.675, 0, 0, 1],
            "8648": [0.19444, 0.69224, 0, 0, 0.83334],
            "8649": [0.1808, 0.675, 0, 0, 1],
            "8650": [0.19444, 0.69224, 0, 0, 0.83334],
            "8651": [0.01354, 0.52239, 0, 0, 1],
            "8652": [0.01354, 0.52239, 0, 0, 1],
            "8653": [-0.13313, 0.36687, 0, 0, 1],
            "8654": [-0.13313, 0.36687, 0, 0, 1],
            "8655": [-0.13313, 0.36687, 0, 0, 1],
            "8666": [0.13667, 0.63667, 0, 0, 1],
            "8667": [0.13667, 0.63667, 0, 0, 1],
            "8669": [-0.13313, 0.37788, 0, 0, 1],
            "8672": [-0.064, 0.437, 0, 0, 1.334],
            "8674": [-0.064, 0.437, 0, 0, 1.334],
            "8705": [0, 0.825, 0, 0, 0.5],
            "8708": [0, 0.68889, 0, 0, 0.55556],
            "8709": [0.08167, 0.58167, 0, 0, 0.77778],
            "8717": [0, 0.43056, 0, 0, 0.42917],
            "8722": [-0.03598, 0.46402, 0, 0, 0.5],
            "8724": [0.08198, 0.69224, 0, 0, 0.77778],
            "8726": [0.08167, 0.58167, 0, 0, 0.77778],
            "8733": [0, 0.69224, 0, 0, 0.77778],
            "8736": [0, 0.69224, 0, 0, 0.72222],
            "8737": [0, 0.69224, 0, 0, 0.72222],
            "8738": [0.03517, 0.52239, 0, 0, 0.72222],
            "8739": [0.08167, 0.58167, 0, 0, 0.22222],
            "8740": [0.25142, 0.74111, 0, 0, 0.27778],
            "8741": [0.08167, 0.58167, 0, 0, 0.38889],
            "8742": [0.25142, 0.74111, 0, 0, 0.5],
            "8756": [0, 0.69224, 0, 0, 0.66667],
            "8757": [0, 0.69224, 0, 0, 0.66667],
            "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
            "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
            "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
            "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8774": [0.30274, 0.79383, 0, 0, 0.77778],
            "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
            "8778": [0.08167, 0.58167, 0, 0, 0.77778],
            "8782": [0.06062, 0.54986, 0, 0, 0.77778],
            "8783": [0.06062, 0.54986, 0, 0, 0.77778],
            "8785": [0.08198, 0.58198, 0, 0, 0.77778],
            "8786": [0.08198, 0.58198, 0, 0, 0.77778],
            "8787": [0.08198, 0.58198, 0, 0, 0.77778],
            "8790": [0, 0.69224, 0, 0, 0.77778],
            "8791": [0.22958, 0.72958, 0, 0, 0.77778],
            "8796": [0.08198, 0.91667, 0, 0, 0.77778],
            "8806": [0.25583, 0.75583, 0, 0, 0.77778],
            "8807": [0.25583, 0.75583, 0, 0, 0.77778],
            "8808": [0.25142, 0.75726, 0, 0, 0.77778],
            "8809": [0.25142, 0.75726, 0, 0, 0.77778],
            "8812": [0.25583, 0.75583, 0, 0, 0.5],
            "8814": [0.20576, 0.70576, 0, 0, 0.77778],
            "8815": [0.20576, 0.70576, 0, 0, 0.77778],
            "8816": [0.30274, 0.79383, 0, 0, 0.77778],
            "8817": [0.30274, 0.79383, 0, 0, 0.77778],
            "8818": [0.22958, 0.72958, 0, 0, 0.77778],
            "8819": [0.22958, 0.72958, 0, 0, 0.77778],
            "8822": [0.1808, 0.675, 0, 0, 0.77778],
            "8823": [0.1808, 0.675, 0, 0, 0.77778],
            "8828": [0.13667, 0.63667, 0, 0, 0.77778],
            "8829": [0.13667, 0.63667, 0, 0, 0.77778],
            "8830": [0.22958, 0.72958, 0, 0, 0.77778],
            "8831": [0.22958, 0.72958, 0, 0, 0.77778],
            "8832": [0.20576, 0.70576, 0, 0, 0.77778],
            "8833": [0.20576, 0.70576, 0, 0, 0.77778],
            "8840": [0.30274, 0.79383, 0, 0, 0.77778],
            "8841": [0.30274, 0.79383, 0, 0, 0.77778],
            "8842": [0.13597, 0.63597, 0, 0, 0.77778],
            "8843": [0.13597, 0.63597, 0, 0, 0.77778],
            "8847": [0.03517, 0.54986, 0, 0, 0.77778],
            "8848": [0.03517, 0.54986, 0, 0, 0.77778],
            "8858": [0.08198, 0.58198, 0, 0, 0.77778],
            "8859": [0.08198, 0.58198, 0, 0, 0.77778],
            "8861": [0.08198, 0.58198, 0, 0, 0.77778],
            "8862": [0, 0.675, 0, 0, 0.77778],
            "8863": [0, 0.675, 0, 0, 0.77778],
            "8864": [0, 0.675, 0, 0, 0.77778],
            "8865": [0, 0.675, 0, 0, 0.77778],
            "8872": [0, 0.69224, 0, 0, 0.61111],
            "8873": [0, 0.69224, 0, 0, 0.72222],
            "8874": [0, 0.69224, 0, 0, 0.88889],
            "8876": [0, 0.68889, 0, 0, 0.61111],
            "8877": [0, 0.68889, 0, 0, 0.61111],
            "8878": [0, 0.68889, 0, 0, 0.72222],
            "8879": [0, 0.68889, 0, 0, 0.72222],
            "8882": [0.03517, 0.54986, 0, 0, 0.77778],
            "8883": [0.03517, 0.54986, 0, 0, 0.77778],
            "8884": [0.13667, 0.63667, 0, 0, 0.77778],
            "8885": [0.13667, 0.63667, 0, 0, 0.77778],
            "8888": [0, 0.54986, 0, 0, 1.11111],
            "8890": [0.19444, 0.43056, 0, 0, 0.55556],
            "8891": [0.19444, 0.69224, 0, 0, 0.61111],
            "8892": [0.19444, 0.69224, 0, 0, 0.61111],
            "8901": [0, 0.54986, 0, 0, 0.27778],
            "8903": [0.08167, 0.58167, 0, 0, 0.77778],
            "8905": [0.08167, 0.58167, 0, 0, 0.77778],
            "8906": [0.08167, 0.58167, 0, 0, 0.77778],
            "8907": [0, 0.69224, 0, 0, 0.77778],
            "8908": [0, 0.69224, 0, 0, 0.77778],
            "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
            "8910": [0, 0.54986, 0, 0, 0.76042],
            "8911": [0, 0.54986, 0, 0, 0.76042],
            "8912": [0.03517, 0.54986, 0, 0, 0.77778],
            "8913": [0.03517, 0.54986, 0, 0, 0.77778],
            "8914": [0, 0.54986, 0, 0, 0.66667],
            "8915": [0, 0.54986, 0, 0, 0.66667],
            "8916": [0, 0.69224, 0, 0, 0.66667],
            "8918": [0.0391, 0.5391, 0, 0, 0.77778],
            "8919": [0.0391, 0.5391, 0, 0, 0.77778],
            "8920": [0.03517, 0.54986, 0, 0, 1.33334],
            "8921": [0.03517, 0.54986, 0, 0, 1.33334],
            "8922": [0.38569, 0.88569, 0, 0, 0.77778],
            "8923": [0.38569, 0.88569, 0, 0, 0.77778],
            "8926": [0.13667, 0.63667, 0, 0, 0.77778],
            "8927": [0.13667, 0.63667, 0, 0, 0.77778],
            "8928": [0.30274, 0.79383, 0, 0, 0.77778],
            "8929": [0.30274, 0.79383, 0, 0, 0.77778],
            "8934": [0.23222, 0.74111, 0, 0, 0.77778],
            "8935": [0.23222, 0.74111, 0, 0, 0.77778],
            "8936": [0.23222, 0.74111, 0, 0, 0.77778],
            "8937": [0.23222, 0.74111, 0, 0, 0.77778],
            "8938": [0.20576, 0.70576, 0, 0, 0.77778],
            "8939": [0.20576, 0.70576, 0, 0, 0.77778],
            "8940": [0.30274, 0.79383, 0, 0, 0.77778],
            "8941": [0.30274, 0.79383, 0, 0, 0.77778],
            "8994": [0.19444, 0.69224, 0, 0, 0.77778],
            "8995": [0.19444, 0.69224, 0, 0, 0.77778],
            "9416": [0.15559, 0.69224, 0, 0, 0.90222],
            "9484": [0, 0.69224, 0, 0, 0.5],
            "9488": [0, 0.69224, 0, 0, 0.5],
            "9492": [0, 0.37788, 0, 0, 0.5],
            "9496": [0, 0.37788, 0, 0, 0.5],
            "9585": [0.19444, 0.68889, 0, 0, 0.88889],
            "9586": [0.19444, 0.74111, 0, 0, 0.88889],
            "9632": [0, 0.675, 0, 0, 0.77778],
            "9633": [0, 0.675, 0, 0, 0.77778],
            "9650": [0, 0.54986, 0, 0, 0.72222],
            "9651": [0, 0.54986, 0, 0, 0.72222],
            "9654": [0.03517, 0.54986, 0, 0, 0.77778],
            "9660": [0, 0.54986, 0, 0, 0.72222],
            "9661": [0, 0.54986, 0, 0, 0.72222],
            "9664": [0.03517, 0.54986, 0, 0, 0.77778],
            "9674": [0.11111, 0.69224, 0, 0, 0.66667],
            "9733": [0.19444, 0.69224, 0, 0, 0.94445],
            "10003": [0, 0.69224, 0, 0, 0.83334],
            "10016": [0, 0.69224, 0, 0, 0.83334],
            "10731": [0.11111, 0.69224, 0, 0, 0.66667],
            "10846": [0.19444, 0.75583, 0, 0, 0.61111],
            "10877": [0.13667, 0.63667, 0, 0, 0.77778],
            "10878": [0.13667, 0.63667, 0, 0, 0.77778],
            "10885": [0.25583, 0.75583, 0, 0, 0.77778],
            "10886": [0.25583, 0.75583, 0, 0, 0.77778],
            "10887": [0.13597, 0.63597, 0, 0, 0.77778],
            "10888": [0.13597, 0.63597, 0, 0, 0.77778],
            "10889": [0.26167, 0.75726, 0, 0, 0.77778],
            "10890": [0.26167, 0.75726, 0, 0, 0.77778],
            "10891": [0.48256, 0.98256, 0, 0, 0.77778],
            "10892": [0.48256, 0.98256, 0, 0, 0.77778],
            "10901": [0.13667, 0.63667, 0, 0, 0.77778],
            "10902": [0.13667, 0.63667, 0, 0, 0.77778],
            "10933": [0.25142, 0.75726, 0, 0, 0.77778],
            "10934": [0.25142, 0.75726, 0, 0, 0.77778],
            "10935": [0.26167, 0.75726, 0, 0, 0.77778],
            "10936": [0.26167, 0.75726, 0, 0, 0.77778],
            "10937": [0.26167, 0.75726, 0, 0, 0.77778],
            "10938": [0.26167, 0.75726, 0, 0, 0.77778],
            "10949": [0.25583, 0.75583, 0, 0, 0.77778],
            "10950": [0.25583, 0.75583, 0, 0, 0.77778],
            "10955": [0.28481, 0.79383, 0, 0, 0.77778],
            "10956": [0.28481, 0.79383, 0, 0, 0.77778],
            "57350": [0.08167, 0.58167, 0, 0, 0.22222],
            "57351": [0.08167, 0.58167, 0, 0, 0.38889],
            "57352": [0.08167, 0.58167, 0, 0, 0.77778],
            "57353": [0, 0.43056, 0.04028, 0, 0.66667],
            "57356": [0.25142, 0.75726, 0, 0, 0.77778],
            "57357": [0.25142, 0.75726, 0, 0, 0.77778],
            "57358": [0.41951, 0.91951, 0, 0, 0.77778],
            "57359": [0.30274, 0.79383, 0, 0, 0.77778],
            "57360": [0.30274, 0.79383, 0, 0, 0.77778],
            "57361": [0.41951, 0.91951, 0, 0, 0.77778],
            "57366": [0.25142, 0.75726, 0, 0, 0.77778],
            "57367": [0.25142, 0.75726, 0, 0, 0.77778],
            "57368": [0.25142, 0.75726, 0, 0, 0.77778],
            "57369": [0.25142, 0.75726, 0, 0, 0.77778],
            "57370": [0.13597, 0.63597, 0, 0, 0.77778],
            "57371": [0.13597, 0.63597, 0, 0, 0.77778]
          },
          "Caligraphic-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "65": [0, 0.68333, 0, 0.19445, 0.79847],
            "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
            "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
            "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
            "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
            "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
            "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
            "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
            "73": [0, 0.68333, 0.07382, 0, 0.54452],
            "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
            "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
            "76": [0, 0.68333, 0, 0.13889, 0.68972],
            "77": [0, 0.68333, 0, 0.13889, 1.2009],
            "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
            "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
            "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
            "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
            "82": [0, 0.68333, 0, 0.08334, 0.8475],
            "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
            "84": [0, 0.68333, 0.25417, 0, 0.54464],
            "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
            "86": [0, 0.68333, 0.08222, 0, 0.61278],
            "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
            "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
            "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
            "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
            "160": [0, 0, 0, 0, 0.25]
          },
          "Fraktur-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69141, 0, 0, 0.29574],
            "34": [0, 0.69141, 0, 0, 0.21471],
            "38": [0, 0.69141, 0, 0, 0.73786],
            "39": [0, 0.69141, 0, 0, 0.21201],
            "40": [0.24982, 0.74947, 0, 0, 0.38865],
            "41": [0.24982, 0.74947, 0, 0, 0.38865],
            "42": [0, 0.62119, 0, 0, 0.27764],
            "43": [0.08319, 0.58283, 0, 0, 0.75623],
            "44": [0, 0.10803, 0, 0, 0.27764],
            "45": [0.08319, 0.58283, 0, 0, 0.75623],
            "46": [0, 0.10803, 0, 0, 0.27764],
            "47": [0.24982, 0.74947, 0, 0, 0.50181],
            "48": [0, 0.47534, 0, 0, 0.50181],
            "49": [0, 0.47534, 0, 0, 0.50181],
            "50": [0, 0.47534, 0, 0, 0.50181],
            "51": [0.18906, 0.47534, 0, 0, 0.50181],
            "52": [0.18906, 0.47534, 0, 0, 0.50181],
            "53": [0.18906, 0.47534, 0, 0, 0.50181],
            "54": [0, 0.69141, 0, 0, 0.50181],
            "55": [0.18906, 0.47534, 0, 0, 0.50181],
            "56": [0, 0.69141, 0, 0, 0.50181],
            "57": [0.18906, 0.47534, 0, 0, 0.50181],
            "58": [0, 0.47534, 0, 0, 0.21606],
            "59": [0.12604, 0.47534, 0, 0, 0.21606],
            "61": [-0.13099, 0.36866, 0, 0, 0.75623],
            "63": [0, 0.69141, 0, 0, 0.36245],
            "65": [0, 0.69141, 0, 0, 0.7176],
            "66": [0, 0.69141, 0, 0, 0.88397],
            "67": [0, 0.69141, 0, 0, 0.61254],
            "68": [0, 0.69141, 0, 0, 0.83158],
            "69": [0, 0.69141, 0, 0, 0.66278],
            "70": [0.12604, 0.69141, 0, 0, 0.61119],
            "71": [0, 0.69141, 0, 0, 0.78539],
            "72": [0.06302, 0.69141, 0, 0, 0.7203],
            "73": [0, 0.69141, 0, 0, 0.55448],
            "74": [0.12604, 0.69141, 0, 0, 0.55231],
            "75": [0, 0.69141, 0, 0, 0.66845],
            "76": [0, 0.69141, 0, 0, 0.66602],
            "77": [0, 0.69141, 0, 0, 1.04953],
            "78": [0, 0.69141, 0, 0, 0.83212],
            "79": [0, 0.69141, 0, 0, 0.82699],
            "80": [0.18906, 0.69141, 0, 0, 0.82753],
            "81": [0.03781, 0.69141, 0, 0, 0.82699],
            "82": [0, 0.69141, 0, 0, 0.82807],
            "83": [0, 0.69141, 0, 0, 0.82861],
            "84": [0, 0.69141, 0, 0, 0.66899],
            "85": [0, 0.69141, 0, 0, 0.64576],
            "86": [0, 0.69141, 0, 0, 0.83131],
            "87": [0, 0.69141, 0, 0, 1.04602],
            "88": [0, 0.69141, 0, 0, 0.71922],
            "89": [0.18906, 0.69141, 0, 0, 0.83293],
            "90": [0.12604, 0.69141, 0, 0, 0.60201],
            "91": [0.24982, 0.74947, 0, 0, 0.27764],
            "93": [0.24982, 0.74947, 0, 0, 0.27764],
            "94": [0, 0.69141, 0, 0, 0.49965],
            "97": [0, 0.47534, 0, 0, 0.50046],
            "98": [0, 0.69141, 0, 0, 0.51315],
            "99": [0, 0.47534, 0, 0, 0.38946],
            "100": [0, 0.62119, 0, 0, 0.49857],
            "101": [0, 0.47534, 0, 0, 0.40053],
            "102": [0.18906, 0.69141, 0, 0, 0.32626],
            "103": [0.18906, 0.47534, 0, 0, 0.5037],
            "104": [0.18906, 0.69141, 0, 0, 0.52126],
            "105": [0, 0.69141, 0, 0, 0.27899],
            "106": [0, 0.69141, 0, 0, 0.28088],
            "107": [0, 0.69141, 0, 0, 0.38946],
            "108": [0, 0.69141, 0, 0, 0.27953],
            "109": [0, 0.47534, 0, 0, 0.76676],
            "110": [0, 0.47534, 0, 0, 0.52666],
            "111": [0, 0.47534, 0, 0, 0.48885],
            "112": [0.18906, 0.52396, 0, 0, 0.50046],
            "113": [0.18906, 0.47534, 0, 0, 0.48912],
            "114": [0, 0.47534, 0, 0, 0.38919],
            "115": [0, 0.47534, 0, 0, 0.44266],
            "116": [0, 0.62119, 0, 0, 0.33301],
            "117": [0, 0.47534, 0, 0, 0.5172],
            "118": [0, 0.52396, 0, 0, 0.5118],
            "119": [0, 0.52396, 0, 0, 0.77351],
            "120": [0.18906, 0.47534, 0, 0, 0.38865],
            "121": [0.18906, 0.47534, 0, 0, 0.49884],
            "122": [0.18906, 0.47534, 0, 0, 0.39054],
            "160": [0, 0, 0, 0, 0.25],
            "8216": [0, 0.69141, 0, 0, 0.21471],
            "8217": [0, 0.69141, 0, 0, 0.21471],
            "58112": [0, 0.62119, 0, 0, 0.49749],
            "58113": [0, 0.62119, 0, 0, 0.4983],
            "58114": [0.18906, 0.69141, 0, 0, 0.33328],
            "58115": [0.18906, 0.69141, 0, 0, 0.32923],
            "58116": [0.18906, 0.47534, 0, 0, 0.50343],
            "58117": [0, 0.69141, 0, 0, 0.33301],
            "58118": [0, 0.62119, 0, 0, 0.33409],
            "58119": [0, 0.47534, 0, 0, 0.50073]
          },
          "Main-Bold": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.35],
            "34": [0, 0.69444, 0, 0, 0.60278],
            "35": [0.19444, 0.69444, 0, 0, 0.95833],
            "36": [0.05556, 0.75, 0, 0, 0.575],
            "37": [0.05556, 0.75, 0, 0, 0.95833],
            "38": [0, 0.69444, 0, 0, 0.89444],
            "39": [0, 0.69444, 0, 0, 0.31944],
            "40": [0.25, 0.75, 0, 0, 0.44722],
            "41": [0.25, 0.75, 0, 0, 0.44722],
            "42": [0, 0.75, 0, 0, 0.575],
            "43": [0.13333, 0.63333, 0, 0, 0.89444],
            "44": [0.19444, 0.15556, 0, 0, 0.31944],
            "45": [0, 0.44444, 0, 0, 0.38333],
            "46": [0, 0.15556, 0, 0, 0.31944],
            "47": [0.25, 0.75, 0, 0, 0.575],
            "48": [0, 0.64444, 0, 0, 0.575],
            "49": [0, 0.64444, 0, 0, 0.575],
            "50": [0, 0.64444, 0, 0, 0.575],
            "51": [0, 0.64444, 0, 0, 0.575],
            "52": [0, 0.64444, 0, 0, 0.575],
            "53": [0, 0.64444, 0, 0, 0.575],
            "54": [0, 0.64444, 0, 0, 0.575],
            "55": [0, 0.64444, 0, 0, 0.575],
            "56": [0, 0.64444, 0, 0, 0.575],
            "57": [0, 0.64444, 0, 0, 0.575],
            "58": [0, 0.44444, 0, 0, 0.31944],
            "59": [0.19444, 0.44444, 0, 0, 0.31944],
            "60": [0.08556, 0.58556, 0, 0, 0.89444],
            "61": [-0.10889, 0.39111, 0, 0, 0.89444],
            "62": [0.08556, 0.58556, 0, 0, 0.89444],
            "63": [0, 0.69444, 0, 0, 0.54305],
            "64": [0, 0.69444, 0, 0, 0.89444],
            "65": [0, 0.68611, 0, 0, 0.86944],
            "66": [0, 0.68611, 0, 0, 0.81805],
            "67": [0, 0.68611, 0, 0, 0.83055],
            "68": [0, 0.68611, 0, 0, 0.88194],
            "69": [0, 0.68611, 0, 0, 0.75555],
            "70": [0, 0.68611, 0, 0, 0.72361],
            "71": [0, 0.68611, 0, 0, 0.90416],
            "72": [0, 0.68611, 0, 0, 0.9],
            "73": [0, 0.68611, 0, 0, 0.43611],
            "74": [0, 0.68611, 0, 0, 0.59444],
            "75": [0, 0.68611, 0, 0, 0.90138],
            "76": [0, 0.68611, 0, 0, 0.69166],
            "77": [0, 0.68611, 0, 0, 1.09166],
            "78": [0, 0.68611, 0, 0, 0.9],
            "79": [0, 0.68611, 0, 0, 0.86388],
            "80": [0, 0.68611, 0, 0, 0.78611],
            "81": [0.19444, 0.68611, 0, 0, 0.86388],
            "82": [0, 0.68611, 0, 0, 0.8625],
            "83": [0, 0.68611, 0, 0, 0.63889],
            "84": [0, 0.68611, 0, 0, 0.8],
            "85": [0, 0.68611, 0, 0, 0.88472],
            "86": [0, 0.68611, 0.01597, 0, 0.86944],
            "87": [0, 0.68611, 0.01597, 0, 1.18888],
            "88": [0, 0.68611, 0, 0, 0.86944],
            "89": [0, 0.68611, 0.02875, 0, 0.86944],
            "90": [0, 0.68611, 0, 0, 0.70277],
            "91": [0.25, 0.75, 0, 0, 0.31944],
            "92": [0.25, 0.75, 0, 0, 0.575],
            "93": [0.25, 0.75, 0, 0, 0.31944],
            "94": [0, 0.69444, 0, 0, 0.575],
            "95": [0.31, 0.13444, 0.03194, 0, 0.575],
            "97": [0, 0.44444, 0, 0, 0.55902],
            "98": [0, 0.69444, 0, 0, 0.63889],
            "99": [0, 0.44444, 0, 0, 0.51111],
            "100": [0, 0.69444, 0, 0, 0.63889],
            "101": [0, 0.44444, 0, 0, 0.52708],
            "102": [0, 0.69444, 0.10903, 0, 0.35139],
            "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
            "104": [0, 0.69444, 0, 0, 0.63889],
            "105": [0, 0.69444, 0, 0, 0.31944],
            "106": [0.19444, 0.69444, 0, 0, 0.35139],
            "107": [0, 0.69444, 0, 0, 0.60694],
            "108": [0, 0.69444, 0, 0, 0.31944],
            "109": [0, 0.44444, 0, 0, 0.95833],
            "110": [0, 0.44444, 0, 0, 0.63889],
            "111": [0, 0.44444, 0, 0, 0.575],
            "112": [0.19444, 0.44444, 0, 0, 0.63889],
            "113": [0.19444, 0.44444, 0, 0, 0.60694],
            "114": [0, 0.44444, 0, 0, 0.47361],
            "115": [0, 0.44444, 0, 0, 0.45361],
            "116": [0, 0.63492, 0, 0, 0.44722],
            "117": [0, 0.44444, 0, 0, 0.63889],
            "118": [0, 0.44444, 0.01597, 0, 0.60694],
            "119": [0, 0.44444, 0.01597, 0, 0.83055],
            "120": [0, 0.44444, 0, 0, 0.60694],
            "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
            "122": [0, 0.44444, 0, 0, 0.51111],
            "123": [0.25, 0.75, 0, 0, 0.575],
            "124": [0.25, 0.75, 0, 0, 0.31944],
            "125": [0.25, 0.75, 0, 0, 0.575],
            "126": [0.35, 0.34444, 0, 0, 0.575],
            "160": [0, 0, 0, 0, 0.25],
            "163": [0, 0.69444, 0, 0, 0.86853],
            "168": [0, 0.69444, 0, 0, 0.575],
            "172": [0, 0.44444, 0, 0, 0.76666],
            "176": [0, 0.69444, 0, 0, 0.86944],
            "177": [0.13333, 0.63333, 0, 0, 0.89444],
            "184": [0.17014, 0, 0, 0, 0.51111],
            "198": [0, 0.68611, 0, 0, 1.04166],
            "215": [0.13333, 0.63333, 0, 0, 0.89444],
            "216": [0.04861, 0.73472, 0, 0, 0.89444],
            "223": [0, 0.69444, 0, 0, 0.59722],
            "230": [0, 0.44444, 0, 0, 0.83055],
            "247": [0.13333, 0.63333, 0, 0, 0.89444],
            "248": [0.09722, 0.54167, 0, 0, 0.575],
            "305": [0, 0.44444, 0, 0, 0.31944],
            "338": [0, 0.68611, 0, 0, 1.16944],
            "339": [0, 0.44444, 0, 0, 0.89444],
            "567": [0.19444, 0.44444, 0, 0, 0.35139],
            "710": [0, 0.69444, 0, 0, 0.575],
            "711": [0, 0.63194, 0, 0, 0.575],
            "713": [0, 0.59611, 0, 0, 0.575],
            "714": [0, 0.69444, 0, 0, 0.575],
            "715": [0, 0.69444, 0, 0, 0.575],
            "728": [0, 0.69444, 0, 0, 0.575],
            "729": [0, 0.69444, 0, 0, 0.31944],
            "730": [0, 0.69444, 0, 0, 0.86944],
            "732": [0, 0.69444, 0, 0, 0.575],
            "733": [0, 0.69444, 0, 0, 0.575],
            "915": [0, 0.68611, 0, 0, 0.69166],
            "916": [0, 0.68611, 0, 0, 0.95833],
            "920": [0, 0.68611, 0, 0, 0.89444],
            "923": [0, 0.68611, 0, 0, 0.80555],
            "926": [0, 0.68611, 0, 0, 0.76666],
            "928": [0, 0.68611, 0, 0, 0.9],
            "931": [0, 0.68611, 0, 0, 0.83055],
            "933": [0, 0.68611, 0, 0, 0.89444],
            "934": [0, 0.68611, 0, 0, 0.83055],
            "936": [0, 0.68611, 0, 0, 0.89444],
            "937": [0, 0.68611, 0, 0, 0.83055],
            "8211": [0, 0.44444, 0.03194, 0, 0.575],
            "8212": [0, 0.44444, 0.03194, 0, 1.14999],
            "8216": [0, 0.69444, 0, 0, 0.31944],
            "8217": [0, 0.69444, 0, 0, 0.31944],
            "8220": [0, 0.69444, 0, 0, 0.60278],
            "8221": [0, 0.69444, 0, 0, 0.60278],
            "8224": [0.19444, 0.69444, 0, 0, 0.51111],
            "8225": [0.19444, 0.69444, 0, 0, 0.51111],
            "8242": [0, 0.55556, 0, 0, 0.34444],
            "8407": [0, 0.72444, 0.15486, 0, 0.575],
            "8463": [0, 0.69444, 0, 0, 0.66759],
            "8465": [0, 0.69444, 0, 0, 0.83055],
            "8467": [0, 0.69444, 0, 0, 0.47361],
            "8472": [0.19444, 0.44444, 0, 0, 0.74027],
            "8476": [0, 0.69444, 0, 0, 0.83055],
            "8501": [0, 0.69444, 0, 0, 0.70277],
            "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8593": [0.19444, 0.69444, 0, 0, 0.575],
            "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8595": [0.19444, 0.69444, 0, 0, 0.575],
            "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8597": [0.25, 0.75, 0, 0, 0.575],
            "8598": [0.19444, 0.69444, 0, 0, 1.14999],
            "8599": [0.19444, 0.69444, 0, 0, 1.14999],
            "8600": [0.19444, 0.69444, 0, 0, 1.14999],
            "8601": [0.19444, 0.69444, 0, 0, 1.14999],
            "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8657": [0.19444, 0.69444, 0, 0, 0.70277],
            "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8659": [0.19444, 0.69444, 0, 0, 0.70277],
            "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
            "8661": [0.25, 0.75, 0, 0, 0.70277],
            "8704": [0, 0.69444, 0, 0, 0.63889],
            "8706": [0, 0.69444, 0.06389, 0, 0.62847],
            "8707": [0, 0.69444, 0, 0, 0.63889],
            "8709": [0.05556, 0.75, 0, 0, 0.575],
            "8711": [0, 0.68611, 0, 0, 0.95833],
            "8712": [0.08556, 0.58556, 0, 0, 0.76666],
            "8715": [0.08556, 0.58556, 0, 0, 0.76666],
            "8722": [0.13333, 0.63333, 0, 0, 0.89444],
            "8723": [0.13333, 0.63333, 0, 0, 0.89444],
            "8725": [0.25, 0.75, 0, 0, 0.575],
            "8726": [0.25, 0.75, 0, 0, 0.575],
            "8727": [-0.02778, 0.47222, 0, 0, 0.575],
            "8728": [-0.02639, 0.47361, 0, 0, 0.575],
            "8729": [-0.02639, 0.47361, 0, 0, 0.575],
            "8730": [0.18, 0.82, 0, 0, 0.95833],
            "8733": [0, 0.44444, 0, 0, 0.89444],
            "8734": [0, 0.44444, 0, 0, 1.14999],
            "8736": [0, 0.69224, 0, 0, 0.72222],
            "8739": [0.25, 0.75, 0, 0, 0.31944],
            "8741": [0.25, 0.75, 0, 0, 0.575],
            "8743": [0, 0.55556, 0, 0, 0.76666],
            "8744": [0, 0.55556, 0, 0, 0.76666],
            "8745": [0, 0.55556, 0, 0, 0.76666],
            "8746": [0, 0.55556, 0, 0, 0.76666],
            "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
            "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
            "8768": [0.19444, 0.69444, 0, 0, 0.31944],
            "8771": [222e-5, 0.50222, 0, 0, 0.89444],
            "8776": [0.02444, 0.52444, 0, 0, 0.89444],
            "8781": [222e-5, 0.50222, 0, 0, 0.89444],
            "8801": [222e-5, 0.50222, 0, 0, 0.89444],
            "8804": [0.19667, 0.69667, 0, 0, 0.89444],
            "8805": [0.19667, 0.69667, 0, 0, 0.89444],
            "8810": [0.08556, 0.58556, 0, 0, 1.14999],
            "8811": [0.08556, 0.58556, 0, 0, 1.14999],
            "8826": [0.08556, 0.58556, 0, 0, 0.89444],
            "8827": [0.08556, 0.58556, 0, 0, 0.89444],
            "8834": [0.08556, 0.58556, 0, 0, 0.89444],
            "8835": [0.08556, 0.58556, 0, 0, 0.89444],
            "8838": [0.19667, 0.69667, 0, 0, 0.89444],
            "8839": [0.19667, 0.69667, 0, 0, 0.89444],
            "8846": [0, 0.55556, 0, 0, 0.76666],
            "8849": [0.19667, 0.69667, 0, 0, 0.89444],
            "8850": [0.19667, 0.69667, 0, 0, 0.89444],
            "8851": [0, 0.55556, 0, 0, 0.76666],
            "8852": [0, 0.55556, 0, 0, 0.76666],
            "8853": [0.13333, 0.63333, 0, 0, 0.89444],
            "8854": [0.13333, 0.63333, 0, 0, 0.89444],
            "8855": [0.13333, 0.63333, 0, 0, 0.89444],
            "8856": [0.13333, 0.63333, 0, 0, 0.89444],
            "8857": [0.13333, 0.63333, 0, 0, 0.89444],
            "8866": [0, 0.69444, 0, 0, 0.70277],
            "8867": [0, 0.69444, 0, 0, 0.70277],
            "8868": [0, 0.69444, 0, 0, 0.89444],
            "8869": [0, 0.69444, 0, 0, 0.89444],
            "8900": [-0.02639, 0.47361, 0, 0, 0.575],
            "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
            "8902": [-0.02778, 0.47222, 0, 0, 0.575],
            "8968": [0.25, 0.75, 0, 0, 0.51111],
            "8969": [0.25, 0.75, 0, 0, 0.51111],
            "8970": [0.25, 0.75, 0, 0, 0.51111],
            "8971": [0.25, 0.75, 0, 0, 0.51111],
            "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
            "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
            "9651": [0.19444, 0.69444, 0, 0, 1.02222],
            "9657": [-0.02778, 0.47222, 0, 0, 0.575],
            "9661": [0.19444, 0.69444, 0, 0, 1.02222],
            "9667": [-0.02778, 0.47222, 0, 0, 0.575],
            "9711": [0.19444, 0.69444, 0, 0, 1.14999],
            "9824": [0.12963, 0.69444, 0, 0, 0.89444],
            "9825": [0.12963, 0.69444, 0, 0, 0.89444],
            "9826": [0.12963, 0.69444, 0, 0, 0.89444],
            "9827": [0.12963, 0.69444, 0, 0, 0.89444],
            "9837": [0, 0.75, 0, 0, 0.44722],
            "9838": [0.19444, 0.69444, 0, 0, 0.44722],
            "9839": [0.19444, 0.69444, 0, 0, 0.44722],
            "10216": [0.25, 0.75, 0, 0, 0.44722],
            "10217": [0.25, 0.75, 0, 0, 0.44722],
            "10815": [0, 0.68611, 0, 0, 0.9],
            "10927": [0.19667, 0.69667, 0, 0, 0.89444],
            "10928": [0.19667, 0.69667, 0, 0, 0.89444],
            "57376": [0.19444, 0.69444, 0, 0, 0]
          },
          "Main-BoldItalic": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0.11417, 0, 0.38611],
            "34": [0, 0.69444, 0.07939, 0, 0.62055],
            "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
            "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
            "38": [0, 0.69444, 0.08528, 0, 0.88555],
            "39": [0, 0.69444, 0.12945, 0, 0.35555],
            "40": [0.25, 0.75, 0.15806, 0, 0.47333],
            "41": [0.25, 0.75, 0.03306, 0, 0.47333],
            "42": [0, 0.75, 0.14333, 0, 0.59111],
            "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
            "44": [0.19444, 0.14722, 0, 0, 0.35555],
            "45": [0, 0.44444, 0.02611, 0, 0.41444],
            "46": [0, 0.14722, 0, 0, 0.35555],
            "47": [0.25, 0.75, 0.15806, 0, 0.59111],
            "48": [0, 0.64444, 0.13167, 0, 0.59111],
            "49": [0, 0.64444, 0.13167, 0, 0.59111],
            "50": [0, 0.64444, 0.13167, 0, 0.59111],
            "51": [0, 0.64444, 0.13167, 0, 0.59111],
            "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
            "53": [0, 0.64444, 0.13167, 0, 0.59111],
            "54": [0, 0.64444, 0.13167, 0, 0.59111],
            "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
            "56": [0, 0.64444, 0.13167, 0, 0.59111],
            "57": [0, 0.64444, 0.13167, 0, 0.59111],
            "58": [0, 0.44444, 0.06695, 0, 0.35555],
            "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
            "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
            "63": [0, 0.69444, 0.11472, 0, 0.59111],
            "64": [0, 0.69444, 0.09208, 0, 0.88555],
            "65": [0, 0.68611, 0, 0, 0.86555],
            "66": [0, 0.68611, 0.0992, 0, 0.81666],
            "67": [0, 0.68611, 0.14208, 0, 0.82666],
            "68": [0, 0.68611, 0.09062, 0, 0.87555],
            "69": [0, 0.68611, 0.11431, 0, 0.75666],
            "70": [0, 0.68611, 0.12903, 0, 0.72722],
            "71": [0, 0.68611, 0.07347, 0, 0.89527],
            "72": [0, 0.68611, 0.17208, 0, 0.8961],
            "73": [0, 0.68611, 0.15681, 0, 0.47166],
            "74": [0, 0.68611, 0.145, 0, 0.61055],
            "75": [0, 0.68611, 0.14208, 0, 0.89499],
            "76": [0, 0.68611, 0, 0, 0.69777],
            "77": [0, 0.68611, 0.17208, 0, 1.07277],
            "78": [0, 0.68611, 0.17208, 0, 0.8961],
            "79": [0, 0.68611, 0.09062, 0, 0.85499],
            "80": [0, 0.68611, 0.0992, 0, 0.78721],
            "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
            "82": [0, 0.68611, 0.02559, 0, 0.85944],
            "83": [0, 0.68611, 0.11264, 0, 0.64999],
            "84": [0, 0.68611, 0.12903, 0, 0.7961],
            "85": [0, 0.68611, 0.17208, 0, 0.88083],
            "86": [0, 0.68611, 0.18625, 0, 0.86555],
            "87": [0, 0.68611, 0.18625, 0, 1.15999],
            "88": [0, 0.68611, 0.15681, 0, 0.86555],
            "89": [0, 0.68611, 0.19803, 0, 0.86555],
            "90": [0, 0.68611, 0.14208, 0, 0.70888],
            "91": [0.25, 0.75, 0.1875, 0, 0.35611],
            "93": [0.25, 0.75, 0.09972, 0, 0.35611],
            "94": [0, 0.69444, 0.06709, 0, 0.59111],
            "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
            "97": [0, 0.44444, 0.09426, 0, 0.59111],
            "98": [0, 0.69444, 0.07861, 0, 0.53222],
            "99": [0, 0.44444, 0.05222, 0, 0.53222],
            "100": [0, 0.69444, 0.10861, 0, 0.59111],
            "101": [0, 0.44444, 0.085, 0, 0.53222],
            "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
            "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
            "104": [0, 0.69444, 0.09426, 0, 0.59111],
            "105": [0, 0.69326, 0.11387, 0, 0.35555],
            "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
            "107": [0, 0.69444, 0.11111, 0, 0.53222],
            "108": [0, 0.69444, 0.10861, 0, 0.29666],
            "109": [0, 0.44444, 0.09426, 0, 0.94444],
            "110": [0, 0.44444, 0.09426, 0, 0.64999],
            "111": [0, 0.44444, 0.07861, 0, 0.59111],
            "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
            "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
            "114": [0, 0.44444, 0.11111, 0, 0.50167],
            "115": [0, 0.44444, 0.08167, 0, 0.48694],
            "116": [0, 0.63492, 0.09639, 0, 0.385],
            "117": [0, 0.44444, 0.09426, 0, 0.62055],
            "118": [0, 0.44444, 0.11111, 0, 0.53222],
            "119": [0, 0.44444, 0.11111, 0, 0.76777],
            "120": [0, 0.44444, 0.12583, 0, 0.56055],
            "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
            "122": [0, 0.44444, 0.13889, 0, 0.49055],
            "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.69444, 0.11473, 0, 0.59111],
            "176": [0, 0.69444, 0, 0, 0.94888],
            "184": [0.17014, 0, 0, 0, 0.53222],
            "198": [0, 0.68611, 0.11431, 0, 1.02277],
            "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
            "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
            "230": [0, 0.44444, 0.085, 0, 0.82666],
            "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
            "305": [0, 0.44444, 0.09426, 0, 0.35555],
            "338": [0, 0.68611, 0.11431, 0, 1.14054],
            "339": [0, 0.44444, 0.085, 0, 0.82666],
            "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
            "710": [0, 0.69444, 0.06709, 0, 0.59111],
            "711": [0, 0.63194, 0.08271, 0, 0.59111],
            "713": [0, 0.59444, 0.10444, 0, 0.59111],
            "714": [0, 0.69444, 0.08528, 0, 0.59111],
            "715": [0, 0.69444, 0, 0, 0.59111],
            "728": [0, 0.69444, 0.10333, 0, 0.59111],
            "729": [0, 0.69444, 0.12945, 0, 0.35555],
            "730": [0, 0.69444, 0, 0, 0.94888],
            "732": [0, 0.69444, 0.11472, 0, 0.59111],
            "733": [0, 0.69444, 0.11472, 0, 0.59111],
            "915": [0, 0.68611, 0.12903, 0, 0.69777],
            "916": [0, 0.68611, 0, 0, 0.94444],
            "920": [0, 0.68611, 0.09062, 0, 0.88555],
            "923": [0, 0.68611, 0, 0, 0.80666],
            "926": [0, 0.68611, 0.15092, 0, 0.76777],
            "928": [0, 0.68611, 0.17208, 0, 0.8961],
            "931": [0, 0.68611, 0.11431, 0, 0.82666],
            "933": [0, 0.68611, 0.10778, 0, 0.88555],
            "934": [0, 0.68611, 0.05632, 0, 0.82666],
            "936": [0, 0.68611, 0.10778, 0, 0.88555],
            "937": [0, 0.68611, 0.0992, 0, 0.82666],
            "8211": [0, 0.44444, 0.09811, 0, 0.59111],
            "8212": [0, 0.44444, 0.09811, 0, 1.18221],
            "8216": [0, 0.69444, 0.12945, 0, 0.35555],
            "8217": [0, 0.69444, 0.12945, 0, 0.35555],
            "8220": [0, 0.69444, 0.16772, 0, 0.62055],
            "8221": [0, 0.69444, 0.07939, 0, 0.62055]
          },
          "Main-Italic": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0.12417, 0, 0.30667],
            "34": [0, 0.69444, 0.06961, 0, 0.51444],
            "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
            "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
            "38": [0, 0.69444, 0.09694, 0, 0.76666],
            "39": [0, 0.69444, 0.12417, 0, 0.30667],
            "40": [0.25, 0.75, 0.16194, 0, 0.40889],
            "41": [0.25, 0.75, 0.03694, 0, 0.40889],
            "42": [0, 0.75, 0.14917, 0, 0.51111],
            "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
            "44": [0.19444, 0.10556, 0, 0, 0.30667],
            "45": [0, 0.43056, 0.02826, 0, 0.35778],
            "46": [0, 0.10556, 0, 0, 0.30667],
            "47": [0.25, 0.75, 0.16194, 0, 0.51111],
            "48": [0, 0.64444, 0.13556, 0, 0.51111],
            "49": [0, 0.64444, 0.13556, 0, 0.51111],
            "50": [0, 0.64444, 0.13556, 0, 0.51111],
            "51": [0, 0.64444, 0.13556, 0, 0.51111],
            "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
            "53": [0, 0.64444, 0.13556, 0, 0.51111],
            "54": [0, 0.64444, 0.13556, 0, 0.51111],
            "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
            "56": [0, 0.64444, 0.13556, 0, 0.51111],
            "57": [0, 0.64444, 0.13556, 0, 0.51111],
            "58": [0, 0.43056, 0.0582, 0, 0.30667],
            "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
            "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
            "63": [0, 0.69444, 0.1225, 0, 0.51111],
            "64": [0, 0.69444, 0.09597, 0, 0.76666],
            "65": [0, 0.68333, 0, 0, 0.74333],
            "66": [0, 0.68333, 0.10257, 0, 0.70389],
            "67": [0, 0.68333, 0.14528, 0, 0.71555],
            "68": [0, 0.68333, 0.09403, 0, 0.755],
            "69": [0, 0.68333, 0.12028, 0, 0.67833],
            "70": [0, 0.68333, 0.13305, 0, 0.65277],
            "71": [0, 0.68333, 0.08722, 0, 0.77361],
            "72": [0, 0.68333, 0.16389, 0, 0.74333],
            "73": [0, 0.68333, 0.15806, 0, 0.38555],
            "74": [0, 0.68333, 0.14028, 0, 0.525],
            "75": [0, 0.68333, 0.14528, 0, 0.76888],
            "76": [0, 0.68333, 0, 0, 0.62722],
            "77": [0, 0.68333, 0.16389, 0, 0.89666],
            "78": [0, 0.68333, 0.16389, 0, 0.74333],
            "79": [0, 0.68333, 0.09403, 0, 0.76666],
            "80": [0, 0.68333, 0.10257, 0, 0.67833],
            "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
            "82": [0, 0.68333, 0.03868, 0, 0.72944],
            "83": [0, 0.68333, 0.11972, 0, 0.56222],
            "84": [0, 0.68333, 0.13305, 0, 0.71555],
            "85": [0, 0.68333, 0.16389, 0, 0.74333],
            "86": [0, 0.68333, 0.18361, 0, 0.74333],
            "87": [0, 0.68333, 0.18361, 0, 0.99888],
            "88": [0, 0.68333, 0.15806, 0, 0.74333],
            "89": [0, 0.68333, 0.19383, 0, 0.74333],
            "90": [0, 0.68333, 0.14528, 0, 0.61333],
            "91": [0.25, 0.75, 0.1875, 0, 0.30667],
            "93": [0.25, 0.75, 0.10528, 0, 0.30667],
            "94": [0, 0.69444, 0.06646, 0, 0.51111],
            "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
            "97": [0, 0.43056, 0.07671, 0, 0.51111],
            "98": [0, 0.69444, 0.06312, 0, 0.46],
            "99": [0, 0.43056, 0.05653, 0, 0.46],
            "100": [0, 0.69444, 0.10333, 0, 0.51111],
            "101": [0, 0.43056, 0.07514, 0, 0.46],
            "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
            "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
            "104": [0, 0.69444, 0.07671, 0, 0.51111],
            "105": [0, 0.65536, 0.1019, 0, 0.30667],
            "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
            "107": [0, 0.69444, 0.10764, 0, 0.46],
            "108": [0, 0.69444, 0.10333, 0, 0.25555],
            "109": [0, 0.43056, 0.07671, 0, 0.81777],
            "110": [0, 0.43056, 0.07671, 0, 0.56222],
            "111": [0, 0.43056, 0.06312, 0, 0.51111],
            "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
            "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
            "114": [0, 0.43056, 0.10764, 0, 0.42166],
            "115": [0, 0.43056, 0.08208, 0, 0.40889],
            "116": [0, 0.61508, 0.09486, 0, 0.33222],
            "117": [0, 0.43056, 0.07671, 0, 0.53666],
            "118": [0, 0.43056, 0.10764, 0, 0.46],
            "119": [0, 0.43056, 0.10764, 0, 0.66444],
            "120": [0, 0.43056, 0.12042, 0, 0.46389],
            "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
            "122": [0, 0.43056, 0.12292, 0, 0.40889],
            "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.66786, 0.10474, 0, 0.51111],
            "176": [0, 0.69444, 0, 0, 0.83129],
            "184": [0.17014, 0, 0, 0, 0.46],
            "198": [0, 0.68333, 0.12028, 0, 0.88277],
            "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
            "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
            "230": [0, 0.43056, 0.07514, 0, 0.71555],
            "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
            "338": [0, 0.68333, 0.12028, 0, 0.98499],
            "339": [0, 0.43056, 0.07514, 0, 0.71555],
            "710": [0, 0.69444, 0.06646, 0, 0.51111],
            "711": [0, 0.62847, 0.08295, 0, 0.51111],
            "713": [0, 0.56167, 0.10333, 0, 0.51111],
            "714": [0, 0.69444, 0.09694, 0, 0.51111],
            "715": [0, 0.69444, 0, 0, 0.51111],
            "728": [0, 0.69444, 0.10806, 0, 0.51111],
            "729": [0, 0.66786, 0.11752, 0, 0.30667],
            "730": [0, 0.69444, 0, 0, 0.83129],
            "732": [0, 0.66786, 0.11585, 0, 0.51111],
            "733": [0, 0.69444, 0.1225, 0, 0.51111],
            "915": [0, 0.68333, 0.13305, 0, 0.62722],
            "916": [0, 0.68333, 0, 0, 0.81777],
            "920": [0, 0.68333, 0.09403, 0, 0.76666],
            "923": [0, 0.68333, 0, 0, 0.69222],
            "926": [0, 0.68333, 0.15294, 0, 0.66444],
            "928": [0, 0.68333, 0.16389, 0, 0.74333],
            "931": [0, 0.68333, 0.12028, 0, 0.71555],
            "933": [0, 0.68333, 0.11111, 0, 0.76666],
            "934": [0, 0.68333, 0.05986, 0, 0.71555],
            "936": [0, 0.68333, 0.11111, 0, 0.76666],
            "937": [0, 0.68333, 0.10257, 0, 0.71555],
            "8211": [0, 0.43056, 0.09208, 0, 0.51111],
            "8212": [0, 0.43056, 0.09208, 0, 1.02222],
            "8216": [0, 0.69444, 0.12417, 0, 0.30667],
            "8217": [0, 0.69444, 0.12417, 0, 0.30667],
            "8220": [0, 0.69444, 0.1685, 0, 0.51444],
            "8221": [0, 0.69444, 0.06961, 0, 0.51444],
            "8463": [0, 0.68889, 0, 0, 0.54028]
          },
          "Main-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.27778],
            "34": [0, 0.69444, 0, 0, 0.5],
            "35": [0.19444, 0.69444, 0, 0, 0.83334],
            "36": [0.05556, 0.75, 0, 0, 0.5],
            "37": [0.05556, 0.75, 0, 0, 0.83334],
            "38": [0, 0.69444, 0, 0, 0.77778],
            "39": [0, 0.69444, 0, 0, 0.27778],
            "40": [0.25, 0.75, 0, 0, 0.38889],
            "41": [0.25, 0.75, 0, 0, 0.38889],
            "42": [0, 0.75, 0, 0, 0.5],
            "43": [0.08333, 0.58333, 0, 0, 0.77778],
            "44": [0.19444, 0.10556, 0, 0, 0.27778],
            "45": [0, 0.43056, 0, 0, 0.33333],
            "46": [0, 0.10556, 0, 0, 0.27778],
            "47": [0.25, 0.75, 0, 0, 0.5],
            "48": [0, 0.64444, 0, 0, 0.5],
            "49": [0, 0.64444, 0, 0, 0.5],
            "50": [0, 0.64444, 0, 0, 0.5],
            "51": [0, 0.64444, 0, 0, 0.5],
            "52": [0, 0.64444, 0, 0, 0.5],
            "53": [0, 0.64444, 0, 0, 0.5],
            "54": [0, 0.64444, 0, 0, 0.5],
            "55": [0, 0.64444, 0, 0, 0.5],
            "56": [0, 0.64444, 0, 0, 0.5],
            "57": [0, 0.64444, 0, 0, 0.5],
            "58": [0, 0.43056, 0, 0, 0.27778],
            "59": [0.19444, 0.43056, 0, 0, 0.27778],
            "60": [0.0391, 0.5391, 0, 0, 0.77778],
            "61": [-0.13313, 0.36687, 0, 0, 0.77778],
            "62": [0.0391, 0.5391, 0, 0, 0.77778],
            "63": [0, 0.69444, 0, 0, 0.47222],
            "64": [0, 0.69444, 0, 0, 0.77778],
            "65": [0, 0.68333, 0, 0, 0.75],
            "66": [0, 0.68333, 0, 0, 0.70834],
            "67": [0, 0.68333, 0, 0, 0.72222],
            "68": [0, 0.68333, 0, 0, 0.76389],
            "69": [0, 0.68333, 0, 0, 0.68056],
            "70": [0, 0.68333, 0, 0, 0.65278],
            "71": [0, 0.68333, 0, 0, 0.78472],
            "72": [0, 0.68333, 0, 0, 0.75],
            "73": [0, 0.68333, 0, 0, 0.36111],
            "74": [0, 0.68333, 0, 0, 0.51389],
            "75": [0, 0.68333, 0, 0, 0.77778],
            "76": [0, 0.68333, 0, 0, 0.625],
            "77": [0, 0.68333, 0, 0, 0.91667],
            "78": [0, 0.68333, 0, 0, 0.75],
            "79": [0, 0.68333, 0, 0, 0.77778],
            "80": [0, 0.68333, 0, 0, 0.68056],
            "81": [0.19444, 0.68333, 0, 0, 0.77778],
            "82": [0, 0.68333, 0, 0, 0.73611],
            "83": [0, 0.68333, 0, 0, 0.55556],
            "84": [0, 0.68333, 0, 0, 0.72222],
            "85": [0, 0.68333, 0, 0, 0.75],
            "86": [0, 0.68333, 0.01389, 0, 0.75],
            "87": [0, 0.68333, 0.01389, 0, 1.02778],
            "88": [0, 0.68333, 0, 0, 0.75],
            "89": [0, 0.68333, 0.025, 0, 0.75],
            "90": [0, 0.68333, 0, 0, 0.61111],
            "91": [0.25, 0.75, 0, 0, 0.27778],
            "92": [0.25, 0.75, 0, 0, 0.5],
            "93": [0.25, 0.75, 0, 0, 0.27778],
            "94": [0, 0.69444, 0, 0, 0.5],
            "95": [0.31, 0.12056, 0.02778, 0, 0.5],
            "97": [0, 0.43056, 0, 0, 0.5],
            "98": [0, 0.69444, 0, 0, 0.55556],
            "99": [0, 0.43056, 0, 0, 0.44445],
            "100": [0, 0.69444, 0, 0, 0.55556],
            "101": [0, 0.43056, 0, 0, 0.44445],
            "102": [0, 0.69444, 0.07778, 0, 0.30556],
            "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
            "104": [0, 0.69444, 0, 0, 0.55556],
            "105": [0, 0.66786, 0, 0, 0.27778],
            "106": [0.19444, 0.66786, 0, 0, 0.30556],
            "107": [0, 0.69444, 0, 0, 0.52778],
            "108": [0, 0.69444, 0, 0, 0.27778],
            "109": [0, 0.43056, 0, 0, 0.83334],
            "110": [0, 0.43056, 0, 0, 0.55556],
            "111": [0, 0.43056, 0, 0, 0.5],
            "112": [0.19444, 0.43056, 0, 0, 0.55556],
            "113": [0.19444, 0.43056, 0, 0, 0.52778],
            "114": [0, 0.43056, 0, 0, 0.39167],
            "115": [0, 0.43056, 0, 0, 0.39445],
            "116": [0, 0.61508, 0, 0, 0.38889],
            "117": [0, 0.43056, 0, 0, 0.55556],
            "118": [0, 0.43056, 0.01389, 0, 0.52778],
            "119": [0, 0.43056, 0.01389, 0, 0.72222],
            "120": [0, 0.43056, 0, 0, 0.52778],
            "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
            "122": [0, 0.43056, 0, 0, 0.44445],
            "123": [0.25, 0.75, 0, 0, 0.5],
            "124": [0.25, 0.75, 0, 0, 0.27778],
            "125": [0.25, 0.75, 0, 0, 0.5],
            "126": [0.35, 0.31786, 0, 0, 0.5],
            "160": [0, 0, 0, 0, 0.25],
            "163": [0, 0.69444, 0, 0, 0.76909],
            "167": [0.19444, 0.69444, 0, 0, 0.44445],
            "168": [0, 0.66786, 0, 0, 0.5],
            "172": [0, 0.43056, 0, 0, 0.66667],
            "176": [0, 0.69444, 0, 0, 0.75],
            "177": [0.08333, 0.58333, 0, 0, 0.77778],
            "182": [0.19444, 0.69444, 0, 0, 0.61111],
            "184": [0.17014, 0, 0, 0, 0.44445],
            "198": [0, 0.68333, 0, 0, 0.90278],
            "215": [0.08333, 0.58333, 0, 0, 0.77778],
            "216": [0.04861, 0.73194, 0, 0, 0.77778],
            "223": [0, 0.69444, 0, 0, 0.5],
            "230": [0, 0.43056, 0, 0, 0.72222],
            "247": [0.08333, 0.58333, 0, 0, 0.77778],
            "248": [0.09722, 0.52778, 0, 0, 0.5],
            "305": [0, 0.43056, 0, 0, 0.27778],
            "338": [0, 0.68333, 0, 0, 1.01389],
            "339": [0, 0.43056, 0, 0, 0.77778],
            "567": [0.19444, 0.43056, 0, 0, 0.30556],
            "710": [0, 0.69444, 0, 0, 0.5],
            "711": [0, 0.62847, 0, 0, 0.5],
            "713": [0, 0.56778, 0, 0, 0.5],
            "714": [0, 0.69444, 0, 0, 0.5],
            "715": [0, 0.69444, 0, 0, 0.5],
            "728": [0, 0.69444, 0, 0, 0.5],
            "729": [0, 0.66786, 0, 0, 0.27778],
            "730": [0, 0.69444, 0, 0, 0.75],
            "732": [0, 0.66786, 0, 0, 0.5],
            "733": [0, 0.69444, 0, 0, 0.5],
            "915": [0, 0.68333, 0, 0, 0.625],
            "916": [0, 0.68333, 0, 0, 0.83334],
            "920": [0, 0.68333, 0, 0, 0.77778],
            "923": [0, 0.68333, 0, 0, 0.69445],
            "926": [0, 0.68333, 0, 0, 0.66667],
            "928": [0, 0.68333, 0, 0, 0.75],
            "931": [0, 0.68333, 0, 0, 0.72222],
            "933": [0, 0.68333, 0, 0, 0.77778],
            "934": [0, 0.68333, 0, 0, 0.72222],
            "936": [0, 0.68333, 0, 0, 0.77778],
            "937": [0, 0.68333, 0, 0, 0.72222],
            "8211": [0, 0.43056, 0.02778, 0, 0.5],
            "8212": [0, 0.43056, 0.02778, 0, 1],
            "8216": [0, 0.69444, 0, 0, 0.27778],
            "8217": [0, 0.69444, 0, 0, 0.27778],
            "8220": [0, 0.69444, 0, 0, 0.5],
            "8221": [0, 0.69444, 0, 0, 0.5],
            "8224": [0.19444, 0.69444, 0, 0, 0.44445],
            "8225": [0.19444, 0.69444, 0, 0, 0.44445],
            "8230": [0, 0.12, 0, 0, 1.172],
            "8242": [0, 0.55556, 0, 0, 0.275],
            "8407": [0, 0.71444, 0.15382, 0, 0.5],
            "8463": [0, 0.68889, 0, 0, 0.54028],
            "8465": [0, 0.69444, 0, 0, 0.72222],
            "8467": [0, 0.69444, 0, 0.11111, 0.41667],
            "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
            "8476": [0, 0.69444, 0, 0, 0.72222],
            "8501": [0, 0.69444, 0, 0, 0.61111],
            "8592": [-0.13313, 0.36687, 0, 0, 1],
            "8593": [0.19444, 0.69444, 0, 0, 0.5],
            "8594": [-0.13313, 0.36687, 0, 0, 1],
            "8595": [0.19444, 0.69444, 0, 0, 0.5],
            "8596": [-0.13313, 0.36687, 0, 0, 1],
            "8597": [0.25, 0.75, 0, 0, 0.5],
            "8598": [0.19444, 0.69444, 0, 0, 1],
            "8599": [0.19444, 0.69444, 0, 0, 1],
            "8600": [0.19444, 0.69444, 0, 0, 1],
            "8601": [0.19444, 0.69444, 0, 0, 1],
            "8614": [0.011, 0.511, 0, 0, 1],
            "8617": [0.011, 0.511, 0, 0, 1.126],
            "8618": [0.011, 0.511, 0, 0, 1.126],
            "8636": [-0.13313, 0.36687, 0, 0, 1],
            "8637": [-0.13313, 0.36687, 0, 0, 1],
            "8640": [-0.13313, 0.36687, 0, 0, 1],
            "8641": [-0.13313, 0.36687, 0, 0, 1],
            "8652": [0.011, 0.671, 0, 0, 1],
            "8656": [-0.13313, 0.36687, 0, 0, 1],
            "8657": [0.19444, 0.69444, 0, 0, 0.61111],
            "8658": [-0.13313, 0.36687, 0, 0, 1],
            "8659": [0.19444, 0.69444, 0, 0, 0.61111],
            "8660": [-0.13313, 0.36687, 0, 0, 1],
            "8661": [0.25, 0.75, 0, 0, 0.61111],
            "8704": [0, 0.69444, 0, 0, 0.55556],
            "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
            "8707": [0, 0.69444, 0, 0, 0.55556],
            "8709": [0.05556, 0.75, 0, 0, 0.5],
            "8711": [0, 0.68333, 0, 0, 0.83334],
            "8712": [0.0391, 0.5391, 0, 0, 0.66667],
            "8715": [0.0391, 0.5391, 0, 0, 0.66667],
            "8722": [0.08333, 0.58333, 0, 0, 0.77778],
            "8723": [0.08333, 0.58333, 0, 0, 0.77778],
            "8725": [0.25, 0.75, 0, 0, 0.5],
            "8726": [0.25, 0.75, 0, 0, 0.5],
            "8727": [-0.03472, 0.46528, 0, 0, 0.5],
            "8728": [-0.05555, 0.44445, 0, 0, 0.5],
            "8729": [-0.05555, 0.44445, 0, 0, 0.5],
            "8730": [0.2, 0.8, 0, 0, 0.83334],
            "8733": [0, 0.43056, 0, 0, 0.77778],
            "8734": [0, 0.43056, 0, 0, 1],
            "8736": [0, 0.69224, 0, 0, 0.72222],
            "8739": [0.25, 0.75, 0, 0, 0.27778],
            "8741": [0.25, 0.75, 0, 0, 0.5],
            "8743": [0, 0.55556, 0, 0, 0.66667],
            "8744": [0, 0.55556, 0, 0, 0.66667],
            "8745": [0, 0.55556, 0, 0, 0.66667],
            "8746": [0, 0.55556, 0, 0, 0.66667],
            "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
            "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
            "8768": [0.19444, 0.69444, 0, 0, 0.27778],
            "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8773": [-0.022, 0.589, 0, 0, 1],
            "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
            "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8784": [-0.133, 0.67, 0, 0, 0.778],
            "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
            "8804": [0.13597, 0.63597, 0, 0, 0.77778],
            "8805": [0.13597, 0.63597, 0, 0, 0.77778],
            "8810": [0.0391, 0.5391, 0, 0, 1],
            "8811": [0.0391, 0.5391, 0, 0, 1],
            "8826": [0.0391, 0.5391, 0, 0, 0.77778],
            "8827": [0.0391, 0.5391, 0, 0, 0.77778],
            "8834": [0.0391, 0.5391, 0, 0, 0.77778],
            "8835": [0.0391, 0.5391, 0, 0, 0.77778],
            "8838": [0.13597, 0.63597, 0, 0, 0.77778],
            "8839": [0.13597, 0.63597, 0, 0, 0.77778],
            "8846": [0, 0.55556, 0, 0, 0.66667],
            "8849": [0.13597, 0.63597, 0, 0, 0.77778],
            "8850": [0.13597, 0.63597, 0, 0, 0.77778],
            "8851": [0, 0.55556, 0, 0, 0.66667],
            "8852": [0, 0.55556, 0, 0, 0.66667],
            "8853": [0.08333, 0.58333, 0, 0, 0.77778],
            "8854": [0.08333, 0.58333, 0, 0, 0.77778],
            "8855": [0.08333, 0.58333, 0, 0, 0.77778],
            "8856": [0.08333, 0.58333, 0, 0, 0.77778],
            "8857": [0.08333, 0.58333, 0, 0, 0.77778],
            "8866": [0, 0.69444, 0, 0, 0.61111],
            "8867": [0, 0.69444, 0, 0, 0.61111],
            "8868": [0, 0.69444, 0, 0, 0.77778],
            "8869": [0, 0.69444, 0, 0, 0.77778],
            "8872": [0.249, 0.75, 0, 0, 0.867],
            "8900": [-0.05555, 0.44445, 0, 0, 0.5],
            "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
            "8902": [-0.03472, 0.46528, 0, 0, 0.5],
            "8904": [5e-3, 0.505, 0, 0, 0.9],
            "8942": [0.03, 0.9, 0, 0, 0.278],
            "8943": [-0.19, 0.31, 0, 0, 1.172],
            "8945": [-0.1, 0.82, 0, 0, 1.282],
            "8968": [0.25, 0.75, 0, 0, 0.44445],
            "8969": [0.25, 0.75, 0, 0, 0.44445],
            "8970": [0.25, 0.75, 0, 0, 0.44445],
            "8971": [0.25, 0.75, 0, 0, 0.44445],
            "8994": [-0.14236, 0.35764, 0, 0, 1],
            "8995": [-0.14236, 0.35764, 0, 0, 1],
            "9136": [0.244, 0.744, 0, 0, 0.412],
            "9137": [0.244, 0.744, 0, 0, 0.412],
            "9651": [0.19444, 0.69444, 0, 0, 0.88889],
            "9657": [-0.03472, 0.46528, 0, 0, 0.5],
            "9661": [0.19444, 0.69444, 0, 0, 0.88889],
            "9667": [-0.03472, 0.46528, 0, 0, 0.5],
            "9711": [0.19444, 0.69444, 0, 0, 1],
            "9824": [0.12963, 0.69444, 0, 0, 0.77778],
            "9825": [0.12963, 0.69444, 0, 0, 0.77778],
            "9826": [0.12963, 0.69444, 0, 0, 0.77778],
            "9827": [0.12963, 0.69444, 0, 0, 0.77778],
            "9837": [0, 0.75, 0, 0, 0.38889],
            "9838": [0.19444, 0.69444, 0, 0, 0.38889],
            "9839": [0.19444, 0.69444, 0, 0, 0.38889],
            "10216": [0.25, 0.75, 0, 0, 0.38889],
            "10217": [0.25, 0.75, 0, 0, 0.38889],
            "10222": [0.244, 0.744, 0, 0, 0.412],
            "10223": [0.244, 0.744, 0, 0, 0.412],
            "10229": [0.011, 0.511, 0, 0, 1.609],
            "10230": [0.011, 0.511, 0, 0, 1.638],
            "10231": [0.011, 0.511, 0, 0, 1.859],
            "10232": [0.024, 0.525, 0, 0, 1.609],
            "10233": [0.024, 0.525, 0, 0, 1.638],
            "10234": [0.024, 0.525, 0, 0, 1.858],
            "10236": [0.011, 0.511, 0, 0, 1.638],
            "10815": [0, 0.68333, 0, 0, 0.75],
            "10927": [0.13597, 0.63597, 0, 0, 0.77778],
            "10928": [0.13597, 0.63597, 0, 0, 0.77778],
            "57376": [0.19444, 0.69444, 0, 0, 0]
          },
          "Math-BoldItalic": {
            "32": [0, 0, 0, 0, 0.25],
            "48": [0, 0.44444, 0, 0, 0.575],
            "49": [0, 0.44444, 0, 0, 0.575],
            "50": [0, 0.44444, 0, 0, 0.575],
            "51": [0.19444, 0.44444, 0, 0, 0.575],
            "52": [0.19444, 0.44444, 0, 0, 0.575],
            "53": [0.19444, 0.44444, 0, 0, 0.575],
            "54": [0, 0.64444, 0, 0, 0.575],
            "55": [0.19444, 0.44444, 0, 0, 0.575],
            "56": [0, 0.64444, 0, 0, 0.575],
            "57": [0.19444, 0.44444, 0, 0, 0.575],
            "65": [0, 0.68611, 0, 0, 0.86944],
            "66": [0, 0.68611, 0.04835, 0, 0.8664],
            "67": [0, 0.68611, 0.06979, 0, 0.81694],
            "68": [0, 0.68611, 0.03194, 0, 0.93812],
            "69": [0, 0.68611, 0.05451, 0, 0.81007],
            "70": [0, 0.68611, 0.15972, 0, 0.68889],
            "71": [0, 0.68611, 0, 0, 0.88673],
            "72": [0, 0.68611, 0.08229, 0, 0.98229],
            "73": [0, 0.68611, 0.07778, 0, 0.51111],
            "74": [0, 0.68611, 0.10069, 0, 0.63125],
            "75": [0, 0.68611, 0.06979, 0, 0.97118],
            "76": [0, 0.68611, 0, 0, 0.75555],
            "77": [0, 0.68611, 0.11424, 0, 1.14201],
            "78": [0, 0.68611, 0.11424, 0, 0.95034],
            "79": [0, 0.68611, 0.03194, 0, 0.83666],
            "80": [0, 0.68611, 0.15972, 0, 0.72309],
            "81": [0.19444, 0.68611, 0, 0, 0.86861],
            "82": [0, 0.68611, 421e-5, 0, 0.87235],
            "83": [0, 0.68611, 0.05382, 0, 0.69271],
            "84": [0, 0.68611, 0.15972, 0, 0.63663],
            "85": [0, 0.68611, 0.11424, 0, 0.80027],
            "86": [0, 0.68611, 0.25555, 0, 0.67778],
            "87": [0, 0.68611, 0.15972, 0, 1.09305],
            "88": [0, 0.68611, 0.07778, 0, 0.94722],
            "89": [0, 0.68611, 0.25555, 0, 0.67458],
            "90": [0, 0.68611, 0.06979, 0, 0.77257],
            "97": [0, 0.44444, 0, 0, 0.63287],
            "98": [0, 0.69444, 0, 0, 0.52083],
            "99": [0, 0.44444, 0, 0, 0.51342],
            "100": [0, 0.69444, 0, 0, 0.60972],
            "101": [0, 0.44444, 0, 0, 0.55361],
            "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
            "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
            "104": [0, 0.69444, 0, 0, 0.66759],
            "105": [0, 0.69326, 0, 0, 0.4048],
            "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
            "107": [0, 0.69444, 0.01852, 0, 0.6037],
            "108": [0, 0.69444, 88e-4, 0, 0.34815],
            "109": [0, 0.44444, 0, 0, 1.0324],
            "110": [0, 0.44444, 0, 0, 0.71296],
            "111": [0, 0.44444, 0, 0, 0.58472],
            "112": [0.19444, 0.44444, 0, 0, 0.60092],
            "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
            "114": [0, 0.44444, 0.03194, 0, 0.5287],
            "115": [0, 0.44444, 0, 0, 0.53125],
            "116": [0, 0.63492, 0, 0, 0.41528],
            "117": [0, 0.44444, 0, 0, 0.68102],
            "118": [0, 0.44444, 0.03704, 0, 0.56666],
            "119": [0, 0.44444, 0.02778, 0, 0.83148],
            "120": [0, 0.44444, 0, 0, 0.65903],
            "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
            "122": [0, 0.44444, 0.04213, 0, 0.55509],
            "160": [0, 0, 0, 0, 0.25],
            "915": [0, 0.68611, 0.15972, 0, 0.65694],
            "916": [0, 0.68611, 0, 0, 0.95833],
            "920": [0, 0.68611, 0.03194, 0, 0.86722],
            "923": [0, 0.68611, 0, 0, 0.80555],
            "926": [0, 0.68611, 0.07458, 0, 0.84125],
            "928": [0, 0.68611, 0.08229, 0, 0.98229],
            "931": [0, 0.68611, 0.05451, 0, 0.88507],
            "933": [0, 0.68611, 0.15972, 0, 0.67083],
            "934": [0, 0.68611, 0, 0, 0.76666],
            "936": [0, 0.68611, 0.11653, 0, 0.71402],
            "937": [0, 0.68611, 0.04835, 0, 0.8789],
            "945": [0, 0.44444, 0, 0, 0.76064],
            "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
            "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
            "948": [0, 0.69444, 0.03819, 0, 0.52222],
            "949": [0, 0.44444, 0, 0, 0.52882],
            "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
            "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
            "952": [0, 0.69444, 0.03194, 0, 0.5618],
            "953": [0, 0.44444, 0, 0, 0.41204],
            "954": [0, 0.44444, 0, 0, 0.66759],
            "955": [0, 0.69444, 0, 0, 0.67083],
            "956": [0.19444, 0.44444, 0, 0, 0.70787],
            "957": [0, 0.44444, 0.06898, 0, 0.57685],
            "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
            "959": [0, 0.44444, 0, 0, 0.58472],
            "960": [0, 0.44444, 0.03704, 0, 0.68241],
            "961": [0.19444, 0.44444, 0, 0, 0.6118],
            "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
            "963": [0, 0.44444, 0.03704, 0, 0.68588],
            "964": [0, 0.44444, 0.13472, 0, 0.52083],
            "965": [0, 0.44444, 0.03704, 0, 0.63055],
            "966": [0.19444, 0.44444, 0, 0, 0.74722],
            "967": [0.19444, 0.44444, 0, 0, 0.71805],
            "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
            "969": [0, 0.44444, 0.03704, 0, 0.71782],
            "977": [0, 0.69444, 0, 0, 0.69155],
            "981": [0.19444, 0.69444, 0, 0, 0.7125],
            "982": [0, 0.44444, 0.03194, 0, 0.975],
            "1009": [0.19444, 0.44444, 0, 0, 0.6118],
            "1013": [0, 0.44444, 0, 0, 0.48333],
            "57649": [0, 0.44444, 0, 0, 0.39352],
            "57911": [0.19444, 0.44444, 0, 0, 0.43889]
          },
          "Math-Italic": {
            "32": [0, 0, 0, 0, 0.25],
            "48": [0, 0.43056, 0, 0, 0.5],
            "49": [0, 0.43056, 0, 0, 0.5],
            "50": [0, 0.43056, 0, 0, 0.5],
            "51": [0.19444, 0.43056, 0, 0, 0.5],
            "52": [0.19444, 0.43056, 0, 0, 0.5],
            "53": [0.19444, 0.43056, 0, 0, 0.5],
            "54": [0, 0.64444, 0, 0, 0.5],
            "55": [0.19444, 0.43056, 0, 0, 0.5],
            "56": [0, 0.64444, 0, 0, 0.5],
            "57": [0.19444, 0.43056, 0, 0, 0.5],
            "65": [0, 0.68333, 0, 0.13889, 0.75],
            "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
            "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
            "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
            "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
            "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
            "71": [0, 0.68333, 0, 0.08334, 0.78625],
            "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
            "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
            "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
            "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
            "76": [0, 0.68333, 0, 0.02778, 0.68056],
            "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
            "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
            "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
            "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
            "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
            "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
            "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
            "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
            "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
            "86": [0, 0.68333, 0.22222, 0, 0.58333],
            "87": [0, 0.68333, 0.13889, 0, 0.94445],
            "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
            "89": [0, 0.68333, 0.22222, 0, 0.58056],
            "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
            "97": [0, 0.43056, 0, 0, 0.52859],
            "98": [0, 0.69444, 0, 0, 0.42917],
            "99": [0, 0.43056, 0, 0.05556, 0.43276],
            "100": [0, 0.69444, 0, 0.16667, 0.52049],
            "101": [0, 0.43056, 0, 0.05556, 0.46563],
            "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
            "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
            "104": [0, 0.69444, 0, 0, 0.57616],
            "105": [0, 0.65952, 0, 0, 0.34451],
            "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
            "107": [0, 0.69444, 0.03148, 0, 0.5206],
            "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
            "109": [0, 0.43056, 0, 0, 0.87801],
            "110": [0, 0.43056, 0, 0, 0.60023],
            "111": [0, 0.43056, 0, 0.05556, 0.48472],
            "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
            "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
            "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
            "115": [0, 0.43056, 0, 0.05556, 0.46875],
            "116": [0, 0.61508, 0, 0.08334, 0.36111],
            "117": [0, 0.43056, 0, 0.02778, 0.57246],
            "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
            "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
            "120": [0, 0.43056, 0, 0.02778, 0.57153],
            "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
            "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
            "160": [0, 0, 0, 0, 0.25],
            "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
            "916": [0, 0.68333, 0, 0.16667, 0.83334],
            "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
            "923": [0, 0.68333, 0, 0.16667, 0.69445],
            "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
            "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
            "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
            "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
            "934": [0, 0.68333, 0, 0.08334, 0.66667],
            "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
            "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
            "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
            "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
            "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
            "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
            "949": [0, 0.43056, 0, 0.08334, 0.46632],
            "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
            "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
            "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
            "953": [0, 0.43056, 0, 0.05556, 0.35394],
            "954": [0, 0.43056, 0, 0, 0.57616],
            "955": [0, 0.69444, 0, 0, 0.58334],
            "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
            "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
            "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
            "959": [0, 0.43056, 0, 0.05556, 0.48472],
            "960": [0, 0.43056, 0.03588, 0, 0.57003],
            "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
            "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
            "963": [0, 0.43056, 0.03588, 0, 0.57141],
            "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
            "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
            "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
            "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
            "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
            "969": [0, 0.43056, 0.03588, 0, 0.62245],
            "977": [0, 0.69444, 0, 0.08334, 0.59144],
            "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
            "982": [0, 0.43056, 0.02778, 0, 0.82813],
            "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
            "1013": [0, 0.43056, 0, 0.05556, 0.4059],
            "57649": [0, 0.43056, 0, 0.02778, 0.32246],
            "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
          },
          "SansSerif-Bold": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.36667],
            "34": [0, 0.69444, 0, 0, 0.55834],
            "35": [0.19444, 0.69444, 0, 0, 0.91667],
            "36": [0.05556, 0.75, 0, 0, 0.55],
            "37": [0.05556, 0.75, 0, 0, 1.02912],
            "38": [0, 0.69444, 0, 0, 0.83056],
            "39": [0, 0.69444, 0, 0, 0.30556],
            "40": [0.25, 0.75, 0, 0, 0.42778],
            "41": [0.25, 0.75, 0, 0, 0.42778],
            "42": [0, 0.75, 0, 0, 0.55],
            "43": [0.11667, 0.61667, 0, 0, 0.85556],
            "44": [0.10556, 0.13056, 0, 0, 0.30556],
            "45": [0, 0.45833, 0, 0, 0.36667],
            "46": [0, 0.13056, 0, 0, 0.30556],
            "47": [0.25, 0.75, 0, 0, 0.55],
            "48": [0, 0.69444, 0, 0, 0.55],
            "49": [0, 0.69444, 0, 0, 0.55],
            "50": [0, 0.69444, 0, 0, 0.55],
            "51": [0, 0.69444, 0, 0, 0.55],
            "52": [0, 0.69444, 0, 0, 0.55],
            "53": [0, 0.69444, 0, 0, 0.55],
            "54": [0, 0.69444, 0, 0, 0.55],
            "55": [0, 0.69444, 0, 0, 0.55],
            "56": [0, 0.69444, 0, 0, 0.55],
            "57": [0, 0.69444, 0, 0, 0.55],
            "58": [0, 0.45833, 0, 0, 0.30556],
            "59": [0.10556, 0.45833, 0, 0, 0.30556],
            "61": [-0.09375, 0.40625, 0, 0, 0.85556],
            "63": [0, 0.69444, 0, 0, 0.51945],
            "64": [0, 0.69444, 0, 0, 0.73334],
            "65": [0, 0.69444, 0, 0, 0.73334],
            "66": [0, 0.69444, 0, 0, 0.73334],
            "67": [0, 0.69444, 0, 0, 0.70278],
            "68": [0, 0.69444, 0, 0, 0.79445],
            "69": [0, 0.69444, 0, 0, 0.64167],
            "70": [0, 0.69444, 0, 0, 0.61111],
            "71": [0, 0.69444, 0, 0, 0.73334],
            "72": [0, 0.69444, 0, 0, 0.79445],
            "73": [0, 0.69444, 0, 0, 0.33056],
            "74": [0, 0.69444, 0, 0, 0.51945],
            "75": [0, 0.69444, 0, 0, 0.76389],
            "76": [0, 0.69444, 0, 0, 0.58056],
            "77": [0, 0.69444, 0, 0, 0.97778],
            "78": [0, 0.69444, 0, 0, 0.79445],
            "79": [0, 0.69444, 0, 0, 0.79445],
            "80": [0, 0.69444, 0, 0, 0.70278],
            "81": [0.10556, 0.69444, 0, 0, 0.79445],
            "82": [0, 0.69444, 0, 0, 0.70278],
            "83": [0, 0.69444, 0, 0, 0.61111],
            "84": [0, 0.69444, 0, 0, 0.73334],
            "85": [0, 0.69444, 0, 0, 0.76389],
            "86": [0, 0.69444, 0.01528, 0, 0.73334],
            "87": [0, 0.69444, 0.01528, 0, 1.03889],
            "88": [0, 0.69444, 0, 0, 0.73334],
            "89": [0, 0.69444, 0.0275, 0, 0.73334],
            "90": [0, 0.69444, 0, 0, 0.67223],
            "91": [0.25, 0.75, 0, 0, 0.34306],
            "93": [0.25, 0.75, 0, 0, 0.34306],
            "94": [0, 0.69444, 0, 0, 0.55],
            "95": [0.35, 0.10833, 0.03056, 0, 0.55],
            "97": [0, 0.45833, 0, 0, 0.525],
            "98": [0, 0.69444, 0, 0, 0.56111],
            "99": [0, 0.45833, 0, 0, 0.48889],
            "100": [0, 0.69444, 0, 0, 0.56111],
            "101": [0, 0.45833, 0, 0, 0.51111],
            "102": [0, 0.69444, 0.07639, 0, 0.33611],
            "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
            "104": [0, 0.69444, 0, 0, 0.56111],
            "105": [0, 0.69444, 0, 0, 0.25556],
            "106": [0.19444, 0.69444, 0, 0, 0.28611],
            "107": [0, 0.69444, 0, 0, 0.53056],
            "108": [0, 0.69444, 0, 0, 0.25556],
            "109": [0, 0.45833, 0, 0, 0.86667],
            "110": [0, 0.45833, 0, 0, 0.56111],
            "111": [0, 0.45833, 0, 0, 0.55],
            "112": [0.19444, 0.45833, 0, 0, 0.56111],
            "113": [0.19444, 0.45833, 0, 0, 0.56111],
            "114": [0, 0.45833, 0.01528, 0, 0.37222],
            "115": [0, 0.45833, 0, 0, 0.42167],
            "116": [0, 0.58929, 0, 0, 0.40417],
            "117": [0, 0.45833, 0, 0, 0.56111],
            "118": [0, 0.45833, 0.01528, 0, 0.5],
            "119": [0, 0.45833, 0.01528, 0, 0.74445],
            "120": [0, 0.45833, 0, 0, 0.5],
            "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
            "122": [0, 0.45833, 0, 0, 0.47639],
            "126": [0.35, 0.34444, 0, 0, 0.55],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.69444, 0, 0, 0.55],
            "176": [0, 0.69444, 0, 0, 0.73334],
            "180": [0, 0.69444, 0, 0, 0.55],
            "184": [0.17014, 0, 0, 0, 0.48889],
            "305": [0, 0.45833, 0, 0, 0.25556],
            "567": [0.19444, 0.45833, 0, 0, 0.28611],
            "710": [0, 0.69444, 0, 0, 0.55],
            "711": [0, 0.63542, 0, 0, 0.55],
            "713": [0, 0.63778, 0, 0, 0.55],
            "728": [0, 0.69444, 0, 0, 0.55],
            "729": [0, 0.69444, 0, 0, 0.30556],
            "730": [0, 0.69444, 0, 0, 0.73334],
            "732": [0, 0.69444, 0, 0, 0.55],
            "733": [0, 0.69444, 0, 0, 0.55],
            "915": [0, 0.69444, 0, 0, 0.58056],
            "916": [0, 0.69444, 0, 0, 0.91667],
            "920": [0, 0.69444, 0, 0, 0.85556],
            "923": [0, 0.69444, 0, 0, 0.67223],
            "926": [0, 0.69444, 0, 0, 0.73334],
            "928": [0, 0.69444, 0, 0, 0.79445],
            "931": [0, 0.69444, 0, 0, 0.79445],
            "933": [0, 0.69444, 0, 0, 0.85556],
            "934": [0, 0.69444, 0, 0, 0.79445],
            "936": [0, 0.69444, 0, 0, 0.85556],
            "937": [0, 0.69444, 0, 0, 0.79445],
            "8211": [0, 0.45833, 0.03056, 0, 0.55],
            "8212": [0, 0.45833, 0.03056, 0, 1.10001],
            "8216": [0, 0.69444, 0, 0, 0.30556],
            "8217": [0, 0.69444, 0, 0, 0.30556],
            "8220": [0, 0.69444, 0, 0, 0.55834],
            "8221": [0, 0.69444, 0, 0, 0.55834]
          },
          "SansSerif-Italic": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0.05733, 0, 0.31945],
            "34": [0, 0.69444, 316e-5, 0, 0.5],
            "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
            "36": [0.05556, 0.75, 0.11156, 0, 0.5],
            "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
            "38": [0, 0.69444, 0.03058, 0, 0.75834],
            "39": [0, 0.69444, 0.07816, 0, 0.27778],
            "40": [0.25, 0.75, 0.13164, 0, 0.38889],
            "41": [0.25, 0.75, 0.02536, 0, 0.38889],
            "42": [0, 0.75, 0.11775, 0, 0.5],
            "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
            "44": [0.125, 0.08333, 0, 0, 0.27778],
            "45": [0, 0.44444, 0.01946, 0, 0.33333],
            "46": [0, 0.08333, 0, 0, 0.27778],
            "47": [0.25, 0.75, 0.13164, 0, 0.5],
            "48": [0, 0.65556, 0.11156, 0, 0.5],
            "49": [0, 0.65556, 0.11156, 0, 0.5],
            "50": [0, 0.65556, 0.11156, 0, 0.5],
            "51": [0, 0.65556, 0.11156, 0, 0.5],
            "52": [0, 0.65556, 0.11156, 0, 0.5],
            "53": [0, 0.65556, 0.11156, 0, 0.5],
            "54": [0, 0.65556, 0.11156, 0, 0.5],
            "55": [0, 0.65556, 0.11156, 0, 0.5],
            "56": [0, 0.65556, 0.11156, 0, 0.5],
            "57": [0, 0.65556, 0.11156, 0, 0.5],
            "58": [0, 0.44444, 0.02502, 0, 0.27778],
            "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
            "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
            "63": [0, 0.69444, 0.11809, 0, 0.47222],
            "64": [0, 0.69444, 0.07555, 0, 0.66667],
            "65": [0, 0.69444, 0, 0, 0.66667],
            "66": [0, 0.69444, 0.08293, 0, 0.66667],
            "67": [0, 0.69444, 0.11983, 0, 0.63889],
            "68": [0, 0.69444, 0.07555, 0, 0.72223],
            "69": [0, 0.69444, 0.11983, 0, 0.59722],
            "70": [0, 0.69444, 0.13372, 0, 0.56945],
            "71": [0, 0.69444, 0.11983, 0, 0.66667],
            "72": [0, 0.69444, 0.08094, 0, 0.70834],
            "73": [0, 0.69444, 0.13372, 0, 0.27778],
            "74": [0, 0.69444, 0.08094, 0, 0.47222],
            "75": [0, 0.69444, 0.11983, 0, 0.69445],
            "76": [0, 0.69444, 0, 0, 0.54167],
            "77": [0, 0.69444, 0.08094, 0, 0.875],
            "78": [0, 0.69444, 0.08094, 0, 0.70834],
            "79": [0, 0.69444, 0.07555, 0, 0.73611],
            "80": [0, 0.69444, 0.08293, 0, 0.63889],
            "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
            "82": [0, 0.69444, 0.08293, 0, 0.64584],
            "83": [0, 0.69444, 0.09205, 0, 0.55556],
            "84": [0, 0.69444, 0.13372, 0, 0.68056],
            "85": [0, 0.69444, 0.08094, 0, 0.6875],
            "86": [0, 0.69444, 0.1615, 0, 0.66667],
            "87": [0, 0.69444, 0.1615, 0, 0.94445],
            "88": [0, 0.69444, 0.13372, 0, 0.66667],
            "89": [0, 0.69444, 0.17261, 0, 0.66667],
            "90": [0, 0.69444, 0.11983, 0, 0.61111],
            "91": [0.25, 0.75, 0.15942, 0, 0.28889],
            "93": [0.25, 0.75, 0.08719, 0, 0.28889],
            "94": [0, 0.69444, 0.0799, 0, 0.5],
            "95": [0.35, 0.09444, 0.08616, 0, 0.5],
            "97": [0, 0.44444, 981e-5, 0, 0.48056],
            "98": [0, 0.69444, 0.03057, 0, 0.51667],
            "99": [0, 0.44444, 0.08336, 0, 0.44445],
            "100": [0, 0.69444, 0.09483, 0, 0.51667],
            "101": [0, 0.44444, 0.06778, 0, 0.44445],
            "102": [0, 0.69444, 0.21705, 0, 0.30556],
            "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
            "104": [0, 0.69444, 0.01778, 0, 0.51667],
            "105": [0, 0.67937, 0.09718, 0, 0.23889],
            "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
            "107": [0, 0.69444, 0.08336, 0, 0.48889],
            "108": [0, 0.69444, 0.09483, 0, 0.23889],
            "109": [0, 0.44444, 0.01778, 0, 0.79445],
            "110": [0, 0.44444, 0.01778, 0, 0.51667],
            "111": [0, 0.44444, 0.06613, 0, 0.5],
            "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
            "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
            "114": [0, 0.44444, 0.10836, 0, 0.34167],
            "115": [0, 0.44444, 0.0778, 0, 0.38333],
            "116": [0, 0.57143, 0.07225, 0, 0.36111],
            "117": [0, 0.44444, 0.04169, 0, 0.51667],
            "118": [0, 0.44444, 0.10836, 0, 0.46111],
            "119": [0, 0.44444, 0.10836, 0, 0.68334],
            "120": [0, 0.44444, 0.09169, 0, 0.46111],
            "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
            "122": [0, 0.44444, 0.08752, 0, 0.43472],
            "126": [0.35, 0.32659, 0.08826, 0, 0.5],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.67937, 0.06385, 0, 0.5],
            "176": [0, 0.69444, 0, 0, 0.73752],
            "184": [0.17014, 0, 0, 0, 0.44445],
            "305": [0, 0.44444, 0.04169, 0, 0.23889],
            "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
            "710": [0, 0.69444, 0.0799, 0, 0.5],
            "711": [0, 0.63194, 0.08432, 0, 0.5],
            "713": [0, 0.60889, 0.08776, 0, 0.5],
            "714": [0, 0.69444, 0.09205, 0, 0.5],
            "715": [0, 0.69444, 0, 0, 0.5],
            "728": [0, 0.69444, 0.09483, 0, 0.5],
            "729": [0, 0.67937, 0.07774, 0, 0.27778],
            "730": [0, 0.69444, 0, 0, 0.73752],
            "732": [0, 0.67659, 0.08826, 0, 0.5],
            "733": [0, 0.69444, 0.09205, 0, 0.5],
            "915": [0, 0.69444, 0.13372, 0, 0.54167],
            "916": [0, 0.69444, 0, 0, 0.83334],
            "920": [0, 0.69444, 0.07555, 0, 0.77778],
            "923": [0, 0.69444, 0, 0, 0.61111],
            "926": [0, 0.69444, 0.12816, 0, 0.66667],
            "928": [0, 0.69444, 0.08094, 0, 0.70834],
            "931": [0, 0.69444, 0.11983, 0, 0.72222],
            "933": [0, 0.69444, 0.09031, 0, 0.77778],
            "934": [0, 0.69444, 0.04603, 0, 0.72222],
            "936": [0, 0.69444, 0.09031, 0, 0.77778],
            "937": [0, 0.69444, 0.08293, 0, 0.72222],
            "8211": [0, 0.44444, 0.08616, 0, 0.5],
            "8212": [0, 0.44444, 0.08616, 0, 1],
            "8216": [0, 0.69444, 0.07816, 0, 0.27778],
            "8217": [0, 0.69444, 0.07816, 0, 0.27778],
            "8220": [0, 0.69444, 0.14205, 0, 0.5],
            "8221": [0, 0.69444, 316e-5, 0, 0.5]
          },
          "SansSerif-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "33": [0, 0.69444, 0, 0, 0.31945],
            "34": [0, 0.69444, 0, 0, 0.5],
            "35": [0.19444, 0.69444, 0, 0, 0.83334],
            "36": [0.05556, 0.75, 0, 0, 0.5],
            "37": [0.05556, 0.75, 0, 0, 0.83334],
            "38": [0, 0.69444, 0, 0, 0.75834],
            "39": [0, 0.69444, 0, 0, 0.27778],
            "40": [0.25, 0.75, 0, 0, 0.38889],
            "41": [0.25, 0.75, 0, 0, 0.38889],
            "42": [0, 0.75, 0, 0, 0.5],
            "43": [0.08333, 0.58333, 0, 0, 0.77778],
            "44": [0.125, 0.08333, 0, 0, 0.27778],
            "45": [0, 0.44444, 0, 0, 0.33333],
            "46": [0, 0.08333, 0, 0, 0.27778],
            "47": [0.25, 0.75, 0, 0, 0.5],
            "48": [0, 0.65556, 0, 0, 0.5],
            "49": [0, 0.65556, 0, 0, 0.5],
            "50": [0, 0.65556, 0, 0, 0.5],
            "51": [0, 0.65556, 0, 0, 0.5],
            "52": [0, 0.65556, 0, 0, 0.5],
            "53": [0, 0.65556, 0, 0, 0.5],
            "54": [0, 0.65556, 0, 0, 0.5],
            "55": [0, 0.65556, 0, 0, 0.5],
            "56": [0, 0.65556, 0, 0, 0.5],
            "57": [0, 0.65556, 0, 0, 0.5],
            "58": [0, 0.44444, 0, 0, 0.27778],
            "59": [0.125, 0.44444, 0, 0, 0.27778],
            "61": [-0.13, 0.37, 0, 0, 0.77778],
            "63": [0, 0.69444, 0, 0, 0.47222],
            "64": [0, 0.69444, 0, 0, 0.66667],
            "65": [0, 0.69444, 0, 0, 0.66667],
            "66": [0, 0.69444, 0, 0, 0.66667],
            "67": [0, 0.69444, 0, 0, 0.63889],
            "68": [0, 0.69444, 0, 0, 0.72223],
            "69": [0, 0.69444, 0, 0, 0.59722],
            "70": [0, 0.69444, 0, 0, 0.56945],
            "71": [0, 0.69444, 0, 0, 0.66667],
            "72": [0, 0.69444, 0, 0, 0.70834],
            "73": [0, 0.69444, 0, 0, 0.27778],
            "74": [0, 0.69444, 0, 0, 0.47222],
            "75": [0, 0.69444, 0, 0, 0.69445],
            "76": [0, 0.69444, 0, 0, 0.54167],
            "77": [0, 0.69444, 0, 0, 0.875],
            "78": [0, 0.69444, 0, 0, 0.70834],
            "79": [0, 0.69444, 0, 0, 0.73611],
            "80": [0, 0.69444, 0, 0, 0.63889],
            "81": [0.125, 0.69444, 0, 0, 0.73611],
            "82": [0, 0.69444, 0, 0, 0.64584],
            "83": [0, 0.69444, 0, 0, 0.55556],
            "84": [0, 0.69444, 0, 0, 0.68056],
            "85": [0, 0.69444, 0, 0, 0.6875],
            "86": [0, 0.69444, 0.01389, 0, 0.66667],
            "87": [0, 0.69444, 0.01389, 0, 0.94445],
            "88": [0, 0.69444, 0, 0, 0.66667],
            "89": [0, 0.69444, 0.025, 0, 0.66667],
            "90": [0, 0.69444, 0, 0, 0.61111],
            "91": [0.25, 0.75, 0, 0, 0.28889],
            "93": [0.25, 0.75, 0, 0, 0.28889],
            "94": [0, 0.69444, 0, 0, 0.5],
            "95": [0.35, 0.09444, 0.02778, 0, 0.5],
            "97": [0, 0.44444, 0, 0, 0.48056],
            "98": [0, 0.69444, 0, 0, 0.51667],
            "99": [0, 0.44444, 0, 0, 0.44445],
            "100": [0, 0.69444, 0, 0, 0.51667],
            "101": [0, 0.44444, 0, 0, 0.44445],
            "102": [0, 0.69444, 0.06944, 0, 0.30556],
            "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
            "104": [0, 0.69444, 0, 0, 0.51667],
            "105": [0, 0.67937, 0, 0, 0.23889],
            "106": [0.19444, 0.67937, 0, 0, 0.26667],
            "107": [0, 0.69444, 0, 0, 0.48889],
            "108": [0, 0.69444, 0, 0, 0.23889],
            "109": [0, 0.44444, 0, 0, 0.79445],
            "110": [0, 0.44444, 0, 0, 0.51667],
            "111": [0, 0.44444, 0, 0, 0.5],
            "112": [0.19444, 0.44444, 0, 0, 0.51667],
            "113": [0.19444, 0.44444, 0, 0, 0.51667],
            "114": [0, 0.44444, 0.01389, 0, 0.34167],
            "115": [0, 0.44444, 0, 0, 0.38333],
            "116": [0, 0.57143, 0, 0, 0.36111],
            "117": [0, 0.44444, 0, 0, 0.51667],
            "118": [0, 0.44444, 0.01389, 0, 0.46111],
            "119": [0, 0.44444, 0.01389, 0, 0.68334],
            "120": [0, 0.44444, 0, 0, 0.46111],
            "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
            "122": [0, 0.44444, 0, 0, 0.43472],
            "126": [0.35, 0.32659, 0, 0, 0.5],
            "160": [0, 0, 0, 0, 0.25],
            "168": [0, 0.67937, 0, 0, 0.5],
            "176": [0, 0.69444, 0, 0, 0.66667],
            "184": [0.17014, 0, 0, 0, 0.44445],
            "305": [0, 0.44444, 0, 0, 0.23889],
            "567": [0.19444, 0.44444, 0, 0, 0.26667],
            "710": [0, 0.69444, 0, 0, 0.5],
            "711": [0, 0.63194, 0, 0, 0.5],
            "713": [0, 0.60889, 0, 0, 0.5],
            "714": [0, 0.69444, 0, 0, 0.5],
            "715": [0, 0.69444, 0, 0, 0.5],
            "728": [0, 0.69444, 0, 0, 0.5],
            "729": [0, 0.67937, 0, 0, 0.27778],
            "730": [0, 0.69444, 0, 0, 0.66667],
            "732": [0, 0.67659, 0, 0, 0.5],
            "733": [0, 0.69444, 0, 0, 0.5],
            "915": [0, 0.69444, 0, 0, 0.54167],
            "916": [0, 0.69444, 0, 0, 0.83334],
            "920": [0, 0.69444, 0, 0, 0.77778],
            "923": [0, 0.69444, 0, 0, 0.61111],
            "926": [0, 0.69444, 0, 0, 0.66667],
            "928": [0, 0.69444, 0, 0, 0.70834],
            "931": [0, 0.69444, 0, 0, 0.72222],
            "933": [0, 0.69444, 0, 0, 0.77778],
            "934": [0, 0.69444, 0, 0, 0.72222],
            "936": [0, 0.69444, 0, 0, 0.77778],
            "937": [0, 0.69444, 0, 0, 0.72222],
            "8211": [0, 0.44444, 0.02778, 0, 0.5],
            "8212": [0, 0.44444, 0.02778, 0, 1],
            "8216": [0, 0.69444, 0, 0, 0.27778],
            "8217": [0, 0.69444, 0, 0, 0.27778],
            "8220": [0, 0.69444, 0, 0, 0.5],
            "8221": [0, 0.69444, 0, 0, 0.5]
          },
          "Script-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "65": [0, 0.7, 0.22925, 0, 0.80253],
            "66": [0, 0.7, 0.04087, 0, 0.90757],
            "67": [0, 0.7, 0.1689, 0, 0.66619],
            "68": [0, 0.7, 0.09371, 0, 0.77443],
            "69": [0, 0.7, 0.18583, 0, 0.56162],
            "70": [0, 0.7, 0.13634, 0, 0.89544],
            "71": [0, 0.7, 0.17322, 0, 0.60961],
            "72": [0, 0.7, 0.29694, 0, 0.96919],
            "73": [0, 0.7, 0.19189, 0, 0.80907],
            "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
            "75": [0, 0.7, 0.31259, 0, 0.91364],
            "76": [0, 0.7, 0.19189, 0, 0.87373],
            "77": [0, 0.7, 0.15981, 0, 1.08031],
            "78": [0, 0.7, 0.3525, 0, 0.9015],
            "79": [0, 0.7, 0.08078, 0, 0.73787],
            "80": [0, 0.7, 0.08078, 0, 1.01262],
            "81": [0, 0.7, 0.03305, 0, 0.88282],
            "82": [0, 0.7, 0.06259, 0, 0.85],
            "83": [0, 0.7, 0.19189, 0, 0.86767],
            "84": [0, 0.7, 0.29087, 0, 0.74697],
            "85": [0, 0.7, 0.25815, 0, 0.79996],
            "86": [0, 0.7, 0.27523, 0, 0.62204],
            "87": [0, 0.7, 0.27523, 0, 0.80532],
            "88": [0, 0.7, 0.26006, 0, 0.94445],
            "89": [0, 0.7, 0.2939, 0, 0.70961],
            "90": [0, 0.7, 0.24037, 0, 0.8212],
            "160": [0, 0, 0, 0, 0.25]
          },
          "Size1-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [0.35001, 0.85, 0, 0, 0.45834],
            "41": [0.35001, 0.85, 0, 0, 0.45834],
            "47": [0.35001, 0.85, 0, 0, 0.57778],
            "91": [0.35001, 0.85, 0, 0, 0.41667],
            "92": [0.35001, 0.85, 0, 0, 0.57778],
            "93": [0.35001, 0.85, 0, 0, 0.41667],
            "123": [0.35001, 0.85, 0, 0, 0.58334],
            "125": [0.35001, 0.85, 0, 0, 0.58334],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.72222, 0, 0, 0.55556],
            "732": [0, 0.72222, 0, 0, 0.55556],
            "770": [0, 0.72222, 0, 0, 0.55556],
            "771": [0, 0.72222, 0, 0, 0.55556],
            "8214": [-99e-5, 0.601, 0, 0, 0.77778],
            "8593": [1e-5, 0.6, 0, 0, 0.66667],
            "8595": [1e-5, 0.6, 0, 0, 0.66667],
            "8657": [1e-5, 0.6, 0, 0, 0.77778],
            "8659": [1e-5, 0.6, 0, 0, 0.77778],
            "8719": [0.25001, 0.75, 0, 0, 0.94445],
            "8720": [0.25001, 0.75, 0, 0, 0.94445],
            "8721": [0.25001, 0.75, 0, 0, 1.05556],
            "8730": [0.35001, 0.85, 0, 0, 1],
            "8739": [-599e-5, 0.606, 0, 0, 0.33333],
            "8741": [-599e-5, 0.606, 0, 0, 0.55556],
            "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
            "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
            "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
            "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
            "8896": [0.25001, 0.75, 0, 0, 0.83334],
            "8897": [0.25001, 0.75, 0, 0, 0.83334],
            "8898": [0.25001, 0.75, 0, 0, 0.83334],
            "8899": [0.25001, 0.75, 0, 0, 0.83334],
            "8968": [0.35001, 0.85, 0, 0, 0.47222],
            "8969": [0.35001, 0.85, 0, 0, 0.47222],
            "8970": [0.35001, 0.85, 0, 0, 0.47222],
            "8971": [0.35001, 0.85, 0, 0, 0.47222],
            "9168": [-99e-5, 0.601, 0, 0, 0.66667],
            "10216": [0.35001, 0.85, 0, 0, 0.47222],
            "10217": [0.35001, 0.85, 0, 0, 0.47222],
            "10752": [0.25001, 0.75, 0, 0, 1.11111],
            "10753": [0.25001, 0.75, 0, 0, 1.11111],
            "10754": [0.25001, 0.75, 0, 0, 1.11111],
            "10756": [0.25001, 0.75, 0, 0, 0.83334],
            "10758": [0.25001, 0.75, 0, 0, 0.83334]
          },
          "Size2-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [0.65002, 1.15, 0, 0, 0.59722],
            "41": [0.65002, 1.15, 0, 0, 0.59722],
            "47": [0.65002, 1.15, 0, 0, 0.81111],
            "91": [0.65002, 1.15, 0, 0, 0.47222],
            "92": [0.65002, 1.15, 0, 0, 0.81111],
            "93": [0.65002, 1.15, 0, 0, 0.47222],
            "123": [0.65002, 1.15, 0, 0, 0.66667],
            "125": [0.65002, 1.15, 0, 0, 0.66667],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.75, 0, 0, 1],
            "732": [0, 0.75, 0, 0, 1],
            "770": [0, 0.75, 0, 0, 1],
            "771": [0, 0.75, 0, 0, 1],
            "8719": [0.55001, 1.05, 0, 0, 1.27778],
            "8720": [0.55001, 1.05, 0, 0, 1.27778],
            "8721": [0.55001, 1.05, 0, 0, 1.44445],
            "8730": [0.65002, 1.15, 0, 0, 1],
            "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
            "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
            "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
            "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
            "8896": [0.55001, 1.05, 0, 0, 1.11111],
            "8897": [0.55001, 1.05, 0, 0, 1.11111],
            "8898": [0.55001, 1.05, 0, 0, 1.11111],
            "8899": [0.55001, 1.05, 0, 0, 1.11111],
            "8968": [0.65002, 1.15, 0, 0, 0.52778],
            "8969": [0.65002, 1.15, 0, 0, 0.52778],
            "8970": [0.65002, 1.15, 0, 0, 0.52778],
            "8971": [0.65002, 1.15, 0, 0, 0.52778],
            "10216": [0.65002, 1.15, 0, 0, 0.61111],
            "10217": [0.65002, 1.15, 0, 0, 0.61111],
            "10752": [0.55001, 1.05, 0, 0, 1.51112],
            "10753": [0.55001, 1.05, 0, 0, 1.51112],
            "10754": [0.55001, 1.05, 0, 0, 1.51112],
            "10756": [0.55001, 1.05, 0, 0, 1.11111],
            "10758": [0.55001, 1.05, 0, 0, 1.11111]
          },
          "Size3-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [0.95003, 1.45, 0, 0, 0.73611],
            "41": [0.95003, 1.45, 0, 0, 0.73611],
            "47": [0.95003, 1.45, 0, 0, 1.04445],
            "91": [0.95003, 1.45, 0, 0, 0.52778],
            "92": [0.95003, 1.45, 0, 0, 1.04445],
            "93": [0.95003, 1.45, 0, 0, 0.52778],
            "123": [0.95003, 1.45, 0, 0, 0.75],
            "125": [0.95003, 1.45, 0, 0, 0.75],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.75, 0, 0, 1.44445],
            "732": [0, 0.75, 0, 0, 1.44445],
            "770": [0, 0.75, 0, 0, 1.44445],
            "771": [0, 0.75, 0, 0, 1.44445],
            "8730": [0.95003, 1.45, 0, 0, 1],
            "8968": [0.95003, 1.45, 0, 0, 0.58334],
            "8969": [0.95003, 1.45, 0, 0, 0.58334],
            "8970": [0.95003, 1.45, 0, 0, 0.58334],
            "8971": [0.95003, 1.45, 0, 0, 0.58334],
            "10216": [0.95003, 1.45, 0, 0, 0.75],
            "10217": [0.95003, 1.45, 0, 0, 0.75]
          },
          "Size4-Regular": {
            "32": [0, 0, 0, 0, 0.25],
            "40": [1.25003, 1.75, 0, 0, 0.79167],
            "41": [1.25003, 1.75, 0, 0, 0.79167],
            "47": [1.25003, 1.75, 0, 0, 1.27778],
            "91": [1.25003, 1.75, 0, 0, 0.58334],
            "92": [1.25003, 1.75, 0, 0, 1.27778],
            "93": [1.25003, 1.75, 0, 0, 0.58334],
            "123": [1.25003, 1.75, 0, 0, 0.80556],
            "125": [1.25003, 1.75, 0, 0, 0.80556],
            "160": [0, 0, 0, 0, 0.25],
            "710": [0, 0.825, 0, 0, 1.8889],
            "732": [0, 0.825, 0, 0, 1.8889],
            "770": [0, 0.825, 0, 0, 1.8889],
            "771": [0, 0.825, 0, 0, 1.8889],
            "8730": [1.25003, 1.75, 0, 0, 1],
            "8968": [1.25003, 1.75, 0, 0, 0.63889],
            "8969": [1.25003, 1.75, 0, 0, 0.63889],
            "8970": [1.25003, 1.75, 0, 0, 0.63889],
            "8971": [1.25003, 1.75, 0, 0, 0.63889],
            "9115": [0.64502, 1.155, 0, 0, 0.875],
            "9116": [1e-5, 0.6, 0, 0, 0.875],
            "9117": [0.64502, 1.155, 0, 0, 0.875],
            "9118": [0.64502, 1.155, 0, 0, 0.875],
            "9119": [1e-5, 0.6, 0, 0, 0.875],
            "9120": [0.64502, 1.155, 0, 0, 0.875],
            "9121": [0.64502, 1.155, 0, 0, 0.66667],
            "9122": [-99e-5, 0.601, 0, 0, 0.66667],
            "9123": [0.64502, 1.155, 0, 0, 0.66667],
            "9124": [0.64502, 1.155, 0, 0, 0.66667],
            "9125": [-99e-5, 0.601, 0, 0, 0.66667],
            "9126": [0.64502, 1.155, 0, 0, 0.66667],
            "9127": [1e-5, 0.9, 0, 0, 0.88889],
            "9128": [0.65002, 1.15, 0, 0, 0.88889],
            "9129": [0.90001, 0, 0, 0, 0.88889],
            "9130": [0, 0.3, 0, 0, 0.88889],
            "9131": [1e-5, 0.9, 0, 0, 0.88889],
            "9132": [0.65002, 1.15, 0, 0, 0.88889],
            "9133": [0.90001, 0, 0, 0, 0.88889],
            "9143": [0.88502, 0.915, 0, 0, 1.05556],
            "10216": [1.25003, 1.75, 0, 0, 0.80556],
            "10217": [1.25003, 1.75, 0, 0, 0.80556],
            "57344": [-499e-5, 0.605, 0, 0, 1.05556],
            "57345": [-499e-5, 0.605, 0, 0, 1.05556],
            "57680": [0, 0.12, 0, 0, 0.45],
            "57681": [0, 0.12, 0, 0, 0.45],
            "57682": [0, 0.12, 0, 0, 0.45],
            "57683": [0, 0.12, 0, 0, 0.45]
          },
          "Typewriter-Regular": {
            "32": [0, 0, 0, 0, 0.525],
            "33": [0, 0.61111, 0, 0, 0.525],
            "34": [0, 0.61111, 0, 0, 0.525],
            "35": [0, 0.61111, 0, 0, 0.525],
            "36": [0.08333, 0.69444, 0, 0, 0.525],
            "37": [0.08333, 0.69444, 0, 0, 0.525],
            "38": [0, 0.61111, 0, 0, 0.525],
            "39": [0, 0.61111, 0, 0, 0.525],
            "40": [0.08333, 0.69444, 0, 0, 0.525],
            "41": [0.08333, 0.69444, 0, 0, 0.525],
            "42": [0, 0.52083, 0, 0, 0.525],
            "43": [-0.08056, 0.53055, 0, 0, 0.525],
            "44": [0.13889, 0.125, 0, 0, 0.525],
            "45": [-0.08056, 0.53055, 0, 0, 0.525],
            "46": [0, 0.125, 0, 0, 0.525],
            "47": [0.08333, 0.69444, 0, 0, 0.525],
            "48": [0, 0.61111, 0, 0, 0.525],
            "49": [0, 0.61111, 0, 0, 0.525],
            "50": [0, 0.61111, 0, 0, 0.525],
            "51": [0, 0.61111, 0, 0, 0.525],
            "52": [0, 0.61111, 0, 0, 0.525],
            "53": [0, 0.61111, 0, 0, 0.525],
            "54": [0, 0.61111, 0, 0, 0.525],
            "55": [0, 0.61111, 0, 0, 0.525],
            "56": [0, 0.61111, 0, 0, 0.525],
            "57": [0, 0.61111, 0, 0, 0.525],
            "58": [0, 0.43056, 0, 0, 0.525],
            "59": [0.13889, 0.43056, 0, 0, 0.525],
            "60": [-0.05556, 0.55556, 0, 0, 0.525],
            "61": [-0.19549, 0.41562, 0, 0, 0.525],
            "62": [-0.05556, 0.55556, 0, 0, 0.525],
            "63": [0, 0.61111, 0, 0, 0.525],
            "64": [0, 0.61111, 0, 0, 0.525],
            "65": [0, 0.61111, 0, 0, 0.525],
            "66": [0, 0.61111, 0, 0, 0.525],
            "67": [0, 0.61111, 0, 0, 0.525],
            "68": [0, 0.61111, 0, 0, 0.525],
            "69": [0, 0.61111, 0, 0, 0.525],
            "70": [0, 0.61111, 0, 0, 0.525],
            "71": [0, 0.61111, 0, 0, 0.525],
            "72": [0, 0.61111, 0, 0, 0.525],
            "73": [0, 0.61111, 0, 0, 0.525],
            "74": [0, 0.61111, 0, 0, 0.525],
            "75": [0, 0.61111, 0, 0, 0.525],
            "76": [0, 0.61111, 0, 0, 0.525],
            "77": [0, 0.61111, 0, 0, 0.525],
            "78": [0, 0.61111, 0, 0, 0.525],
            "79": [0, 0.61111, 0, 0, 0.525],
            "80": [0, 0.61111, 0, 0, 0.525],
            "81": [0.13889, 0.61111, 0, 0, 0.525],
            "82": [0, 0.61111, 0, 0, 0.525],
            "83": [0, 0.61111, 0, 0, 0.525],
            "84": [0, 0.61111, 0, 0, 0.525],
            "85": [0, 0.61111, 0, 0, 0.525],
            "86": [0, 0.61111, 0, 0, 0.525],
            "87": [0, 0.61111, 0, 0, 0.525],
            "88": [0, 0.61111, 0, 0, 0.525],
            "89": [0, 0.61111, 0, 0, 0.525],
            "90": [0, 0.61111, 0, 0, 0.525],
            "91": [0.08333, 0.69444, 0, 0, 0.525],
            "92": [0.08333, 0.69444, 0, 0, 0.525],
            "93": [0.08333, 0.69444, 0, 0, 0.525],
            "94": [0, 0.61111, 0, 0, 0.525],
            "95": [0.09514, 0, 0, 0, 0.525],
            "96": [0, 0.61111, 0, 0, 0.525],
            "97": [0, 0.43056, 0, 0, 0.525],
            "98": [0, 0.61111, 0, 0, 0.525],
            "99": [0, 0.43056, 0, 0, 0.525],
            "100": [0, 0.61111, 0, 0, 0.525],
            "101": [0, 0.43056, 0, 0, 0.525],
            "102": [0, 0.61111, 0, 0, 0.525],
            "103": [0.22222, 0.43056, 0, 0, 0.525],
            "104": [0, 0.61111, 0, 0, 0.525],
            "105": [0, 0.61111, 0, 0, 0.525],
            "106": [0.22222, 0.61111, 0, 0, 0.525],
            "107": [0, 0.61111, 0, 0, 0.525],
            "108": [0, 0.61111, 0, 0, 0.525],
            "109": [0, 0.43056, 0, 0, 0.525],
            "110": [0, 0.43056, 0, 0, 0.525],
            "111": [0, 0.43056, 0, 0, 0.525],
            "112": [0.22222, 0.43056, 0, 0, 0.525],
            "113": [0.22222, 0.43056, 0, 0, 0.525],
            "114": [0, 0.43056, 0, 0, 0.525],
            "115": [0, 0.43056, 0, 0, 0.525],
            "116": [0, 0.55358, 0, 0, 0.525],
            "117": [0, 0.43056, 0, 0, 0.525],
            "118": [0, 0.43056, 0, 0, 0.525],
            "119": [0, 0.43056, 0, 0, 0.525],
            "120": [0, 0.43056, 0, 0, 0.525],
            "121": [0.22222, 0.43056, 0, 0, 0.525],
            "122": [0, 0.43056, 0, 0, 0.525],
            "123": [0.08333, 0.69444, 0, 0, 0.525],
            "124": [0.08333, 0.69444, 0, 0, 0.525],
            "125": [0.08333, 0.69444, 0, 0, 0.525],
            "126": [0, 0.61111, 0, 0, 0.525],
            "127": [0, 0.61111, 0, 0, 0.525],
            "160": [0, 0, 0, 0, 0.525],
            "176": [0, 0.61111, 0, 0, 0.525],
            "184": [0.19445, 0, 0, 0, 0.525],
            "305": [0, 0.43056, 0, 0, 0.525],
            "567": [0.22222, 0.43056, 0, 0, 0.525],
            "711": [0, 0.56597, 0, 0, 0.525],
            "713": [0, 0.56555, 0, 0, 0.525],
            "714": [0, 0.61111, 0, 0, 0.525],
            "715": [0, 0.61111, 0, 0, 0.525],
            "728": [0, 0.61111, 0, 0, 0.525],
            "730": [0, 0.61111, 0, 0, 0.525],
            "770": [0, 0.61111, 0, 0, 0.525],
            "771": [0, 0.61111, 0, 0, 0.525],
            "776": [0, 0.61111, 0, 0, 0.525],
            "915": [0, 0.61111, 0, 0, 0.525],
            "916": [0, 0.61111, 0, 0, 0.525],
            "920": [0, 0.61111, 0, 0, 0.525],
            "923": [0, 0.61111, 0, 0, 0.525],
            "926": [0, 0.61111, 0, 0, 0.525],
            "928": [0, 0.61111, 0, 0, 0.525],
            "931": [0, 0.61111, 0, 0, 0.525],
            "933": [0, 0.61111, 0, 0, 0.525],
            "934": [0, 0.61111, 0, 0, 0.525],
            "936": [0, 0.61111, 0, 0, 0.525],
            "937": [0, 0.61111, 0, 0, 0.525],
            "8216": [0, 0.61111, 0, 0, 0.525],
            "8217": [0, 0.61111, 0, 0, 0.525],
            "8242": [0, 0.61111, 0, 0, 0.525],
            "9251": [0.11111, 0.21944, 0, 0, 0.525]
          }
        };
        ;
        var sigmasAndXis = {
          slant: [0.25, 0.25, 0.25],
          space: [0, 0, 0],
          stretch: [0, 0, 0],
          shrink: [0, 0, 0],
          xHeight: [0.431, 0.431, 0.431],
          quad: [1, 1.171, 1.472],
          extraSpace: [0, 0, 0],
          num1: [0.677, 0.732, 0.925],
          num2: [0.394, 0.384, 0.387],
          num3: [0.444, 0.471, 0.504],
          denom1: [0.686, 0.752, 1.025],
          denom2: [0.345, 0.344, 0.532],
          sup1: [0.413, 0.503, 0.504],
          sup2: [0.363, 0.431, 0.404],
          sup3: [0.289, 0.286, 0.294],
          sub1: [0.15, 0.143, 0.2],
          sub2: [0.247, 0.286, 0.4],
          supDrop: [0.386, 0.353, 0.494],
          subDrop: [0.05, 0.071, 0.1],
          delim1: [2.39, 1.7, 1.98],
          delim2: [1.01, 1.157, 1.42],
          axisHeight: [0.25, 0.25, 0.25],
          defaultRuleThickness: [0.04, 0.049, 0.049],
          bigOpSpacing1: [0.111, 0.111, 0.111],
          bigOpSpacing2: [0.166, 0.166, 0.166],
          bigOpSpacing3: [0.2, 0.2, 0.2],
          bigOpSpacing4: [0.6, 0.611, 0.611],
          bigOpSpacing5: [0.1, 0.143, 0.143],
          sqrtRuleThickness: [0.04, 0.04, 0.04],
          ptPerEm: [10, 10, 10],
          doubleRuleSep: [0.2, 0.2, 0.2],
          arrayRuleWidth: [0.04, 0.04, 0.04],
          fboxsep: [0.3, 0.3, 0.3],
          fboxrule: [0.04, 0.04, 0.04]
        };
        var extraCharacterMap = {
          "\xC5": "A",
          "\xC7": "C",
          "\xD0": "D",
          "\xDE": "o",
          "\xE5": "a",
          "\xE7": "c",
          "\xF0": "d",
          "\xFE": "o",
          "\u0410": "A",
          "\u0411": "B",
          "\u0412": "B",
          "\u0413": "F",
          "\u0414": "A",
          "\u0415": "E",
          "\u0416": "K",
          "\u0417": "3",
          "\u0418": "N",
          "\u0419": "N",
          "\u041A": "K",
          "\u041B": "N",
          "\u041C": "M",
          "\u041D": "H",
          "\u041E": "O",
          "\u041F": "N",
          "\u0420": "P",
          "\u0421": "C",
          "\u0422": "T",
          "\u0423": "y",
          "\u0424": "O",
          "\u0425": "X",
          "\u0426": "U",
          "\u0427": "h",
          "\u0428": "W",
          "\u0429": "W",
          "\u042A": "B",
          "\u042B": "X",
          "\u042C": "B",
          "\u042D": "3",
          "\u042E": "X",
          "\u042F": "R",
          "\u0430": "a",
          "\u0431": "b",
          "\u0432": "a",
          "\u0433": "r",
          "\u0434": "y",
          "\u0435": "e",
          "\u0436": "m",
          "\u0437": "e",
          "\u0438": "n",
          "\u0439": "n",
          "\u043A": "n",
          "\u043B": "n",
          "\u043C": "m",
          "\u043D": "n",
          "\u043E": "o",
          "\u043F": "n",
          "\u0440": "p",
          "\u0441": "c",
          "\u0442": "o",
          "\u0443": "y",
          "\u0444": "b",
          "\u0445": "x",
          "\u0446": "n",
          "\u0447": "n",
          "\u0448": "w",
          "\u0449": "w",
          "\u044A": "a",
          "\u044B": "m",
          "\u044C": "a",
          "\u044D": "e",
          "\u044E": "m",
          "\u044F": "r"
        };
        function setFontMetrics(fontName, metrics) {
          fontMetricsData[fontName] = metrics;
        }
        function getCharacterMetrics(character, font, mode) {
          if (!fontMetricsData[font]) {
            throw new Error("Font metrics not found for font: " + font + ".");
          }
          var ch2 = character.charCodeAt(0);
          var metrics = fontMetricsData[font][ch2];
          if (!metrics && character[0] in extraCharacterMap) {
            ch2 = extraCharacterMap[character[0]].charCodeAt(0);
            metrics = fontMetricsData[font][ch2];
          }
          if (!metrics && mode === "text") {
            if (supportedCodepoint(ch2)) {
              metrics = fontMetricsData[font][77];
            }
          }
          if (metrics) {
            return {
              depth: metrics[0],
              height: metrics[1],
              italic: metrics[2],
              skew: metrics[3],
              width: metrics[4]
            };
          }
        }
        var fontMetricsBySizeIndex = {};
        function getGlobalMetrics(size) {
          var sizeIndex;
          if (size >= 5) {
            sizeIndex = 0;
          } else if (size >= 3) {
            sizeIndex = 1;
          } else {
            sizeIndex = 2;
          }
          if (!fontMetricsBySizeIndex[sizeIndex]) {
            var metrics = fontMetricsBySizeIndex[sizeIndex] = {
              cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
            };
            for (var key in sigmasAndXis) {
              if (sigmasAndXis.hasOwnProperty(key)) {
                metrics[key] = sigmasAndXis[key][sizeIndex];
              }
            }
          }
          return fontMetricsBySizeIndex[sizeIndex];
        }
        ;
        var ATOMS = {
          "bin": 1,
          "close": 1,
          "inner": 1,
          "open": 1,
          "punct": 1,
          "rel": 1
        };
        var NON_ATOMS = {
          "accent-token": 1,
          "mathord": 1,
          "op-token": 1,
          "spacing": 1,
          "textord": 1
        };
        var symbols = {
          "math": {},
          "text": {}
        };
        var src_symbols = symbols;
        function defineSymbol(mode, font, group, replace, name2, acceptUnicodeChar) {
          symbols[mode][name2] = {
            font,
            group,
            replace
          };
          if (acceptUnicodeChar && replace) {
            symbols[mode][replace] = symbols[mode][name2];
          }
        }
        var math = "math";
        var symbols_text = "text";
        var main = "main";
        var ams = "ams";
        var accent = "accent-token";
        var bin = "bin";
        var symbols_close = "close";
        var inner = "inner";
        var mathord = "mathord";
        var op = "op-token";
        var symbols_open = "open";
        var punct = "punct";
        var rel = "rel";
        var spacing = "spacing";
        var textord = "textord";
        defineSymbol(math, main, rel, "\u2261", "\\equiv", true);
        defineSymbol(math, main, rel, "\u227A", "\\prec", true);
        defineSymbol(math, main, rel, "\u227B", "\\succ", true);
        defineSymbol(math, main, rel, "\u223C", "\\sim", true);
        defineSymbol(math, main, rel, "\u22A5", "\\perp");
        defineSymbol(math, main, rel, "\u2AAF", "\\preceq", true);
        defineSymbol(math, main, rel, "\u2AB0", "\\succeq", true);
        defineSymbol(math, main, rel, "\u2243", "\\simeq", true);
        defineSymbol(math, main, rel, "\u2223", "\\mid", true);
        defineSymbol(math, main, rel, "\u226A", "\\ll", true);
        defineSymbol(math, main, rel, "\u226B", "\\gg", true);
        defineSymbol(math, main, rel, "\u224D", "\\asymp", true);
        defineSymbol(math, main, rel, "\u2225", "\\parallel");
        defineSymbol(math, main, rel, "\u22C8", "\\bowtie", true);
        defineSymbol(math, main, rel, "\u2323", "\\smile", true);
        defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq", true);
        defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq", true);
        defineSymbol(math, main, rel, "\u2250", "\\doteq", true);
        defineSymbol(math, main, rel, "\u2322", "\\frown", true);
        defineSymbol(math, main, rel, "\u220B", "\\ni", true);
        defineSymbol(math, main, rel, "\u221D", "\\propto", true);
        defineSymbol(math, main, rel, "\u22A2", "\\vdash", true);
        defineSymbol(math, main, rel, "\u22A3", "\\dashv", true);
        defineSymbol(math, main, rel, "\u220B", "\\owns");
        defineSymbol(math, main, punct, ".", "\\ldotp");
        defineSymbol(math, main, punct, "\u22C5", "\\cdotp");
        defineSymbol(math, main, textord, "#", "\\#");
        defineSymbol(symbols_text, main, textord, "#", "\\#");
        defineSymbol(math, main, textord, "&", "\\&");
        defineSymbol(symbols_text, main, textord, "&", "\\&");
        defineSymbol(math, main, textord, "\u2135", "\\aleph", true);
        defineSymbol(math, main, textord, "\u2200", "\\forall", true);
        defineSymbol(math, main, textord, "\u210F", "\\hbar", true);
        defineSymbol(math, main, textord, "\u2203", "\\exists", true);
        defineSymbol(math, main, textord, "\u2207", "\\nabla", true);
        defineSymbol(math, main, textord, "\u266D", "\\flat", true);
        defineSymbol(math, main, textord, "\u2113", "\\ell", true);
        defineSymbol(math, main, textord, "\u266E", "\\natural", true);
        defineSymbol(math, main, textord, "\u2663", "\\clubsuit", true);
        defineSymbol(math, main, textord, "\u2118", "\\wp", true);
        defineSymbol(math, main, textord, "\u266F", "\\sharp", true);
        defineSymbol(math, main, textord, "\u2662", "\\diamondsuit", true);
        defineSymbol(math, main, textord, "\u211C", "\\Re", true);
        defineSymbol(math, main, textord, "\u2661", "\\heartsuit", true);
        defineSymbol(math, main, textord, "\u2111", "\\Im", true);
        defineSymbol(math, main, textord, "\u2660", "\\spadesuit", true);
        defineSymbol(math, main, textord, "\xA7", "\\S", true);
        defineSymbol(symbols_text, main, textord, "\xA7", "\\S");
        defineSymbol(math, main, textord, "\xB6", "\\P", true);
        defineSymbol(symbols_text, main, textord, "\xB6", "\\P");
        defineSymbol(math, main, textord, "\u2020", "\\dag");
        defineSymbol(symbols_text, main, textord, "\u2020", "\\dag");
        defineSymbol(symbols_text, main, textord, "\u2020", "\\textdagger");
        defineSymbol(math, main, textord, "\u2021", "\\ddag");
        defineSymbol(symbols_text, main, textord, "\u2021", "\\ddag");
        defineSymbol(symbols_text, main, textord, "\u2021", "\\textdaggerdbl");
        defineSymbol(math, main, symbols_close, "\u23B1", "\\rmoustache", true);
        defineSymbol(math, main, symbols_open, "\u23B0", "\\lmoustache", true);
        defineSymbol(math, main, symbols_close, "\u27EF", "\\rgroup", true);
        defineSymbol(math, main, symbols_open, "\u27EE", "\\lgroup", true);
        defineSymbol(math, main, bin, "\u2213", "\\mp", true);
        defineSymbol(math, main, bin, "\u2296", "\\ominus", true);
        defineSymbol(math, main, bin, "\u228E", "\\uplus", true);
        defineSymbol(math, main, bin, "\u2293", "\\sqcap", true);
        defineSymbol(math, main, bin, "\u2217", "\\ast");
        defineSymbol(math, main, bin, "\u2294", "\\sqcup", true);
        defineSymbol(math, main, bin, "\u25EF", "\\bigcirc", true);
        defineSymbol(math, main, bin, "\u2219", "\\bullet");
        defineSymbol(math, main, bin, "\u2021", "\\ddagger");
        defineSymbol(math, main, bin, "\u2240", "\\wr", true);
        defineSymbol(math, main, bin, "\u2A3F", "\\amalg");
        defineSymbol(math, main, bin, "&", "\\And");
        defineSymbol(math, main, rel, "\u27F5", "\\longleftarrow", true);
        defineSymbol(math, main, rel, "\u21D0", "\\Leftarrow", true);
        defineSymbol(math, main, rel, "\u27F8", "\\Longleftarrow", true);
        defineSymbol(math, main, rel, "\u27F6", "\\longrightarrow", true);
        defineSymbol(math, main, rel, "\u21D2", "\\Rightarrow", true);
        defineSymbol(math, main, rel, "\u27F9", "\\Longrightarrow", true);
        defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow", true);
        defineSymbol(math, main, rel, "\u27F7", "\\longleftrightarrow", true);
        defineSymbol(math, main, rel, "\u21D4", "\\Leftrightarrow", true);
        defineSymbol(math, main, rel, "\u27FA", "\\Longleftrightarrow", true);
        defineSymbol(math, main, rel, "\u21A6", "\\mapsto", true);
        defineSymbol(math, main, rel, "\u27FC", "\\longmapsto", true);
        defineSymbol(math, main, rel, "\u2197", "\\nearrow", true);
        defineSymbol(math, main, rel, "\u21A9", "\\hookleftarrow", true);
        defineSymbol(math, main, rel, "\u21AA", "\\hookrightarrow", true);
        defineSymbol(math, main, rel, "\u2198", "\\searrow", true);
        defineSymbol(math, main, rel, "\u21BC", "\\leftharpoonup", true);
        defineSymbol(math, main, rel, "\u21C0", "\\rightharpoonup", true);
        defineSymbol(math, main, rel, "\u2199", "\\swarrow", true);
        defineSymbol(math, main, rel, "\u21BD", "\\leftharpoondown", true);
        defineSymbol(math, main, rel, "\u21C1", "\\rightharpoondown", true);
        defineSymbol(math, main, rel, "\u2196", "\\nwarrow", true);
        defineSymbol(math, main, rel, "\u21CC", "\\rightleftharpoons", true);
        defineSymbol(math, ams, rel, "\u226E", "\\nless", true);
        defineSymbol(math, ams, rel, "\uE010", "\\@nleqslant");
        defineSymbol(math, ams, rel, "\uE011", "\\@nleqq");
        defineSymbol(math, ams, rel, "\u2A87", "\\lneq", true);
        defineSymbol(math, ams, rel, "\u2268", "\\lneqq", true);
        defineSymbol(math, ams, rel, "\uE00C", "\\@lvertneqq");
        defineSymbol(math, ams, rel, "\u22E6", "\\lnsim", true);
        defineSymbol(math, ams, rel, "\u2A89", "\\lnapprox", true);
        defineSymbol(math, ams, rel, "\u2280", "\\nprec", true);
        defineSymbol(math, ams, rel, "\u22E0", "\\npreceq", true);
        defineSymbol(math, ams, rel, "\u22E8", "\\precnsim", true);
        defineSymbol(math, ams, rel, "\u2AB9", "\\precnapprox", true);
        defineSymbol(math, ams, rel, "\u2241", "\\nsim", true);
        defineSymbol(math, ams, rel, "\uE006", "\\@nshortmid");
        defineSymbol(math, ams, rel, "\u2224", "\\nmid", true);
        defineSymbol(math, ams, rel, "\u22AC", "\\nvdash", true);
        defineSymbol(math, ams, rel, "\u22AD", "\\nvDash", true);
        defineSymbol(math, ams, rel, "\u22EA", "\\ntriangleleft");
        defineSymbol(math, ams, rel, "\u22EC", "\\ntrianglelefteq", true);
        defineSymbol(math, ams, rel, "\u228A", "\\subsetneq", true);
        defineSymbol(math, ams, rel, "\uE01A", "\\@varsubsetneq");
        defineSymbol(math, ams, rel, "\u2ACB", "\\subsetneqq", true);
        defineSymbol(math, ams, rel, "\uE017", "\\@varsubsetneqq");
        defineSymbol(math, ams, rel, "\u226F", "\\ngtr", true);
        defineSymbol(math, ams, rel, "\uE00F", "\\@ngeqslant");
        defineSymbol(math, ams, rel, "\uE00E", "\\@ngeqq");
        defineSymbol(math, ams, rel, "\u2A88", "\\gneq", true);
        defineSymbol(math, ams, rel, "\u2269", "\\gneqq", true);
        defineSymbol(math, ams, rel, "\uE00D", "\\@gvertneqq");
        defineSymbol(math, ams, rel, "\u22E7", "\\gnsim", true);
        defineSymbol(math, ams, rel, "\u2A8A", "\\gnapprox", true);
        defineSymbol(math, ams, rel, "\u2281", "\\nsucc", true);
        defineSymbol(math, ams, rel, "\u22E1", "\\nsucceq", true);
        defineSymbol(math, ams, rel, "\u22E9", "\\succnsim", true);
        defineSymbol(math, ams, rel, "\u2ABA", "\\succnapprox", true);
        defineSymbol(math, ams, rel, "\u2246", "\\ncong", true);
        defineSymbol(math, ams, rel, "\uE007", "\\@nshortparallel");
        defineSymbol(math, ams, rel, "\u2226", "\\nparallel", true);
        defineSymbol(math, ams, rel, "\u22AF", "\\nVDash", true);
        defineSymbol(math, ams, rel, "\u22EB", "\\ntriangleright");
        defineSymbol(math, ams, rel, "\u22ED", "\\ntrianglerighteq", true);
        defineSymbol(math, ams, rel, "\uE018", "\\@nsupseteqq");
        defineSymbol(math, ams, rel, "\u228B", "\\supsetneq", true);
        defineSymbol(math, ams, rel, "\uE01B", "\\@varsupsetneq");
        defineSymbol(math, ams, rel, "\u2ACC", "\\supsetneqq", true);
        defineSymbol(math, ams, rel, "\uE019", "\\@varsupsetneqq");
        defineSymbol(math, ams, rel, "\u22AE", "\\nVdash", true);
        defineSymbol(math, ams, rel, "\u2AB5", "\\precneqq", true);
        defineSymbol(math, ams, rel, "\u2AB6", "\\succneqq", true);
        defineSymbol(math, ams, rel, "\uE016", "\\@nsubseteqq");
        defineSymbol(math, ams, bin, "\u22B4", "\\unlhd");
        defineSymbol(math, ams, bin, "\u22B5", "\\unrhd");
        defineSymbol(math, ams, rel, "\u219A", "\\nleftarrow", true);
        defineSymbol(math, ams, rel, "\u219B", "\\nrightarrow", true);
        defineSymbol(math, ams, rel, "\u21CD", "\\nLeftarrow", true);
        defineSymbol(math, ams, rel, "\u21CF", "\\nRightarrow", true);
        defineSymbol(math, ams, rel, "\u21AE", "\\nleftrightarrow", true);
        defineSymbol(math, ams, rel, "\u21CE", "\\nLeftrightarrow", true);
        defineSymbol(math, ams, rel, "\u25B3", "\\vartriangle");
        defineSymbol(math, ams, textord, "\u210F", "\\hslash");
        defineSymbol(math, ams, textord, "\u25BD", "\\triangledown");
        defineSymbol(math, ams, textord, "\u25CA", "\\lozenge");
        defineSymbol(math, ams, textord, "\u24C8", "\\circledS");
        defineSymbol(math, ams, textord, "\xAE", "\\circledR");
        defineSymbol(symbols_text, ams, textord, "\xAE", "\\circledR");
        defineSymbol(math, ams, textord, "\u2221", "\\measuredangle", true);
        defineSymbol(math, ams, textord, "\u2204", "\\nexists");
        defineSymbol(math, ams, textord, "\u2127", "\\mho");
        defineSymbol(math, ams, textord, "\u2132", "\\Finv", true);
        defineSymbol(math, ams, textord, "\u2141", "\\Game", true);
        defineSymbol(math, ams, textord, "\u2035", "\\backprime");
        defineSymbol(math, ams, textord, "\u25B2", "\\blacktriangle");
        defineSymbol(math, ams, textord, "\u25BC", "\\blacktriangledown");
        defineSymbol(math, ams, textord, "\u25A0", "\\blacksquare");
        defineSymbol(math, ams, textord, "\u29EB", "\\blacklozenge");
        defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
        defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle", true);
        defineSymbol(math, ams, textord, "\u2201", "\\complement", true);
        defineSymbol(math, ams, textord, "\xF0", "\\eth", true);
        defineSymbol(symbols_text, main, textord, "\xF0", "\xF0");
        defineSymbol(math, ams, textord, "\u2571", "\\diagup");
        defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
        defineSymbol(math, ams, textord, "\u25A1", "\\square");
        defineSymbol(math, ams, textord, "\u25A1", "\\Box");
        defineSymbol(math, ams, textord, "\u25CA", "\\Diamond");
        defineSymbol(math, ams, textord, "\xA5", "\\yen", true);
        defineSymbol(symbols_text, ams, textord, "\xA5", "\\yen", true);
        defineSymbol(math, ams, textord, "\u2713", "\\checkmark", true);
        defineSymbol(symbols_text, ams, textord, "\u2713", "\\checkmark");
        defineSymbol(math, ams, textord, "\u2136", "\\beth", true);
        defineSymbol(math, ams, textord, "\u2138", "\\daleth", true);
        defineSymbol(math, ams, textord, "\u2137", "\\gimel", true);
        defineSymbol(math, ams, textord, "\u03DD", "\\digamma", true);
        defineSymbol(math, ams, textord, "\u03F0", "\\varkappa");
        defineSymbol(math, ams, symbols_open, "\u250C", "\\@ulcorner", true);
        defineSymbol(math, ams, symbols_close, "\u2510", "\\@urcorner", true);
        defineSymbol(math, ams, symbols_open, "\u2514", "\\@llcorner", true);
        defineSymbol(math, ams, symbols_close, "\u2518", "\\@lrcorner", true);
        defineSymbol(math, ams, rel, "\u2266", "\\leqq", true);
        defineSymbol(math, ams, rel, "\u2A7D", "\\leqslant", true);
        defineSymbol(math, ams, rel, "\u2A95", "\\eqslantless", true);
        defineSymbol(math, ams, rel, "\u2272", "\\lesssim", true);
        defineSymbol(math, ams, rel, "\u2A85", "\\lessapprox", true);
        defineSymbol(math, ams, rel, "\u224A", "\\approxeq", true);
        defineSymbol(math, ams, bin, "\u22D6", "\\lessdot");
        defineSymbol(math, ams, rel, "\u22D8", "\\lll", true);
        defineSymbol(math, ams, rel, "\u2276", "\\lessgtr", true);
        defineSymbol(math, ams, rel, "\u22DA", "\\lesseqgtr", true);
        defineSymbol(math, ams, rel, "\u2A8B", "\\lesseqqgtr", true);
        defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
        defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq", true);
        defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq", true);
        defineSymbol(math, ams, rel, "\u223D", "\\backsim", true);
        defineSymbol(math, ams, rel, "\u22CD", "\\backsimeq", true);
        defineSymbol(math, ams, rel, "\u2AC5", "\\subseteqq", true);
        defineSymbol(math, ams, rel, "\u22D0", "\\Subset", true);
        defineSymbol(math, ams, rel, "\u228F", "\\sqsubset", true);
        defineSymbol(math, ams, rel, "\u227C", "\\preccurlyeq", true);
        defineSymbol(math, ams, rel, "\u22DE", "\\curlyeqprec", true);
        defineSymbol(math, ams, rel, "\u227E", "\\precsim", true);
        defineSymbol(math, ams, rel, "\u2AB7", "\\precapprox", true);
        defineSymbol(math, ams, rel, "\u22B2", "\\vartriangleleft");
        defineSymbol(math, ams, rel, "\u22B4", "\\trianglelefteq");
        defineSymbol(math, ams, rel, "\u22A8", "\\vDash", true);
        defineSymbol(math, ams, rel, "\u22AA", "\\Vvdash", true);
        defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
        defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
        defineSymbol(math, ams, rel, "\u224F", "\\bumpeq", true);
        defineSymbol(math, ams, rel, "\u224E", "\\Bumpeq", true);
        defineSymbol(math, ams, rel, "\u2267", "\\geqq", true);
        defineSymbol(math, ams, rel, "\u2A7E", "\\geqslant", true);
        defineSymbol(math, ams, rel, "\u2A96", "\\eqslantgtr", true);
        defineSymbol(math, ams, rel, "\u2273", "\\gtrsim", true);
        defineSymbol(math, ams, rel, "\u2A86", "\\gtrapprox", true);
        defineSymbol(math, ams, bin, "\u22D7", "\\gtrdot");
        defineSymbol(math, ams, rel, "\u22D9", "\\ggg", true);
        defineSymbol(math, ams, rel, "\u2277", "\\gtrless", true);
        defineSymbol(math, ams, rel, "\u22DB", "\\gtreqless", true);
        defineSymbol(math, ams, rel, "\u2A8C", "\\gtreqqless", true);
        defineSymbol(math, ams, rel, "\u2256", "\\eqcirc", true);
        defineSymbol(math, ams, rel, "\u2257", "\\circeq", true);
        defineSymbol(math, ams, rel, "\u225C", "\\triangleq", true);
        defineSymbol(math, ams, rel, "\u223C", "\\thicksim");
        defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
        defineSymbol(math, ams, rel, "\u2AC6", "\\supseteqq", true);
        defineSymbol(math, ams, rel, "\u22D1", "\\Supset", true);
        defineSymbol(math, ams, rel, "\u2290", "\\sqsupset", true);
        defineSymbol(math, ams, rel, "\u227D", "\\succcurlyeq", true);
        defineSymbol(math, ams, rel, "\u22DF", "\\curlyeqsucc", true);
        defineSymbol(math, ams, rel, "\u227F", "\\succsim", true);
        defineSymbol(math, ams, rel, "\u2AB8", "\\succapprox", true);
        defineSymbol(math, ams, rel, "\u22B3", "\\vartriangleright");
        defineSymbol(math, ams, rel, "\u22B5", "\\trianglerighteq");
        defineSymbol(math, ams, rel, "\u22A9", "\\Vdash", true);
        defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
        defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
        defineSymbol(math, ams, rel, "\u226C", "\\between", true);
        defineSymbol(math, ams, rel, "\u22D4", "\\pitchfork", true);
        defineSymbol(math, ams, rel, "\u221D", "\\varpropto");
        defineSymbol(math, ams, rel, "\u25C0", "\\blacktriangleleft");
        defineSymbol(math, ams, rel, "\u2234", "\\therefore", true);
        defineSymbol(math, ams, rel, "\u220D", "\\backepsilon");
        defineSymbol(math, ams, rel, "\u25B6", "\\blacktriangleright");
        defineSymbol(math, ams, rel, "\u2235", "\\because", true);
        defineSymbol(math, ams, rel, "\u22D8", "\\llless");
        defineSymbol(math, ams, rel, "\u22D9", "\\gggtr");
        defineSymbol(math, ams, bin, "\u22B2", "\\lhd");
        defineSymbol(math, ams, bin, "\u22B3", "\\rhd");
        defineSymbol(math, ams, rel, "\u2242", "\\eqsim", true);
        defineSymbol(math, main, rel, "\u22C8", "\\Join");
        defineSymbol(math, ams, rel, "\u2251", "\\Doteq", true);
        defineSymbol(math, ams, bin, "\u2214", "\\dotplus", true);
        defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
        defineSymbol(math, ams, bin, "\u22D2", "\\Cap", true);
        defineSymbol(math, ams, bin, "\u22D3", "\\Cup", true);
        defineSymbol(math, ams, bin, "\u2A5E", "\\doublebarwedge", true);
        defineSymbol(math, ams, bin, "\u229F", "\\boxminus", true);
        defineSymbol(math, ams, bin, "\u229E", "\\boxplus", true);
        defineSymbol(math, ams, bin, "\u22C7", "\\divideontimes", true);
        defineSymbol(math, ams, bin, "\u22C9", "\\ltimes", true);
        defineSymbol(math, ams, bin, "\u22CA", "\\rtimes", true);
        defineSymbol(math, ams, bin, "\u22CB", "\\leftthreetimes", true);
        defineSymbol(math, ams, bin, "\u22CC", "\\rightthreetimes", true);
        defineSymbol(math, ams, bin, "\u22CF", "\\curlywedge", true);
        defineSymbol(math, ams, bin, "\u22CE", "\\curlyvee", true);
        defineSymbol(math, ams, bin, "\u229D", "\\circleddash", true);
        defineSymbol(math, ams, bin, "\u229B", "\\circledast", true);
        defineSymbol(math, ams, bin, "\u22C5", "\\centerdot");
        defineSymbol(math, ams, bin, "\u22BA", "\\intercal", true);
        defineSymbol(math, ams, bin, "\u22D2", "\\doublecap");
        defineSymbol(math, ams, bin, "\u22D3", "\\doublecup");
        defineSymbol(math, ams, bin, "\u22A0", "\\boxtimes", true);
        defineSymbol(math, ams, rel, "\u21E2", "\\dashrightarrow", true);
        defineSymbol(math, ams, rel, "\u21E0", "\\dashleftarrow", true);
        defineSymbol(math, ams, rel, "\u21C7", "\\leftleftarrows", true);
        defineSymbol(math, ams, rel, "\u21C6", "\\leftrightarrows", true);
        defineSymbol(math, ams, rel, "\u21DA", "\\Lleftarrow", true);
        defineSymbol(math, ams, rel, "\u219E", "\\twoheadleftarrow", true);
        defineSymbol(math, ams, rel, "\u21A2", "\\leftarrowtail", true);
        defineSymbol(math, ams, rel, "\u21AB", "\\looparrowleft", true);
        defineSymbol(math, ams, rel, "\u21CB", "\\leftrightharpoons", true);
        defineSymbol(math, ams, rel, "\u21B6", "\\curvearrowleft", true);
        defineSymbol(math, ams, rel, "\u21BA", "\\circlearrowleft", true);
        defineSymbol(math, ams, rel, "\u21B0", "\\Lsh", true);
        defineSymbol(math, ams, rel, "\u21C8", "\\upuparrows", true);
        defineSymbol(math, ams, rel, "\u21BF", "\\upharpoonleft", true);
        defineSymbol(math, ams, rel, "\u21C3", "\\downharpoonleft", true);
        defineSymbol(math, main, rel, "\u22B6", "\\origof", true);
        defineSymbol(math, main, rel, "\u22B7", "\\imageof", true);
        defineSymbol(math, ams, rel, "\u22B8", "\\multimap", true);
        defineSymbol(math, ams, rel, "\u21AD", "\\leftrightsquigarrow", true);
        defineSymbol(math, ams, rel, "\u21C9", "\\rightrightarrows", true);
        defineSymbol(math, ams, rel, "\u21C4", "\\rightleftarrows", true);
        defineSymbol(math, ams, rel, "\u21A0", "\\twoheadrightarrow", true);
        defineSymbol(math, ams, rel, "\u21A3", "\\rightarrowtail", true);
        defineSymbol(math, ams, rel, "\u21AC", "\\looparrowright", true);
        defineSymbol(math, ams, rel, "\u21B7", "\\curvearrowright", true);
        defineSymbol(math, ams, rel, "\u21BB", "\\circlearrowright", true);
        defineSymbol(math, ams, rel, "\u21B1", "\\Rsh", true);
        defineSymbol(math, ams, rel, "\u21CA", "\\downdownarrows", true);
        defineSymbol(math, ams, rel, "\u21BE", "\\upharpoonright", true);
        defineSymbol(math, ams, rel, "\u21C2", "\\downharpoonright", true);
        defineSymbol(math, ams, rel, "\u21DD", "\\rightsquigarrow", true);
        defineSymbol(math, ams, rel, "\u21DD", "\\leadsto");
        defineSymbol(math, ams, rel, "\u21DB", "\\Rrightarrow", true);
        defineSymbol(math, ams, rel, "\u21BE", "\\restriction");
        defineSymbol(math, main, textord, "\u2018", "`");
        defineSymbol(math, main, textord, "$", "\\$");
        defineSymbol(symbols_text, main, textord, "$", "\\$");
        defineSymbol(symbols_text, main, textord, "$", "\\textdollar");
        defineSymbol(math, main, textord, "%", "\\%");
        defineSymbol(symbols_text, main, textord, "%", "\\%");
        defineSymbol(math, main, textord, "_", "\\_");
        defineSymbol(symbols_text, main, textord, "_", "\\_");
        defineSymbol(symbols_text, main, textord, "_", "\\textunderscore");
        defineSymbol(math, main, textord, "\u2220", "\\angle", true);
        defineSymbol(math, main, textord, "\u221E", "\\infty", true);
        defineSymbol(math, main, textord, "\u2032", "\\prime");
        defineSymbol(math, main, textord, "\u25B3", "\\triangle");
        defineSymbol(math, main, textord, "\u0393", "\\Gamma", true);
        defineSymbol(math, main, textord, "\u0394", "\\Delta", true);
        defineSymbol(math, main, textord, "\u0398", "\\Theta", true);
        defineSymbol(math, main, textord, "\u039B", "\\Lambda", true);
        defineSymbol(math, main, textord, "\u039E", "\\Xi", true);
        defineSymbol(math, main, textord, "\u03A0", "\\Pi", true);
        defineSymbol(math, main, textord, "\u03A3", "\\Sigma", true);
        defineSymbol(math, main, textord, "\u03A5", "\\Upsilon", true);
        defineSymbol(math, main, textord, "\u03A6", "\\Phi", true);
        defineSymbol(math, main, textord, "\u03A8", "\\Psi", true);
        defineSymbol(math, main, textord, "\u03A9", "\\Omega", true);
        defineSymbol(math, main, textord, "A", "\u0391");
        defineSymbol(math, main, textord, "B", "\u0392");
        defineSymbol(math, main, textord, "E", "\u0395");
        defineSymbol(math, main, textord, "Z", "\u0396");
        defineSymbol(math, main, textord, "H", "\u0397");
        defineSymbol(math, main, textord, "I", "\u0399");
        defineSymbol(math, main, textord, "K", "\u039A");
        defineSymbol(math, main, textord, "M", "\u039C");
        defineSymbol(math, main, textord, "N", "\u039D");
        defineSymbol(math, main, textord, "O", "\u039F");
        defineSymbol(math, main, textord, "P", "\u03A1");
        defineSymbol(math, main, textord, "T", "\u03A4");
        defineSymbol(math, main, textord, "X", "\u03A7");
        defineSymbol(math, main, textord, "\xAC", "\\neg", true);
        defineSymbol(math, main, textord, "\xAC", "\\lnot");
        defineSymbol(math, main, textord, "\u22A4", "\\top");
        defineSymbol(math, main, textord, "\u22A5", "\\bot");
        defineSymbol(math, main, textord, "\u2205", "\\emptyset");
        defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
        defineSymbol(math, main, mathord, "\u03B1", "\\alpha", true);
        defineSymbol(math, main, mathord, "\u03B2", "\\beta", true);
        defineSymbol(math, main, mathord, "\u03B3", "\\gamma", true);
        defineSymbol(math, main, mathord, "\u03B4", "\\delta", true);
        defineSymbol(math, main, mathord, "\u03F5", "\\epsilon", true);
        defineSymbol(math, main, mathord, "\u03B6", "\\zeta", true);
        defineSymbol(math, main, mathord, "\u03B7", "\\eta", true);
        defineSymbol(math, main, mathord, "\u03B8", "\\theta", true);
        defineSymbol(math, main, mathord, "\u03B9", "\\iota", true);
        defineSymbol(math, main, mathord, "\u03BA", "\\kappa", true);
        defineSymbol(math, main, mathord, "\u03BB", "\\lambda", true);
        defineSymbol(math, main, mathord, "\u03BC", "\\mu", true);
        defineSymbol(math, main, mathord, "\u03BD", "\\nu", true);
        defineSymbol(math, main, mathord, "\u03BE", "\\xi", true);
        defineSymbol(math, main, mathord, "\u03BF", "\\omicron", true);
        defineSymbol(math, main, mathord, "\u03C0", "\\pi", true);
        defineSymbol(math, main, mathord, "\u03C1", "\\rho", true);
        defineSymbol(math, main, mathord, "\u03C3", "\\sigma", true);
        defineSymbol(math, main, mathord, "\u03C4", "\\tau", true);
        defineSymbol(math, main, mathord, "\u03C5", "\\upsilon", true);
        defineSymbol(math, main, mathord, "\u03D5", "\\phi", true);
        defineSymbol(math, main, mathord, "\u03C7", "\\chi", true);
        defineSymbol(math, main, mathord, "\u03C8", "\\psi", true);
        defineSymbol(math, main, mathord, "\u03C9", "\\omega", true);
        defineSymbol(math, main, mathord, "\u03B5", "\\varepsilon", true);
        defineSymbol(math, main, mathord, "\u03D1", "\\vartheta", true);
        defineSymbol(math, main, mathord, "\u03D6", "\\varpi", true);
        defineSymbol(math, main, mathord, "\u03F1", "\\varrho", true);
        defineSymbol(math, main, mathord, "\u03C2", "\\varsigma", true);
        defineSymbol(math, main, mathord, "\u03C6", "\\varphi", true);
        defineSymbol(math, main, bin, "\u2217", "*");
        defineSymbol(math, main, bin, "+", "+");
        defineSymbol(math, main, bin, "\u2212", "-");
        defineSymbol(math, main, bin, "\u22C5", "\\cdot", true);
        defineSymbol(math, main, bin, "\u2218", "\\circ");
        defineSymbol(math, main, bin, "\xF7", "\\div", true);
        defineSymbol(math, main, bin, "\xB1", "\\pm", true);
        defineSymbol(math, main, bin, "\xD7", "\\times", true);
        defineSymbol(math, main, bin, "\u2229", "\\cap", true);
        defineSymbol(math, main, bin, "\u222A", "\\cup", true);
        defineSymbol(math, main, bin, "\u2216", "\\setminus");
        defineSymbol(math, main, bin, "\u2227", "\\land");
        defineSymbol(math, main, bin, "\u2228", "\\lor");
        defineSymbol(math, main, bin, "\u2227", "\\wedge", true);
        defineSymbol(math, main, bin, "\u2228", "\\vee", true);
        defineSymbol(math, main, textord, "\u221A", "\\surd");
        defineSymbol(math, main, symbols_open, "\u27E8", "\\langle", true);
        defineSymbol(math, main, symbols_open, "\u2223", "\\lvert");
        defineSymbol(math, main, symbols_open, "\u2225", "\\lVert");
        defineSymbol(math, main, symbols_close, "?", "?");
        defineSymbol(math, main, symbols_close, "!", "!");
        defineSymbol(math, main, symbols_close, "\u27E9", "\\rangle", true);
        defineSymbol(math, main, symbols_close, "\u2223", "\\rvert");
        defineSymbol(math, main, symbols_close, "\u2225", "\\rVert");
        defineSymbol(math, main, rel, "=", "=");
        defineSymbol(math, main, rel, ":", ":");
        defineSymbol(math, main, rel, "\u2248", "\\approx", true);
        defineSymbol(math, main, rel, "\u2245", "\\cong", true);
        defineSymbol(math, main, rel, "\u2265", "\\ge");
        defineSymbol(math, main, rel, "\u2265", "\\geq", true);
        defineSymbol(math, main, rel, "\u2190", "\\gets");
        defineSymbol(math, main, rel, ">", "\\gt", true);
        defineSymbol(math, main, rel, "\u2208", "\\in", true);
        defineSymbol(math, main, rel, "\uE020", "\\@not");
        defineSymbol(math, main, rel, "\u2282", "\\subset", true);
        defineSymbol(math, main, rel, "\u2283", "\\supset", true);
        defineSymbol(math, main, rel, "\u2286", "\\subseteq", true);
        defineSymbol(math, main, rel, "\u2287", "\\supseteq", true);
        defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq", true);
        defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq", true);
        defineSymbol(math, main, rel, "\u22A8", "\\models");
        defineSymbol(math, main, rel, "\u2190", "\\leftarrow", true);
        defineSymbol(math, main, rel, "\u2264", "\\le");
        defineSymbol(math, main, rel, "\u2264", "\\leq", true);
        defineSymbol(math, main, rel, "<", "\\lt", true);
        defineSymbol(math, main, rel, "\u2192", "\\rightarrow", true);
        defineSymbol(math, main, rel, "\u2192", "\\to");
        defineSymbol(math, ams, rel, "\u2271", "\\ngeq", true);
        defineSymbol(math, ams, rel, "\u2270", "\\nleq", true);
        defineSymbol(math, main, spacing, "\xA0", "\\ ");
        defineSymbol(math, main, spacing, "\xA0", "\\space");
        defineSymbol(math, main, spacing, "\xA0", "\\nobreakspace");
        defineSymbol(symbols_text, main, spacing, "\xA0", "\\ ");
        defineSymbol(symbols_text, main, spacing, "\xA0", " ");
        defineSymbol(symbols_text, main, spacing, "\xA0", "\\space");
        defineSymbol(symbols_text, main, spacing, "\xA0", "\\nobreakspace");
        defineSymbol(math, main, spacing, null, "\\nobreak");
        defineSymbol(math, main, spacing, null, "\\allowbreak");
        defineSymbol(math, main, punct, ",", ",");
        defineSymbol(math, main, punct, ";", ";");
        defineSymbol(math, ams, bin, "\u22BC", "\\barwedge", true);
        defineSymbol(math, ams, bin, "\u22BB", "\\veebar", true);
        defineSymbol(math, main, bin, "\u2299", "\\odot", true);
        defineSymbol(math, main, bin, "\u2295", "\\oplus", true);
        defineSymbol(math, main, bin, "\u2297", "\\otimes", true);
        defineSymbol(math, main, textord, "\u2202", "\\partial", true);
        defineSymbol(math, main, bin, "\u2298", "\\oslash", true);
        defineSymbol(math, ams, bin, "\u229A", "\\circledcirc", true);
        defineSymbol(math, ams, bin, "\u22A1", "\\boxdot", true);
        defineSymbol(math, main, bin, "\u25B3", "\\bigtriangleup");
        defineSymbol(math, main, bin, "\u25BD", "\\bigtriangledown");
        defineSymbol(math, main, bin, "\u2020", "\\dagger");
        defineSymbol(math, main, bin, "\u22C4", "\\diamond");
        defineSymbol(math, main, bin, "\u22C6", "\\star");
        defineSymbol(math, main, bin, "\u25C3", "\\triangleleft");
        defineSymbol(math, main, bin, "\u25B9", "\\triangleright");
        defineSymbol(math, main, symbols_open, "{", "\\{");
        defineSymbol(symbols_text, main, textord, "{", "\\{");
        defineSymbol(symbols_text, main, textord, "{", "\\textbraceleft");
        defineSymbol(math, main, symbols_close, "}", "\\}");
        defineSymbol(symbols_text, main, textord, "}", "\\}");
        defineSymbol(symbols_text, main, textord, "}", "\\textbraceright");
        defineSymbol(math, main, symbols_open, "{", "\\lbrace");
        defineSymbol(math, main, symbols_close, "}", "\\rbrace");
        defineSymbol(math, main, symbols_open, "[", "\\lbrack", true);
        defineSymbol(symbols_text, main, textord, "[", "\\lbrack", true);
        defineSymbol(math, main, symbols_close, "]", "\\rbrack", true);
        defineSymbol(symbols_text, main, textord, "]", "\\rbrack", true);
        defineSymbol(math, main, symbols_open, "(", "\\lparen", true);
        defineSymbol(math, main, symbols_close, ")", "\\rparen", true);
        defineSymbol(symbols_text, main, textord, "<", "\\textless", true);
        defineSymbol(symbols_text, main, textord, ">", "\\textgreater", true);
        defineSymbol(math, main, symbols_open, "\u230A", "\\lfloor", true);
        defineSymbol(math, main, symbols_close, "\u230B", "\\rfloor", true);
        defineSymbol(math, main, symbols_open, "\u2308", "\\lceil", true);
        defineSymbol(math, main, symbols_close, "\u2309", "\\rceil", true);
        defineSymbol(math, main, textord, "\\", "\\backslash");
        defineSymbol(math, main, textord, "\u2223", "|");
        defineSymbol(math, main, textord, "\u2223", "\\vert");
        defineSymbol(symbols_text, main, textord, "|", "\\textbar", true);
        defineSymbol(math, main, textord, "\u2225", "\\|");
        defineSymbol(math, main, textord, "\u2225", "\\Vert");
        defineSymbol(symbols_text, main, textord, "\u2225", "\\textbardbl");
        defineSymbol(symbols_text, main, textord, "~", "\\textasciitilde");
        defineSymbol(symbols_text, main, textord, "\\", "\\textbackslash");
        defineSymbol(symbols_text, main, textord, "^", "\\textasciicircum");
        defineSymbol(math, main, rel, "\u2191", "\\uparrow", true);
        defineSymbol(math, main, rel, "\u21D1", "\\Uparrow", true);
        defineSymbol(math, main, rel, "\u2193", "\\downarrow", true);
        defineSymbol(math, main, rel, "\u21D3", "\\Downarrow", true);
        defineSymbol(math, main, rel, "\u2195", "\\updownarrow", true);
        defineSymbol(math, main, rel, "\u21D5", "\\Updownarrow", true);
        defineSymbol(math, main, op, "\u2210", "\\coprod");
        defineSymbol(math, main, op, "\u22C1", "\\bigvee");
        defineSymbol(math, main, op, "\u22C0", "\\bigwedge");
        defineSymbol(math, main, op, "\u2A04", "\\biguplus");
        defineSymbol(math, main, op, "\u22C2", "\\bigcap");
        defineSymbol(math, main, op, "\u22C3", "\\bigcup");
        defineSymbol(math, main, op, "\u222B", "\\int");
        defineSymbol(math, main, op, "\u222B", "\\intop");
        defineSymbol(math, main, op, "\u222C", "\\iint");
        defineSymbol(math, main, op, "\u222D", "\\iiint");
        defineSymbol(math, main, op, "\u220F", "\\prod");
        defineSymbol(math, main, op, "\u2211", "\\sum");
        defineSymbol(math, main, op, "\u2A02", "\\bigotimes");
        defineSymbol(math, main, op, "\u2A01", "\\bigoplus");
        defineSymbol(math, main, op, "\u2A00", "\\bigodot");
        defineSymbol(math, main, op, "\u222E", "\\oint");
        defineSymbol(math, main, op, "\u222F", "\\oiint");
        defineSymbol(math, main, op, "\u2230", "\\oiiint");
        defineSymbol(math, main, op, "\u2A06", "\\bigsqcup");
        defineSymbol(math, main, op, "\u222B", "\\smallint");
        defineSymbol(symbols_text, main, inner, "\u2026", "\\textellipsis");
        defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
        defineSymbol(symbols_text, main, inner, "\u2026", "\\ldots", true);
        defineSymbol(math, main, inner, "\u2026", "\\ldots", true);
        defineSymbol(math, main, inner, "\u22EF", "\\@cdots", true);
        defineSymbol(math, main, inner, "\u22F1", "\\ddots", true);
        defineSymbol(math, main, textord, "\u22EE", "\\varvdots");
        defineSymbol(math, main, accent, "\u02CA", "\\acute");
        defineSymbol(math, main, accent, "\u02CB", "\\grave");
        defineSymbol(math, main, accent, "\xA8", "\\ddot");
        defineSymbol(math, main, accent, "~", "\\tilde");
        defineSymbol(math, main, accent, "\u02C9", "\\bar");
        defineSymbol(math, main, accent, "\u02D8", "\\breve");
        defineSymbol(math, main, accent, "\u02C7", "\\check");
        defineSymbol(math, main, accent, "^", "\\hat");
        defineSymbol(math, main, accent, "\u20D7", "\\vec");
        defineSymbol(math, main, accent, "\u02D9", "\\dot");
        defineSymbol(math, main, accent, "\u02DA", "\\mathring");
        defineSymbol(math, main, mathord, "\uE131", "\\@imath");
        defineSymbol(math, main, mathord, "\uE237", "\\@jmath");
        defineSymbol(math, main, textord, "\u0131", "\u0131");
        defineSymbol(math, main, textord, "\u0237", "\u0237");
        defineSymbol(symbols_text, main, textord, "\u0131", "\\i", true);
        defineSymbol(symbols_text, main, textord, "\u0237", "\\j", true);
        defineSymbol(symbols_text, main, textord, "\xDF", "\\ss", true);
        defineSymbol(symbols_text, main, textord, "\xE6", "\\ae", true);
        defineSymbol(symbols_text, main, textord, "\u0153", "\\oe", true);
        defineSymbol(symbols_text, main, textord, "\xF8", "\\o", true);
        defineSymbol(symbols_text, main, textord, "\xC6", "\\AE", true);
        defineSymbol(symbols_text, main, textord, "\u0152", "\\OE", true);
        defineSymbol(symbols_text, main, textord, "\xD8", "\\O", true);
        defineSymbol(symbols_text, main, accent, "\u02CA", "\\'");
        defineSymbol(symbols_text, main, accent, "\u02CB", "\\`");
        defineSymbol(symbols_text, main, accent, "\u02C6", "\\^");
        defineSymbol(symbols_text, main, accent, "\u02DC", "\\~");
        defineSymbol(symbols_text, main, accent, "\u02C9", "\\=");
        defineSymbol(symbols_text, main, accent, "\u02D8", "\\u");
        defineSymbol(symbols_text, main, accent, "\u02D9", "\\.");
        defineSymbol(symbols_text, main, accent, "\u02DA", "\\r");
        defineSymbol(symbols_text, main, accent, "\u02C7", "\\v");
        defineSymbol(symbols_text, main, accent, "\xA8", '\\"');
        defineSymbol(symbols_text, main, accent, "\u02DD", "\\H");
        defineSymbol(symbols_text, main, accent, "\u25EF", "\\textcircled");
        var ligatures = {
          "--": true,
          "---": true,
          "``": true,
          "''": true
        };
        defineSymbol(symbols_text, main, textord, "\u2013", "--", true);
        defineSymbol(symbols_text, main, textord, "\u2013", "\\textendash");
        defineSymbol(symbols_text, main, textord, "\u2014", "---", true);
        defineSymbol(symbols_text, main, textord, "\u2014", "\\textemdash");
        defineSymbol(symbols_text, main, textord, "\u2018", "`", true);
        defineSymbol(symbols_text, main, textord, "\u2018", "\\textquoteleft");
        defineSymbol(symbols_text, main, textord, "\u2019", "'", true);
        defineSymbol(symbols_text, main, textord, "\u2019", "\\textquoteright");
        defineSymbol(symbols_text, main, textord, "\u201C", "``", true);
        defineSymbol(symbols_text, main, textord, "\u201C", "\\textquotedblleft");
        defineSymbol(symbols_text, main, textord, "\u201D", "''", true);
        defineSymbol(symbols_text, main, textord, "\u201D", "\\textquotedblright");
        defineSymbol(math, main, textord, "\xB0", "\\degree", true);
        defineSymbol(symbols_text, main, textord, "\xB0", "\\degree");
        defineSymbol(symbols_text, main, textord, "\xB0", "\\textdegree", true);
        defineSymbol(math, main, textord, "\xA3", "\\pounds");
        defineSymbol(math, main, textord, "\xA3", "\\mathsterling", true);
        defineSymbol(symbols_text, main, textord, "\xA3", "\\pounds");
        defineSymbol(symbols_text, main, textord, "\xA3", "\\textsterling", true);
        defineSymbol(math, ams, textord, "\u2720", "\\maltese");
        defineSymbol(symbols_text, ams, textord, "\u2720", "\\maltese");
        var mathTextSymbols = '0123456789/@."';
        for (var i = 0; i < mathTextSymbols.length; i++) {
          var ch = mathTextSymbols.charAt(i);
          defineSymbol(math, main, textord, ch, ch);
        }
        var textSymbols = '0123456789!@*()-=+";:?/.,';
        for (var _i = 0; _i < textSymbols.length; _i++) {
          var _ch = textSymbols.charAt(_i);
          defineSymbol(symbols_text, main, textord, _ch, _ch);
        }
        var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        for (var _i2 = 0; _i2 < letters.length; _i2++) {
          var _ch2 = letters.charAt(_i2);
          defineSymbol(math, main, mathord, _ch2, _ch2);
          defineSymbol(symbols_text, main, textord, _ch2, _ch2);
        }
        defineSymbol(math, ams, textord, "C", "\u2102");
        defineSymbol(symbols_text, ams, textord, "C", "\u2102");
        defineSymbol(math, ams, textord, "H", "\u210D");
        defineSymbol(symbols_text, ams, textord, "H", "\u210D");
        defineSymbol(math, ams, textord, "N", "\u2115");
        defineSymbol(symbols_text, ams, textord, "N", "\u2115");
        defineSymbol(math, ams, textord, "P", "\u2119");
        defineSymbol(symbols_text, ams, textord, "P", "\u2119");
        defineSymbol(math, ams, textord, "Q", "\u211A");
        defineSymbol(symbols_text, ams, textord, "Q", "\u211A");
        defineSymbol(math, ams, textord, "R", "\u211D");
        defineSymbol(symbols_text, ams, textord, "R", "\u211D");
        defineSymbol(math, ams, textord, "Z", "\u2124");
        defineSymbol(symbols_text, ams, textord, "Z", "\u2124");
        defineSymbol(math, main, mathord, "h", "\u210E");
        defineSymbol(symbols_text, main, mathord, "h", "\u210E");
        var wideChar = "";
        for (var _i3 = 0; _i3 < letters.length; _i3++) {
          var _ch3 = letters.charAt(_i3);
          wideChar = String.fromCharCode(55349, 56320 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56372 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56424 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56580 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56736 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56788 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56840 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
          wideChar = String.fromCharCode(55349, 56944 + _i3);
          defineSymbol(math, main, mathord, _ch3, wideChar);
          defineSymbol(symbols_text, main, textord, _ch3, wideChar);
          if (_i3 < 26) {
            wideChar = String.fromCharCode(55349, 56632 + _i3);
            defineSymbol(math, main, mathord, _ch3, wideChar);
            defineSymbol(symbols_text, main, textord, _ch3, wideChar);
            wideChar = String.fromCharCode(55349, 56476 + _i3);
            defineSymbol(math, main, mathord, _ch3, wideChar);
            defineSymbol(symbols_text, main, textord, _ch3, wideChar);
          }
        }
        wideChar = String.fromCharCode(55349, 56668);
        defineSymbol(math, main, mathord, "k", wideChar);
        defineSymbol(symbols_text, main, textord, "k", wideChar);
        for (var _i4 = 0; _i4 < 10; _i4++) {
          var _ch4 = _i4.toString();
          wideChar = String.fromCharCode(55349, 57294 + _i4);
          defineSymbol(math, main, mathord, _ch4, wideChar);
          defineSymbol(symbols_text, main, textord, _ch4, wideChar);
          wideChar = String.fromCharCode(55349, 57314 + _i4);
          defineSymbol(math, main, mathord, _ch4, wideChar);
          defineSymbol(symbols_text, main, textord, _ch4, wideChar);
          wideChar = String.fromCharCode(55349, 57324 + _i4);
          defineSymbol(math, main, mathord, _ch4, wideChar);
          defineSymbol(symbols_text, main, textord, _ch4, wideChar);
          wideChar = String.fromCharCode(55349, 57334 + _i4);
          defineSymbol(math, main, mathord, _ch4, wideChar);
          defineSymbol(symbols_text, main, textord, _ch4, wideChar);
        }
        var extraLatin = "\xC7\xD0\xDE\xE7\xFE";
        for (var _i5 = 0; _i5 < extraLatin.length; _i5++) {
          var _ch5 = extraLatin.charAt(_i5);
          defineSymbol(math, main, mathord, _ch5, _ch5);
          defineSymbol(symbols_text, main, textord, _ch5, _ch5);
        }
        ;
        var wideLatinLetterData = [
          ["mathbf", "textbf", "Main-Bold"],
          ["mathbf", "textbf", "Main-Bold"],
          ["mathnormal", "textit", "Math-Italic"],
          ["mathnormal", "textit", "Math-Italic"],
          ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
          ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
          ["mathscr", "textscr", "Script-Regular"],
          ["", "", ""],
          ["", "", ""],
          ["", "", ""],
          ["mathfrak", "textfrak", "Fraktur-Regular"],
          ["mathfrak", "textfrak", "Fraktur-Regular"],
          ["mathbb", "textbb", "AMS-Regular"],
          ["mathbb", "textbb", "AMS-Regular"],
          ["", "", ""],
          ["", "", ""],
          ["mathsf", "textsf", "SansSerif-Regular"],
          ["mathsf", "textsf", "SansSerif-Regular"],
          ["mathboldsf", "textboldsf", "SansSerif-Bold"],
          ["mathboldsf", "textboldsf", "SansSerif-Bold"],
          ["mathitsf", "textitsf", "SansSerif-Italic"],
          ["mathitsf", "textitsf", "SansSerif-Italic"],
          ["", "", ""],
          ["", "", ""],
          ["mathtt", "texttt", "Typewriter-Regular"],
          ["mathtt", "texttt", "Typewriter-Regular"]
        ];
        var wideNumeralData = [
          ["mathbf", "textbf", "Main-Bold"],
          ["", "", ""],
          ["mathsf", "textsf", "SansSerif-Regular"],
          ["mathboldsf", "textboldsf", "SansSerif-Bold"],
          ["mathtt", "texttt", "Typewriter-Regular"]
        ];
        var wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
          var H = wideChar2.charCodeAt(0);
          var L = wideChar2.charCodeAt(1);
          var codePoint = (H - 55296) * 1024 + (L - 56320) + 65536;
          var j = mode === "math" ? 0 : 1;
          if (119808 <= codePoint && codePoint < 120484) {
            var i2 = Math.floor((codePoint - 119808) / 26);
            return [wideLatinLetterData[i2][2], wideLatinLetterData[i2][j]];
          } else if (120782 <= codePoint && codePoint <= 120831) {
            var _i6 = Math.floor((codePoint - 120782) / 10);
            return [wideNumeralData[_i6][2], wideNumeralData[_i6][j]];
          } else if (codePoint === 120485 || codePoint === 120486) {
            return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
          } else if (120486 < codePoint && codePoint < 120782) {
            return ["", ""];
          } else {
            throw new src_ParseError("Unsupported character: " + wideChar2);
          }
        };
        ;
        var sizeStyleMap = [
          [1, 1, 1],
          [2, 1, 1],
          [3, 1, 1],
          [4, 2, 1],
          [5, 2, 1],
          [6, 3, 1],
          [7, 4, 2],
          [8, 6, 3],
          [9, 7, 6],
          [10, 8, 7],
          [11, 10, 9]
        ];
        var sizeMultipliers = [
          0.5,
          0.6,
          0.7,
          0.8,
          0.9,
          1,
          1.2,
          1.44,
          1.728,
          2.074,
          2.488
        ];
        var sizeAtStyle = function sizeAtStyle2(size, style) {
          return style.size < 2 ? size : sizeStyleMap[size - 1][style.size - 1];
        };
        var Options = /* @__PURE__ */ function() {
          function Options2(data) {
            this.style = void 0;
            this.color = void 0;
            this.size = void 0;
            this.textSize = void 0;
            this.phantom = void 0;
            this.font = void 0;
            this.fontFamily = void 0;
            this.fontWeight = void 0;
            this.fontShape = void 0;
            this.sizeMultiplier = void 0;
            this.maxSize = void 0;
            this.minRuleThickness = void 0;
            this._fontMetrics = void 0;
            this.style = data.style;
            this.color = data.color;
            this.size = data.size || Options2.BASESIZE;
            this.textSize = data.textSize || this.size;
            this.phantom = !!data.phantom;
            this.font = data.font || "";
            this.fontFamily = data.fontFamily || "";
            this.fontWeight = data.fontWeight || "";
            this.fontShape = data.fontShape || "";
            this.sizeMultiplier = sizeMultipliers[this.size - 1];
            this.maxSize = data.maxSize;
            this.minRuleThickness = data.minRuleThickness;
            this._fontMetrics = void 0;
          }
          var _proto = Options2.prototype;
          _proto.extend = function extend2(extension) {
            var data = {
              style: this.style,
              size: this.size,
              textSize: this.textSize,
              color: this.color,
              phantom: this.phantom,
              font: this.font,
              fontFamily: this.fontFamily,
              fontWeight: this.fontWeight,
              fontShape: this.fontShape,
              maxSize: this.maxSize,
              minRuleThickness: this.minRuleThickness
            };
            for (var key in extension) {
              if (extension.hasOwnProperty(key)) {
                data[key] = extension[key];
              }
            }
            return new Options2(data);
          };
          _proto.havingStyle = function havingStyle(style) {
            if (this.style === style) {
              return this;
            } else {
              return this.extend({
                style,
                size: sizeAtStyle(this.textSize, style)
              });
            }
          };
          _proto.havingCrampedStyle = function havingCrampedStyle() {
            return this.havingStyle(this.style.cramp());
          };
          _proto.havingSize = function havingSize(size) {
            if (this.size === size && this.textSize === size) {
              return this;
            } else {
              return this.extend({
                style: this.style.text(),
                size,
                textSize: size,
                sizeMultiplier: sizeMultipliers[size - 1]
              });
            }
          };
          _proto.havingBaseStyle = function havingBaseStyle(style) {
            style = style || this.style.text();
            var wantSize = sizeAtStyle(Options2.BASESIZE, style);
            if (this.size === wantSize && this.textSize === Options2.BASESIZE && this.style === style) {
              return this;
            } else {
              return this.extend({
                style,
                size: wantSize
              });
            }
          };
          _proto.havingBaseSizing = function havingBaseSizing() {
            var size;
            switch (this.style.id) {
              case 4:
              case 5:
                size = 3;
                break;
              case 6:
              case 7:
                size = 1;
                break;
              default:
                size = 6;
            }
            return this.extend({
              style: this.style.text(),
              size
            });
          };
          _proto.withColor = function withColor(color) {
            return this.extend({
              color
            });
          };
          _proto.withPhantom = function withPhantom() {
            return this.extend({
              phantom: true
            });
          };
          _proto.withFont = function withFont(font) {
            return this.extend({
              font
            });
          };
          _proto.withTextFontFamily = function withTextFontFamily(fontFamily) {
            return this.extend({
              fontFamily,
              font: ""
            });
          };
          _proto.withTextFontWeight = function withTextFontWeight(fontWeight) {
            return this.extend({
              fontWeight,
              font: ""
            });
          };
          _proto.withTextFontShape = function withTextFontShape(fontShape) {
            return this.extend({
              fontShape,
              font: ""
            });
          };
          _proto.sizingClasses = function sizingClasses(oldOptions) {
            if (oldOptions.size !== this.size) {
              return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
            } else {
              return [];
            }
          };
          _proto.baseSizingClasses = function baseSizingClasses() {
            if (this.size !== Options2.BASESIZE) {
              return ["sizing", "reset-size" + this.size, "size" + Options2.BASESIZE];
            } else {
              return [];
            }
          };
          _proto.fontMetrics = function fontMetrics() {
            if (!this._fontMetrics) {
              this._fontMetrics = getGlobalMetrics(this.size);
            }
            return this._fontMetrics;
          };
          _proto.getColor = function getColor() {
            if (this.phantom) {
              return "transparent";
            } else {
              return this.color;
            }
          };
          return Options2;
        }();
        Options.BASESIZE = 6;
        var src_Options = Options;
        ;
        var ptPerUnit = {
          "pt": 1,
          "mm": 7227 / 2540,
          "cm": 7227 / 254,
          "in": 72.27,
          "bp": 803 / 800,
          "pc": 12,
          "dd": 1238 / 1157,
          "cc": 14856 / 1157,
          "nd": 685 / 642,
          "nc": 1370 / 107,
          "sp": 1 / 65536,
          "px": 803 / 800
        };
        var relativeUnit = {
          "ex": true,
          "em": true,
          "mu": true
        };
        var validUnit = function validUnit2(unit) {
          if (typeof unit !== "string") {
            unit = unit.unit;
          }
          return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
        };
        var calculateSize = function calculateSize2(sizeValue, options) {
          var scale;
          if (sizeValue.unit in ptPerUnit) {
            scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
          } else if (sizeValue.unit === "mu") {
            scale = options.fontMetrics().cssEmPerMu;
          } else {
            var unitOptions;
            if (options.style.isTight()) {
              unitOptions = options.havingStyle(options.style.text());
            } else {
              unitOptions = options;
            }
            if (sizeValue.unit === "ex") {
              scale = unitOptions.fontMetrics().xHeight;
            } else if (sizeValue.unit === "em") {
              scale = unitOptions.fontMetrics().quad;
            } else {
              throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
            }
            if (unitOptions !== options) {
              scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
            }
          }
          return Math.min(sizeValue.number * scale, options.maxSize);
        };
        ;
        var lookupSymbol = function lookupSymbol2(value, fontName, mode) {
          if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
            value = src_symbols[mode][value].replace;
          }
          return {
            value,
            metrics: getCharacterMetrics(value, fontName, mode)
          };
        };
        var makeSymbol = function makeSymbol2(value, fontName, mode, options, classes) {
          var lookup = lookupSymbol(value, fontName, mode);
          var metrics = lookup.metrics;
          value = lookup.value;
          var symbolNode;
          if (metrics) {
            var italic = metrics.italic;
            if (mode === "text" || options && options.font === "mathit") {
              italic = 0;
            }
            symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
          } else {
            typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
            symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
          }
          if (options) {
            symbolNode.maxFontSize = options.sizeMultiplier;
            if (options.style.isTight()) {
              symbolNode.classes.push("mtight");
            }
            var color = options.getColor();
            if (color) {
              symbolNode.style.color = color;
            }
          }
          return symbolNode;
        };
        var mathsym = function mathsym2(value, mode, options, classes) {
          if (classes === void 0) {
            classes = [];
          }
          if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
            return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
          } else if (value === "\\" || src_symbols[mode][value].font === "main") {
            return makeSymbol(value, "Main-Regular", mode, options, classes);
          } else {
            return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
          }
        };
        var boldsymbol = function boldsymbol2(value, mode, options, classes, type) {
          if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
            return {
              fontName: "Math-BoldItalic",
              fontClass: "boldsymbol"
            };
          } else {
            return {
              fontName: "Main-Bold",
              fontClass: "mathbf"
            };
          }
        };
        var makeOrd = function makeOrd2(group, options, type) {
          var mode = group.mode;
          var text = group.text;
          var classes = ["mord"];
          var isFont = mode === "math" || mode === "text" && options.font;
          var fontOrFamily = isFont ? options.font : options.fontFamily;
          if (text.charCodeAt(0) === 55349) {
            var _wideCharacterFont = wideCharacterFont(text, mode), wideFontName = _wideCharacterFont[0], wideFontClass = _wideCharacterFont[1];
            return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
          } else if (fontOrFamily) {
            var fontName;
            var fontClasses;
            if (fontOrFamily === "boldsymbol") {
              var fontData = boldsymbol(text, mode, options, classes, type);
              fontName = fontData.fontName;
              fontClasses = [fontData.fontClass];
            } else if (isFont) {
              fontName = fontMap[fontOrFamily].fontName;
              fontClasses = [fontOrFamily];
            } else {
              fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
              fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
            }
            if (lookupSymbol(text, fontName, mode).metrics) {
              return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
            } else if (ligatures.hasOwnProperty(text) && fontName.substr(0, 10) === "Typewriter") {
              var parts = [];
              for (var i2 = 0; i2 < text.length; i2++) {
                parts.push(makeSymbol(text[i2], fontName, mode, options, classes.concat(fontClasses)));
              }
              return makeFragment(parts);
            }
          }
          if (type === "mathord") {
            return makeSymbol(text, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
          } else if (type === "textord") {
            var font = src_symbols[mode][text] && src_symbols[mode][text].font;
            if (font === "ams") {
              var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
              return makeSymbol(text, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
            } else if (font === "main" || !font) {
              var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
              return makeSymbol(text, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
            } else {
              var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
              return makeSymbol(text, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
            }
          } else {
            throw new Error("unexpected type: " + type + " in makeOrd");
          }
        };
        var canCombine = function canCombine2(prev, next) {
          if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
            return false;
          }
          if (prev.classes.length === 1) {
            var cls = prev.classes[0];
            if (cls === "mbin" || cls === "mord") {
              return false;
            }
          }
          for (var style in prev.style) {
            if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
              return false;
            }
          }
          for (var _style in next.style) {
            if (next.style.hasOwnProperty(_style) && prev.style[_style] !== next.style[_style]) {
              return false;
            }
          }
          return true;
        };
        var tryCombineChars = function tryCombineChars2(chars) {
          for (var i2 = 0; i2 < chars.length - 1; i2++) {
            var prev = chars[i2];
            var next = chars[i2 + 1];
            if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
              prev.text += next.text;
              prev.height = Math.max(prev.height, next.height);
              prev.depth = Math.max(prev.depth, next.depth);
              prev.italic = next.italic;
              chars.splice(i2 + 1, 1);
              i2--;
            }
          }
          return chars;
        };
        var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
          var height = 0;
          var depth = 0;
          var maxFontSize = 0;
          for (var i2 = 0; i2 < elem.children.length; i2++) {
            var child = elem.children[i2];
            if (child.height > height) {
              height = child.height;
            }
            if (child.depth > depth) {
              depth = child.depth;
            }
            if (child.maxFontSize > maxFontSize) {
              maxFontSize = child.maxFontSize;
            }
          }
          elem.height = height;
          elem.depth = depth;
          elem.maxFontSize = maxFontSize;
        };
        var makeSpan = function makeSpan2(classes, children, options, style) {
          var span = new Span(classes, children, options, style);
          sizeElementFromChildren(span);
          return span;
        };
        var makeSvgSpan = function makeSvgSpan2(classes, children, options, style) {
          return new Span(classes, children, options, style);
        };
        var makeLineSpan = function makeLineSpan2(className, options, thickness) {
          var line = makeSpan([className], [], options);
          line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
          line.style.borderBottomWidth = line.height + "em";
          line.maxFontSize = 1;
          return line;
        };
        var makeAnchor = function makeAnchor2(href, classes, children, options) {
          var anchor = new Anchor(href, classes, children, options);
          sizeElementFromChildren(anchor);
          return anchor;
        };
        var makeFragment = function makeFragment2(children) {
          var fragment = new DocumentFragment(children);
          sizeElementFromChildren(fragment);
          return fragment;
        };
        var wrapFragment = function wrapFragment2(group, options) {
          if (group instanceof DocumentFragment) {
            return makeSpan([], [group], options);
          }
          return group;
        };
        var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
          if (params.positionType === "individualShift") {
            var oldChildren = params.children;
            var children = [oldChildren[0]];
            var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
            var currPos = _depth;
            for (var i2 = 1; i2 < oldChildren.length; i2++) {
              var diff = -oldChildren[i2].shift - currPos - oldChildren[i2].elem.depth;
              var size = diff - (oldChildren[i2 - 1].elem.height + oldChildren[i2 - 1].elem.depth);
              currPos = currPos + diff;
              children.push({
                type: "kern",
                size
              });
              children.push(oldChildren[i2]);
            }
            return {
              children,
              depth: _depth
            };
          }
          var depth;
          if (params.positionType === "top") {
            var bottom = params.positionData;
            for (var _i6 = 0; _i6 < params.children.length; _i6++) {
              var child = params.children[_i6];
              bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
            }
            depth = bottom;
          } else if (params.positionType === "bottom") {
            depth = -params.positionData;
          } else {
            var firstChild = params.children[0];
            if (firstChild.type !== "elem") {
              throw new Error('First child must have type "elem".');
            }
            if (params.positionType === "shift") {
              depth = -firstChild.elem.depth - params.positionData;
            } else if (params.positionType === "firstBaseline") {
              depth = -firstChild.elem.depth;
            } else {
              throw new Error("Invalid positionType " + params.positionType + ".");
            }
          }
          return {
            children: params.children,
            depth
          };
        };
        var makeVList = function makeVList2(params, options) {
          var _getVListChildrenAndD = getVListChildrenAndDepth(params), children = _getVListChildrenAndD.children, depth = _getVListChildrenAndD.depth;
          var pstrutSize = 0;
          for (var i2 = 0; i2 < children.length; i2++) {
            var child = children[i2];
            if (child.type === "elem") {
              var elem = child.elem;
              pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
            }
          }
          pstrutSize += 2;
          var pstrut = makeSpan(["pstrut"], []);
          pstrut.style.height = pstrutSize + "em";
          var realChildren = [];
          var minPos = depth;
          var maxPos = depth;
          var currPos = depth;
          for (var _i22 = 0; _i22 < children.length; _i22++) {
            var _child = children[_i22];
            if (_child.type === "kern") {
              currPos += _child.size;
            } else {
              var _elem = _child.elem;
              var classes = _child.wrapperClasses || [];
              var style = _child.wrapperStyle || {};
              var childWrap = makeSpan(classes, [pstrut, _elem], void 0, style);
              childWrap.style.top = -pstrutSize - currPos - _elem.depth + "em";
              if (_child.marginLeft) {
                childWrap.style.marginLeft = _child.marginLeft;
              }
              if (_child.marginRight) {
                childWrap.style.marginRight = _child.marginRight;
              }
              realChildren.push(childWrap);
              currPos += _elem.height + _elem.depth;
            }
            minPos = Math.min(minPos, currPos);
            maxPos = Math.max(maxPos, currPos);
          }
          var vlist = makeSpan(["vlist"], realChildren);
          vlist.style.height = maxPos + "em";
          var rows;
          if (minPos < 0) {
            var emptySpan = makeSpan([], []);
            var depthStrut = makeSpan(["vlist"], [emptySpan]);
            depthStrut.style.height = -minPos + "em";
            var topStrut = makeSpan(["vlist-s"], [new SymbolNode("\u200B")]);
            rows = [makeSpan(["vlist-r"], [vlist, topStrut]), makeSpan(["vlist-r"], [depthStrut])];
          } else {
            rows = [makeSpan(["vlist-r"], [vlist])];
          }
          var vtable = makeSpan(["vlist-t"], rows);
          if (rows.length === 2) {
            vtable.classes.push("vlist-t2");
          }
          vtable.height = maxPos;
          vtable.depth = -minPos;
          return vtable;
        };
        var makeGlue = function makeGlue2(measurement, options) {
          var rule = makeSpan(["mspace"], [], options);
          var size = calculateSize(measurement, options);
          rule.style.marginRight = size + "em";
          return rule;
        };
        var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
          var baseFontName = "";
          switch (fontFamily) {
            case "amsrm":
              baseFontName = "AMS";
              break;
            case "textrm":
              baseFontName = "Main";
              break;
            case "textsf":
              baseFontName = "SansSerif";
              break;
            case "texttt":
              baseFontName = "Typewriter";
              break;
            default:
              baseFontName = fontFamily;
          }
          var fontStylesName;
          if (fontWeight === "textbf" && fontShape === "textit") {
            fontStylesName = "BoldItalic";
          } else if (fontWeight === "textbf") {
            fontStylesName = "Bold";
          } else if (fontWeight === "textit") {
            fontStylesName = "Italic";
          } else {
            fontStylesName = "Regular";
          }
          return baseFontName + "-" + fontStylesName;
        };
        var fontMap = {
          "mathbf": {
            variant: "bold",
            fontName: "Main-Bold"
          },
          "mathrm": {
            variant: "normal",
            fontName: "Main-Regular"
          },
          "textit": {
            variant: "italic",
            fontName: "Main-Italic"
          },
          "mathit": {
            variant: "italic",
            fontName: "Main-Italic"
          },
          "mathnormal": {
            variant: "italic",
            fontName: "Math-Italic"
          },
          "mathbb": {
            variant: "double-struck",
            fontName: "AMS-Regular"
          },
          "mathcal": {
            variant: "script",
            fontName: "Caligraphic-Regular"
          },
          "mathfrak": {
            variant: "fraktur",
            fontName: "Fraktur-Regular"
          },
          "mathscr": {
            variant: "script",
            fontName: "Script-Regular"
          },
          "mathsf": {
            variant: "sans-serif",
            fontName: "SansSerif-Regular"
          },
          "mathtt": {
            variant: "monospace",
            fontName: "Typewriter-Regular"
          }
        };
        var svgData = {
          vec: ["vec", 0.471, 0.714],
          oiintSize1: ["oiintSize1", 0.957, 0.499],
          oiintSize2: ["oiintSize2", 1.472, 0.659],
          oiiintSize1: ["oiiintSize1", 1.304, 0.499],
          oiiintSize2: ["oiiintSize2", 1.98, 0.659]
        };
        var staticSvg = function staticSvg2(value, options) {
          var _svgData$value = svgData[value], pathName = _svgData$value[0], width = _svgData$value[1], height = _svgData$value[2];
          var path2 = new PathNode(pathName);
          var svgNode = new SvgNode([path2], {
            "width": width + "em",
            "height": height + "em",
            "style": "width:" + width + "em",
            "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
            "preserveAspectRatio": "xMinYMin"
          });
          var span = makeSvgSpan(["overlay"], [svgNode], options);
          span.height = height;
          span.style.height = height + "em";
          span.style.width = width + "em";
          return span;
        };
        var buildCommon = {
          fontMap,
          makeSymbol,
          mathsym,
          makeSpan,
          makeSvgSpan,
          makeLineSpan,
          makeAnchor,
          makeFragment,
          wrapFragment,
          makeVList,
          makeOrd,
          makeGlue,
          staticSvg,
          svgData,
          tryCombineChars
        };
        ;
        var thinspace = {
          number: 3,
          unit: "mu"
        };
        var mediumspace = {
          number: 4,
          unit: "mu"
        };
        var thickspace = {
          number: 5,
          unit: "mu"
        };
        var spacings = {
          mord: {
            mop: thinspace,
            mbin: mediumspace,
            mrel: thickspace,
            minner: thinspace
          },
          mop: {
            mord: thinspace,
            mop: thinspace,
            mrel: thickspace,
            minner: thinspace
          },
          mbin: {
            mord: mediumspace,
            mop: mediumspace,
            mopen: mediumspace,
            minner: mediumspace
          },
          mrel: {
            mord: thickspace,
            mop: thickspace,
            mopen: thickspace,
            minner: thickspace
          },
          mopen: {},
          mclose: {
            mop: thinspace,
            mbin: mediumspace,
            mrel: thickspace,
            minner: thinspace
          },
          mpunct: {
            mord: thinspace,
            mop: thinspace,
            mrel: thickspace,
            mopen: thinspace,
            mclose: thinspace,
            mpunct: thinspace,
            minner: thinspace
          },
          minner: {
            mord: thinspace,
            mop: thinspace,
            mbin: mediumspace,
            mrel: thickspace,
            mopen: thinspace,
            mpunct: thinspace,
            minner: thinspace
          }
        };
        var tightSpacings = {
          mord: {
            mop: thinspace
          },
          mop: {
            mord: thinspace,
            mop: thinspace
          },
          mbin: {},
          mrel: {},
          mopen: {},
          mclose: {
            mop: thinspace
          },
          mpunct: {},
          minner: {
            mop: thinspace
          }
        };
        ;
        var _functions = {};
        var _htmlGroupBuilders = {};
        var _mathmlGroupBuilders = {};
        function defineFunction(_ref) {
          var type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder2 = _ref.htmlBuilder, mathmlBuilder2 = _ref.mathmlBuilder;
          var data = {
            type,
            numArgs: props.numArgs,
            argTypes: props.argTypes,
            allowedInArgument: !!props.allowedInArgument,
            allowedInText: !!props.allowedInText,
            allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
            numOptionalArgs: props.numOptionalArgs || 0,
            infix: !!props.infix,
            primitive: !!props.primitive,
            handler
          };
          for (var i2 = 0; i2 < names.length; ++i2) {
            _functions[names[i2]] = data;
          }
          if (type) {
            if (htmlBuilder2) {
              _htmlGroupBuilders[type] = htmlBuilder2;
            }
            if (mathmlBuilder2) {
              _mathmlGroupBuilders[type] = mathmlBuilder2;
            }
          }
        }
        function defineFunctionBuilders(_ref2) {
          var type = _ref2.type, htmlBuilder2 = _ref2.htmlBuilder, mathmlBuilder2 = _ref2.mathmlBuilder;
          defineFunction({
            type,
            names: [],
            props: {
              numArgs: 0
            },
            handler: function handler() {
              throw new Error("Should never be called.");
            },
            htmlBuilder: htmlBuilder2,
            mathmlBuilder: mathmlBuilder2
          });
        }
        var normalizeArgument = function normalizeArgument2(arg) {
          return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
        };
        var ordargument = function ordargument2(arg) {
          return arg.type === "ordgroup" ? arg.body : [arg];
        };
        ;
        var buildHTML_makeSpan = buildCommon.makeSpan;
        var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
        var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
        var styleMap = {
          "display": src_Style.DISPLAY,
          "text": src_Style.TEXT,
          "script": src_Style.SCRIPT,
          "scriptscript": src_Style.SCRIPTSCRIPT
        };
        var DomEnum = {
          mord: "mord",
          mop: "mop",
          mbin: "mbin",
          mrel: "mrel",
          mopen: "mopen",
          mclose: "mclose",
          mpunct: "mpunct",
          minner: "minner"
        };
        var buildExpression = function buildExpression2(expression, options, isRealGroup, surrounding) {
          if (surrounding === void 0) {
            surrounding = [null, null];
          }
          var groups = [];
          for (var i2 = 0; i2 < expression.length; i2++) {
            var output = buildGroup(expression[i2], options);
            if (output instanceof DocumentFragment) {
              var children = output.children;
              groups.push.apply(groups, children);
            } else {
              groups.push(output);
            }
          }
          buildCommon.tryCombineChars(groups);
          if (!isRealGroup) {
            return groups;
          }
          var glueOptions = options;
          if (expression.length === 1) {
            var node = expression[0];
            if (node.type === "sizing") {
              glueOptions = options.havingSize(node.size);
            } else if (node.type === "styling") {
              glueOptions = options.havingStyle(styleMap[node.style]);
            }
          }
          var dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
          var dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
          var isRoot = isRealGroup === "root";
          traverseNonSpaceNodes(groups, function(node2, prev) {
            var prevType = prev.classes[0];
            var type = node2.classes[0];
            if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
              prev.classes[0] = "mord";
            } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
              node2.classes[0] = "mord";
            }
          }, {
            node: dummyPrev
          }, dummyNext, isRoot);
          traverseNonSpaceNodes(groups, function(node2, prev) {
            var prevType = getTypeOfDomTree(prev);
            var type = getTypeOfDomTree(node2);
            var space = prevType && type ? node2.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
            if (space) {
              return buildCommon.makeGlue(space, glueOptions);
            }
          }, {
            node: dummyPrev
          }, dummyNext, isRoot);
          return groups;
        };
        var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev, next, isRoot) {
          if (next) {
            nodes.push(next);
          }
          var i2 = 0;
          for (; i2 < nodes.length; i2++) {
            var node = nodes[i2];
            var partialGroup = checkPartialGroup(node);
            if (partialGroup) {
              traverseNonSpaceNodes2(partialGroup.children, callback, prev, null, isRoot);
              continue;
            }
            var nonspace = !node.hasClass("mspace");
            if (nonspace) {
              var result = callback(node, prev.node);
              if (result) {
                if (prev.insertAfter) {
                  prev.insertAfter(result);
                } else {
                  nodes.unshift(result);
                  i2++;
                }
              }
            }
            if (nonspace) {
              prev.node = node;
            } else if (isRoot && node.hasClass("newline")) {
              prev.node = buildHTML_makeSpan(["leftmost"]);
            }
            prev.insertAfter = function(index) {
              return function(n) {
                nodes.splice(index + 1, 0, n);
                i2++;
              };
            }(i2);
          }
          if (next) {
            nodes.pop();
          }
        };
        var checkPartialGroup = function checkPartialGroup2(node) {
          if (node instanceof DocumentFragment || node instanceof Anchor || node instanceof Span && node.hasClass("enclosing")) {
            return node;
          }
          return null;
        };
        var getOutermostNode = function getOutermostNode2(node, side) {
          var partialGroup = checkPartialGroup(node);
          if (partialGroup) {
            var children = partialGroup.children;
            if (children.length) {
              if (side === "right") {
                return getOutermostNode2(children[children.length - 1], "right");
              } else if (side === "left") {
                return getOutermostNode2(children[0], "left");
              }
            }
          }
          return node;
        };
        var getTypeOfDomTree = function getTypeOfDomTree2(node, side) {
          if (!node) {
            return null;
          }
          if (side) {
            node = getOutermostNode(node, side);
          }
          return DomEnum[node.classes[0]] || null;
        };
        var makeNullDelimiter = function makeNullDelimiter2(options, classes) {
          var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
          return buildHTML_makeSpan(classes.concat(moreClasses));
        };
        var buildGroup = function buildGroup2(group, options, baseOptions) {
          if (!group) {
            return buildHTML_makeSpan();
          }
          if (_htmlGroupBuilders[group.type]) {
            var groupNode = _htmlGroupBuilders[group.type](group, options);
            if (baseOptions && options.size !== baseOptions.size) {
              groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
              var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
              groupNode.height *= multiplier;
              groupNode.depth *= multiplier;
            }
            return groupNode;
          } else {
            throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
          }
        };
        function buildHTMLUnbreakable(children, options) {
          var body = buildHTML_makeSpan(["base"], children, options);
          var strut = buildHTML_makeSpan(["strut"]);
          strut.style.height = body.height + body.depth + "em";
          strut.style.verticalAlign = -body.depth + "em";
          body.children.unshift(strut);
          return body;
        }
        function buildHTML(tree, options) {
          var tag = null;
          if (tree.length === 1 && tree[0].type === "tag") {
            tag = tree[0].tag;
            tree = tree[0].body;
          }
          var expression = buildExpression(tree, options, "root");
          var eqnNum;
          if (expression.length === 2 && expression[1].hasClass("tag")) {
            eqnNum = expression.pop();
          }
          var children = [];
          var parts = [];
          for (var i2 = 0; i2 < expression.length; i2++) {
            parts.push(expression[i2]);
            if (expression[i2].hasClass("mbin") || expression[i2].hasClass("mrel") || expression[i2].hasClass("allowbreak")) {
              var nobreak = false;
              while (i2 < expression.length - 1 && expression[i2 + 1].hasClass("mspace") && !expression[i2 + 1].hasClass("newline")) {
                i2++;
                parts.push(expression[i2]);
                if (expression[i2].hasClass("nobreak")) {
                  nobreak = true;
                }
              }
              if (!nobreak) {
                children.push(buildHTMLUnbreakable(parts, options));
                parts = [];
              }
            } else if (expression[i2].hasClass("newline")) {
              parts.pop();
              if (parts.length > 0) {
                children.push(buildHTMLUnbreakable(parts, options));
                parts = [];
              }
              children.push(expression[i2]);
            }
          }
          if (parts.length > 0) {
            children.push(buildHTMLUnbreakable(parts, options));
          }
          var tagChild;
          if (tag) {
            tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));
            tagChild.classes = ["tag"];
            children.push(tagChild);
          } else if (eqnNum) {
            children.push(eqnNum);
          }
          var htmlNode = buildHTML_makeSpan(["katex-html"], children);
          htmlNode.setAttribute("aria-hidden", "true");
          if (tagChild) {
            var strut = tagChild.children[0];
            strut.style.height = htmlNode.height + htmlNode.depth + "em";
            strut.style.verticalAlign = -htmlNode.depth + "em";
          }
          return htmlNode;
        }
        ;
        function newDocumentFragment(children) {
          return new DocumentFragment(children);
        }
        var MathNode = /* @__PURE__ */ function() {
          function MathNode2(type, children, classes) {
            this.type = void 0;
            this.attributes = void 0;
            this.children = void 0;
            this.classes = void 0;
            this.type = type;
            this.attributes = {};
            this.children = children || [];
            this.classes = classes || [];
          }
          var _proto = MathNode2.prototype;
          _proto.setAttribute = function setAttribute(name2, value) {
            this.attributes[name2] = value;
          };
          _proto.getAttribute = function getAttribute(name2) {
            return this.attributes[name2];
          };
          _proto.toNode = function toNode() {
            var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
            for (var attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                node.setAttribute(attr, this.attributes[attr]);
              }
            }
            if (this.classes.length > 0) {
              node.className = createClass(this.classes);
            }
            for (var i2 = 0; i2 < this.children.length; i2++) {
              node.appendChild(this.children[i2].toNode());
            }
            return node;
          };
          _proto.toMarkup = function toMarkup() {
            var markup = "<" + this.type;
            for (var attr in this.attributes) {
              if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                markup += " " + attr + '="';
                markup += utils.escape(this.attributes[attr]);
                markup += '"';
              }
            }
            if (this.classes.length > 0) {
              markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
            }
            markup += ">";
            for (var i2 = 0; i2 < this.children.length; i2++) {
              markup += this.children[i2].toMarkup();
            }
            markup += "</" + this.type + ">";
            return markup;
          };
          _proto.toText = function toText() {
            return this.children.map(function(child) {
              return child.toText();
            }).join("");
          };
          return MathNode2;
        }();
        var TextNode2 = /* @__PURE__ */ function() {
          function TextNode3(text) {
            this.text = void 0;
            this.text = text;
          }
          var _proto2 = TextNode3.prototype;
          _proto2.toNode = function toNode() {
            return document.createTextNode(this.text);
          };
          _proto2.toMarkup = function toMarkup() {
            return utils.escape(this.toText());
          };
          _proto2.toText = function toText() {
            return this.text;
          };
          return TextNode3;
        }();
        var SpaceNode = /* @__PURE__ */ function() {
          function SpaceNode2(width) {
            this.width = void 0;
            this.character = void 0;
            this.width = width;
            if (width >= 0.05555 && width <= 0.05556) {
              this.character = "\u200A";
            } else if (width >= 0.1666 && width <= 0.1667) {
              this.character = "\u2009";
            } else if (width >= 0.2222 && width <= 0.2223) {
              this.character = "\u2005";
            } else if (width >= 0.2777 && width <= 0.2778) {
              this.character = "\u2005\u200A";
            } else if (width >= -0.05556 && width <= -0.05555) {
              this.character = "\u200A\u2063";
            } else if (width >= -0.1667 && width <= -0.1666) {
              this.character = "\u2009\u2063";
            } else if (width >= -0.2223 && width <= -0.2222) {
              this.character = "\u205F\u2063";
            } else if (width >= -0.2778 && width <= -0.2777) {
              this.character = "\u2005\u2063";
            } else {
              this.character = null;
            }
          }
          var _proto3 = SpaceNode2.prototype;
          _proto3.toNode = function toNode() {
            if (this.character) {
              return document.createTextNode(this.character);
            } else {
              var node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
              node.setAttribute("width", this.width + "em");
              return node;
            }
          };
          _proto3.toMarkup = function toMarkup() {
            if (this.character) {
              return "<mtext>" + this.character + "</mtext>";
            } else {
              return '<mspace width="' + this.width + 'em"/>';
            }
          };
          _proto3.toText = function toText() {
            if (this.character) {
              return this.character;
            } else {
              return " ";
            }
          };
          return SpaceNode2;
        }();
        var mathMLTree = {
          MathNode,
          TextNode: TextNode2,
          SpaceNode,
          newDocumentFragment
        };
        ;
        var makeText = function makeText2(text, mode, options) {
          if (src_symbols[mode][text] && src_symbols[mode][text].replace && text.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.substr(4, 2) === "tt" || options.font && options.font.substr(4, 2) === "tt"))) {
            text = src_symbols[mode][text].replace;
          }
          return new mathMLTree.TextNode(text);
        };
        var makeRow = function makeRow2(body) {
          if (body.length === 1) {
            return body[0];
          } else {
            return new mathMLTree.MathNode("mrow", body);
          }
        };
        var getVariant = function getVariant2(group, options) {
          if (options.fontFamily === "texttt") {
            return "monospace";
          } else if (options.fontFamily === "textsf") {
            if (options.fontShape === "textit" && options.fontWeight === "textbf") {
              return "sans-serif-bold-italic";
            } else if (options.fontShape === "textit") {
              return "sans-serif-italic";
            } else if (options.fontWeight === "textbf") {
              return "bold-sans-serif";
            } else {
              return "sans-serif";
            }
          } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
            return "bold-italic";
          } else if (options.fontShape === "textit") {
            return "italic";
          } else if (options.fontWeight === "textbf") {
            return "bold";
          }
          var font = options.font;
          if (!font || font === "mathnormal") {
            return null;
          }
          var mode = group.mode;
          if (font === "mathit") {
            return "italic";
          } else if (font === "boldsymbol") {
            return group.type === "textord" ? "bold" : "bold-italic";
          } else if (font === "mathbf") {
            return "bold";
          } else if (font === "mathbb") {
            return "double-struck";
          } else if (font === "mathfrak") {
            return "fraktur";
          } else if (font === "mathscr" || font === "mathcal") {
            return "script";
          } else if (font === "mathsf") {
            return "sans-serif";
          } else if (font === "mathtt") {
            return "monospace";
          }
          var text = group.text;
          if (utils.contains(["\\imath", "\\jmath"], text)) {
            return null;
          }
          if (src_symbols[mode][text] && src_symbols[mode][text].replace) {
            text = src_symbols[mode][text].replace;
          }
          var fontName = buildCommon.fontMap[font].fontName;
          if (getCharacterMetrics(text, fontName, mode)) {
            return buildCommon.fontMap[font].variant;
          }
          return null;
        };
        var buildMathML_buildExpression = function buildExpression2(expression, options, isOrdgroup) {
          if (expression.length === 1) {
            var group = buildMathML_buildGroup(expression[0], options);
            if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
              group.setAttribute("lspace", "0em");
              group.setAttribute("rspace", "0em");
            }
            return [group];
          }
          var groups = [];
          var lastGroup;
          for (var i2 = 0; i2 < expression.length; i2++) {
            var _group = buildMathML_buildGroup(expression[i2], options);
            if (_group instanceof MathNode && lastGroup instanceof MathNode) {
              if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
                var _lastGroup$children;
                (_lastGroup$children = lastGroup.children).push.apply(_lastGroup$children, _group.children);
                continue;
              } else if (_group.type === "mn" && lastGroup.type === "mn") {
                var _lastGroup$children2;
                (_lastGroup$children2 = lastGroup.children).push.apply(_lastGroup$children2, _group.children);
                continue;
              } else if (_group.type === "mi" && _group.children.length === 1 && lastGroup.type === "mn") {
                var child = _group.children[0];
                if (child instanceof TextNode2 && child.text === ".") {
                  var _lastGroup$children3;
                  (_lastGroup$children3 = lastGroup.children).push.apply(_lastGroup$children3, _group.children);
                  continue;
                }
              } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
                var lastChild = lastGroup.children[0];
                if (lastChild instanceof TextNode2 && lastChild.text === "\u0338" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
                  var _child = _group.children[0];
                  if (_child instanceof TextNode2 && _child.text.length > 0) {
                    _child.text = _child.text.slice(0, 1) + "\u0338" + _child.text.slice(1);
                    groups.pop();
                  }
                }
              }
            }
            groups.push(_group);
            lastGroup = _group;
          }
          return groups;
        };
        var buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
          return makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));
        };
        var buildMathML_buildGroup = function buildGroup2(group, options) {
          if (!group) {
            return new mathMLTree.MathNode("mrow");
          }
          if (_mathmlGroupBuilders[group.type]) {
            var result = _mathmlGroupBuilders[group.type](group, options);
            return result;
          } else {
            throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
          }
        };
        function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
          var expression = buildMathML_buildExpression(tree, options);
          var wrapper;
          if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
            wrapper = expression[0];
          } else {
            wrapper = new mathMLTree.MathNode("mrow", expression);
          }
          var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
          annotation.setAttribute("encoding", "application/x-tex");
          var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
          var math2 = new mathMLTree.MathNode("math", [semantics]);
          math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
          if (isDisplayMode) {
            math2.setAttribute("display", "block");
          }
          var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
          return buildCommon.makeSpan([wrapperClass], [math2]);
        }
        ;
        var optionsFromSettings = function optionsFromSettings2(settings) {
          return new src_Options({
            style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
            maxSize: settings.maxSize,
            minRuleThickness: settings.minRuleThickness
          });
        };
        var displayWrap = function displayWrap2(node, settings) {
          if (settings.displayMode) {
            var classes = ["katex-display"];
            if (settings.leqno) {
              classes.push("leqno");
            }
            if (settings.fleqn) {
              classes.push("fleqn");
            }
            node = buildCommon.makeSpan(classes, [node]);
          }
          return node;
        };
        var buildTree2 = function buildTree3(tree, expression, settings) {
          var options = optionsFromSettings(settings);
          var katexNode;
          if (settings.output === "mathml") {
            return buildMathML(tree, expression, options, settings.displayMode, true);
          } else if (settings.output === "html") {
            var htmlNode = buildHTML(tree, options);
            katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
          } else {
            var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
            var _htmlNode = buildHTML(tree, options);
            katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
          }
          return displayWrap(katexNode, settings);
        };
        var buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
          var options = optionsFromSettings(settings);
          var htmlNode = buildHTML(tree, options);
          var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
          return displayWrap(katexNode, settings);
        };
        var src_buildTree = null;
        ;
        var stretchyCodePoint = {
          widehat: "^",
          widecheck: "\u02C7",
          widetilde: "~",
          utilde: "~",
          overleftarrow: "\u2190",
          underleftarrow: "\u2190",
          xleftarrow: "\u2190",
          overrightarrow: "\u2192",
          underrightarrow: "\u2192",
          xrightarrow: "\u2192",
          underbrace: "\u23DF",
          overbrace: "\u23DE",
          overgroup: "\u23E0",
          undergroup: "\u23E1",
          overleftrightarrow: "\u2194",
          underleftrightarrow: "\u2194",
          xleftrightarrow: "\u2194",
          Overrightarrow: "\u21D2",
          xRightarrow: "\u21D2",
          overleftharpoon: "\u21BC",
          xleftharpoonup: "\u21BC",
          overrightharpoon: "\u21C0",
          xrightharpoonup: "\u21C0",
          xLeftarrow: "\u21D0",
          xLeftrightarrow: "\u21D4",
          xhookleftarrow: "\u21A9",
          xhookrightarrow: "\u21AA",
          xmapsto: "\u21A6",
          xrightharpoondown: "\u21C1",
          xleftharpoondown: "\u21BD",
          xrightleftharpoons: "\u21CC",
          xleftrightharpoons: "\u21CB",
          xtwoheadleftarrow: "\u219E",
          xtwoheadrightarrow: "\u21A0",
          xlongequal: "=",
          xtofrom: "\u21C4",
          xrightleftarrows: "\u21C4",
          xrightequilibrium: "\u21CC",
          xleftequilibrium: "\u21CB",
          "\\cdrightarrow": "\u2192",
          "\\cdleftarrow": "\u2190",
          "\\cdlongequal": "="
        };
        var mathMLnode = function mathMLnode2(label) {
          var node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
          node.setAttribute("stretchy", "true");
          return node;
        };
        var katexImagesData = {
          overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
          overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
          underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
          underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
          xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
          "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
          xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
          "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
          Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
          xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
          xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
          overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
          xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
          xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
          overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
          xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
          xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
          xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
          "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
          xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
          xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
          overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
          overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
          underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
          underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
          xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
          xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
          xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
          xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
          xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
          xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
          overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
          underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
          overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
          undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
          xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
          xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
          xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
          xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
          xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
        };
        var groupLength = function groupLength2(arg) {
          if (arg.type === "ordgroup") {
            return arg.body.length;
          } else {
            return 1;
          }
        };
        var svgSpan = function svgSpan2(group, options) {
          function buildSvgSpan_() {
            var viewBoxWidth = 4e5;
            var label = group.label.substr(1);
            if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
              var grp = group;
              var numChars = groupLength(grp.base);
              var viewBoxHeight;
              var pathName;
              var _height;
              if (numChars > 5) {
                if (label === "widehat" || label === "widecheck") {
                  viewBoxHeight = 420;
                  viewBoxWidth = 2364;
                  _height = 0.42;
                  pathName = label + "4";
                } else {
                  viewBoxHeight = 312;
                  viewBoxWidth = 2340;
                  _height = 0.34;
                  pathName = "tilde4";
                }
              } else {
                var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
                if (label === "widehat" || label === "widecheck") {
                  viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                  viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                  _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                  pathName = label + imgIndex;
                } else {
                  viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                  viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                  _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                  pathName = "tilde" + imgIndex;
                }
              }
              var path2 = new PathNode(pathName);
              var svgNode = new SvgNode([path2], {
                "width": "100%",
                "height": _height + "em",
                "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                "preserveAspectRatio": "none"
              });
              return {
                span: buildCommon.makeSvgSpan([], [svgNode], options),
                minWidth: 0,
                height: _height
              };
            } else {
              var spans = [];
              var data = katexImagesData[label];
              var paths = data[0], _minWidth = data[1], _viewBoxHeight = data[2];
              var _height2 = _viewBoxHeight / 1e3;
              var numSvgChildren = paths.length;
              var widthClasses;
              var aligns;
              if (numSvgChildren === 1) {
                var align1 = data[3];
                widthClasses = ["hide-tail"];
                aligns = [align1];
              } else if (numSvgChildren === 2) {
                widthClasses = ["halfarrow-left", "halfarrow-right"];
                aligns = ["xMinYMin", "xMaxYMin"];
              } else if (numSvgChildren === 3) {
                widthClasses = ["brace-left", "brace-center", "brace-right"];
                aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
              } else {
                throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
              }
              for (var i2 = 0; i2 < numSvgChildren; i2++) {
                var _path = new PathNode(paths[i2]);
                var _svgNode = new SvgNode([_path], {
                  "width": "400em",
                  "height": _height2 + "em",
                  "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
                  "preserveAspectRatio": aligns[i2] + " slice"
                });
                var _span = buildCommon.makeSvgSpan([widthClasses[i2]], [_svgNode], options);
                if (numSvgChildren === 1) {
                  return {
                    span: _span,
                    minWidth: _minWidth,
                    height: _height2
                  };
                } else {
                  _span.style.height = _height2 + "em";
                  spans.push(_span);
                }
              }
              return {
                span: buildCommon.makeSpan(["stretchy"], spans, options),
                minWidth: _minWidth,
                height: _height2
              };
            }
          }
          var _buildSvgSpan_ = buildSvgSpan_(), span = _buildSvgSpan_.span, minWidth = _buildSvgSpan_.minWidth, height = _buildSvgSpan_.height;
          span.height = height;
          span.style.height = height + "em";
          if (minWidth > 0) {
            span.style.minWidth = minWidth + "em";
          }
          return span;
        };
        var encloseSpan = function encloseSpan2(inner2, label, topPad, bottomPad, options) {
          var img;
          var totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
          if (/fbox|color|angl/.test(label)) {
            img = buildCommon.makeSpan(["stretchy", label], [], options);
            if (label === "fbox") {
              var color = options.color && options.getColor();
              if (color) {
                img.style.borderColor = color;
              }
            }
          } else {
            var lines = [];
            if (/^[bx]cancel$/.test(label)) {
              lines.push(new LineNode({
                "x1": "0",
                "y1": "0",
                "x2": "100%",
                "y2": "100%",
                "stroke-width": "0.046em"
              }));
            }
            if (/^x?cancel$/.test(label)) {
              lines.push(new LineNode({
                "x1": "0",
                "y1": "100%",
                "x2": "100%",
                "y2": "0",
                "stroke-width": "0.046em"
              }));
            }
            var svgNode = new SvgNode(lines, {
              "width": "100%",
              "height": totalHeight + "em"
            });
            img = buildCommon.makeSvgSpan([], [svgNode], options);
          }
          img.height = totalHeight;
          img.style.height = totalHeight + "em";
          return img;
        };
        var stretchy = {
          encloseSpan,
          mathMLnode,
          svgSpan
        };
        ;
        function assertNodeType(node, type) {
          if (!node || node.type !== type) {
            throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
          }
          return node;
        }
        function assertSymbolNodeType(node) {
          var typedNode = checkSymbolNodeType(node);
          if (!typedNode) {
            throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
          }
          return typedNode;
        }
        function checkSymbolNodeType(node) {
          if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
            return node;
          }
          return null;
        }
        ;
        var htmlBuilder = function htmlBuilder2(grp, options) {
          var base2;
          var group;
          var supSubGroup;
          if (grp && grp.type === "supsub") {
            group = assertNodeType(grp.base, "accent");
            base2 = group.base;
            grp.base = base2;
            supSubGroup = assertSpan(buildGroup(grp, options));
            grp.base = group;
          } else {
            group = assertNodeType(grp, "accent");
            base2 = group.base;
          }
          var body = buildGroup(base2, options.havingCrampedStyle());
          var mustShift = group.isShifty && utils.isCharacterBox(base2);
          var skew = 0;
          if (mustShift) {
            var baseChar = utils.getBaseElem(base2);
            var baseGroup = buildGroup(baseChar, options.havingCrampedStyle());
            skew = assertSymbolDomNode(baseGroup).skew;
          }
          var clearance = Math.min(body.height, options.fontMetrics().xHeight);
          var accentBody;
          if (!group.isStretchy) {
            var accent2;
            var width;
            if (group.label === "\\vec") {
              accent2 = buildCommon.staticSvg("vec", options);
              width = buildCommon.svgData.vec[1];
            } else {
              accent2 = buildCommon.makeOrd({
                mode: group.mode,
                text: group.label
              }, options, "textord");
              accent2 = assertSymbolDomNode(accent2);
              accent2.italic = 0;
              width = accent2.width;
            }
            accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
            var accentFull = group.label === "\\textcircled";
            if (accentFull) {
              accentBody.classes.push("accent-full");
              clearance = body.height;
            }
            var left = skew;
            if (!accentFull) {
              left -= width / 2;
            }
            accentBody.style.left = left + "em";
            if (group.label === "\\textcircled") {
              accentBody.style.top = ".2em";
            }
            accentBody = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: body
              }, {
                type: "kern",
                size: -clearance
              }, {
                type: "elem",
                elem: accentBody
              }]
            }, options);
          } else {
            accentBody = stretchy.svgSpan(group, options);
            accentBody = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: body
              }, {
                type: "elem",
                elem: accentBody,
                wrapperClasses: ["svg-align"],
                wrapperStyle: skew > 0 ? {
                  width: "calc(100% - " + 2 * skew + "em)",
                  marginLeft: 2 * skew + "em"
                } : void 0
              }]
            }, options);
          }
          var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
          if (supSubGroup) {
            supSubGroup.children[0] = accentWrap;
            supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
            supSubGroup.classes[0] = "mord";
            return supSubGroup;
          } else {
            return accentWrap;
          }
        };
        var mathmlBuilder = function mathmlBuilder2(group, options) {
          var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
          var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
          node.setAttribute("accent", "true");
          return node;
        };
        var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map(function(accent2) {
          return "\\" + accent2;
        }).join("|"));
        defineFunction({
          type: "accent",
          names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
          props: {
            numArgs: 1
          },
          handler: function handler(context, args) {
            var base2 = normalizeArgument(args[0]);
            var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
            var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
            return {
              type: "accent",
              mode: context.parser.mode,
              label: context.funcName,
              isStretchy,
              isShifty,
              base: base2
            };
          },
          htmlBuilder,
          mathmlBuilder
        });
        defineFunction({
          type: "accent",
          names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v", "\\textcircled"],
          props: {
            numArgs: 1,
            allowedInText: true,
            allowedInMath: true,
            argTypes: ["primitive"]
          },
          handler: function handler(context, args) {
            var base2 = args[0];
            var mode = context.parser.mode;
            if (mode === "math") {
              context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
              mode = "text";
            }
            return {
              type: "accent",
              mode,
              label: context.funcName,
              isStretchy: false,
              isShifty: true,
              base: base2
            };
          },
          htmlBuilder,
          mathmlBuilder
        });
        ;
        defineFunction({
          type: "accentUnder",
          names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
          props: {
            numArgs: 1
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            var base2 = args[0];
            return {
              type: "accentUnder",
              mode: parser2.mode,
              label: funcName,
              base: base2
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var innerGroup = buildGroup(group.base, options);
            var accentBody = stretchy.svgSpan(group, options);
            var kern = group.label === "\\utilde" ? 0.12 : 0;
            var vlist = buildCommon.makeVList({
              positionType: "top",
              positionData: innerGroup.height,
              children: [{
                type: "elem",
                elem: accentBody,
                wrapperClasses: ["svg-align"]
              }, {
                type: "kern",
                size: kern
              }, {
                type: "elem",
                elem: innerGroup
              }]
            }, options);
            return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var accentNode = stretchy.mathMLnode(group.label);
            var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
            node.setAttribute("accentunder", "true");
            return node;
          }
        });
        ;
        var paddedNode = function paddedNode2(group) {
          var node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
          node.setAttribute("width", "+0.6em");
          node.setAttribute("lspace", "0.3em");
          return node;
        };
        defineFunction({
          type: "xArrow",
          names: [
            "\\xleftarrow",
            "\\xrightarrow",
            "\\xLeftarrow",
            "\\xRightarrow",
            "\\xleftrightarrow",
            "\\xLeftrightarrow",
            "\\xhookleftarrow",
            "\\xhookrightarrow",
            "\\xmapsto",
            "\\xrightharpoondown",
            "\\xrightharpoonup",
            "\\xleftharpoondown",
            "\\xleftharpoonup",
            "\\xrightleftharpoons",
            "\\xleftrightharpoons",
            "\\xlongequal",
            "\\xtwoheadrightarrow",
            "\\xtwoheadleftarrow",
            "\\xtofrom",
            "\\xrightleftarrows",
            "\\xrightequilibrium",
            "\\xleftequilibrium",
            "\\\\cdrightarrow",
            "\\\\cdleftarrow",
            "\\\\cdlongequal"
          ],
          props: {
            numArgs: 1,
            numOptionalArgs: 1
          },
          handler: function handler(_ref, args, optArgs) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            return {
              type: "xArrow",
              mode: parser2.mode,
              label: funcName,
              body: args[0],
              below: optArgs[0]
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var style = options.style;
            var newOptions = options.havingStyle(style.sup());
            var upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);
            var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
            upperGroup.classes.push(arrowPrefix + "-arrow-pad");
            var lowerGroup;
            if (group.below) {
              newOptions = options.havingStyle(style.sub());
              lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);
              lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
            }
            var arrowBody = stretchy.svgSpan(group, options);
            var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
            var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
            if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
              upperShift -= upperGroup.depth;
            }
            var vlist;
            if (lowerGroup) {
              var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
              vlist = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: upperGroup,
                  shift: upperShift
                }, {
                  type: "elem",
                  elem: arrowBody,
                  shift: arrowShift
                }, {
                  type: "elem",
                  elem: lowerGroup,
                  shift: lowerShift
                }]
              }, options);
            } else {
              vlist = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: upperGroup,
                  shift: upperShift
                }, {
                  type: "elem",
                  elem: arrowBody,
                  shift: arrowShift
                }]
              }, options);
            }
            vlist.children[0].children[0].children[1].classes.push("svg-align");
            return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var arrowNode = stretchy.mathMLnode(group.label);
            arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
            var node;
            if (group.body) {
              var upperNode = paddedNode(buildMathML_buildGroup(group.body, options));
              if (group.below) {
                var lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
                node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
              } else {
                node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
              }
            } else if (group.below) {
              var _lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
              node = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
            } else {
              node = paddedNode();
              node = new mathMLTree.MathNode("mover", [arrowNode, node]);
            }
            return node;
          }
        });
        ;
        var cdArrowFunctionName = {
          ">": "\\\\cdrightarrow",
          "<": "\\\\cdleftarrow",
          "=": "\\\\cdlongequal",
          "A": "\\uparrow",
          "V": "\\downarrow",
          "|": "\\Vert",
          ".": "no arrow"
        };
        var newCell = function newCell2() {
          return {
            type: "styling",
            body: [],
            mode: "math",
            style: "display"
          };
        };
        var isStartOfArrow = function isStartOfArrow2(node) {
          return node.type === "textord" && node.text === "@";
        };
        var isLabelEnd = function isLabelEnd2(node, endChar) {
          return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
        };
        function cdArrow(arrowChar, labels, parser2) {
          var funcName = cdArrowFunctionName[arrowChar];
          switch (funcName) {
            case "\\\\cdrightarrow":
            case "\\\\cdleftarrow":
              return parser2.callFunction(funcName, [labels[0]], [labels[1]]);
            case "\\uparrow":
            case "\\downarrow": {
              var leftLabel = parser2.callFunction("\\\\cdleft", [labels[0]], []);
              var bareArrow = {
                type: "atom",
                text: funcName,
                mode: "math",
                family: "rel"
              };
              var sizedArrow = parser2.callFunction("\\Big", [bareArrow], []);
              var rightLabel = parser2.callFunction("\\\\cdright", [labels[1]], []);
              var arrowGroup = {
                type: "ordgroup",
                mode: "math",
                body: [leftLabel, sizedArrow, rightLabel]
              };
              return parser2.callFunction("\\\\cdparent", [arrowGroup], []);
            }
            case "\\\\cdlongequal":
              return parser2.callFunction("\\\\cdlongequal", [], []);
            case "\\Vert": {
              var arrow = {
                type: "textord",
                text: "\\Vert",
                mode: "math"
              };
              return parser2.callFunction("\\Big", [arrow], []);
            }
            default:
              return {
                type: "textord",
                text: " ",
                mode: "math"
              };
          }
        }
        function parseCD(parser2) {
          var parsedRows = [];
          parser2.gullet.beginGroup();
          parser2.gullet.macros.set("\\cr", "\\\\\\relax");
          parser2.gullet.beginGroup();
          while (true) {
            parsedRows.push(parser2.parseExpression(false, "\\\\"));
            parser2.gullet.endGroup();
            parser2.gullet.beginGroup();
            var next = parser2.fetch().text;
            if (next === "&" || next === "\\\\") {
              parser2.consume();
            } else if (next === "\\end") {
              if (parsedRows[parsedRows.length - 1].length === 0) {
                parsedRows.pop();
              }
              break;
            } else {
              throw new src_ParseError("Expected \\\\ or \\cr or \\end", parser2.nextToken);
            }
          }
          var row = [];
          var body = [row];
          for (var i2 = 0; i2 < parsedRows.length; i2++) {
            var rowNodes = parsedRows[i2];
            var cell = newCell();
            for (var j = 0; j < rowNodes.length; j++) {
              if (!isStartOfArrow(rowNodes[j])) {
                cell.body.push(rowNodes[j]);
              } else {
                row.push(cell);
                j += 1;
                var arrowChar = assertSymbolNodeType(rowNodes[j]).text;
                var labels = new Array(2);
                labels[0] = {
                  type: "ordgroup",
                  mode: "math",
                  body: []
                };
                labels[1] = {
                  type: "ordgroup",
                  mode: "math",
                  body: []
                };
                if ("=|.".indexOf(arrowChar) > -1) {
                } else if ("<>AV".indexOf(arrowChar) > -1) {
                  for (var labelNum = 0; labelNum < 2; labelNum++) {
                    var inLabel = true;
                    for (var k = j + 1; k < rowNodes.length; k++) {
                      if (isLabelEnd(rowNodes[k], arrowChar)) {
                        inLabel = false;
                        j = k;
                        break;
                      }
                      if (isStartOfArrow(rowNodes[k])) {
                        throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k]);
                      }
                      labels[labelNum].body.push(rowNodes[k]);
                    }
                    if (inLabel) {
                      throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
                    }
                  }
                } else {
                  throw new src_ParseError('Expected one of "<>AV=|." after @', rowNodes[j]);
                }
                var arrow = cdArrow(arrowChar, labels, parser2);
                var wrappedArrow = {
                  type: "styling",
                  body: [arrow],
                  mode: "math",
                  style: "display"
                };
                row.push(wrappedArrow);
                cell = newCell();
              }
            }
            if (i2 % 2 === 0) {
              row.push(cell);
            } else {
              row.shift();
            }
            row = [];
            body.push(row);
          }
          parser2.gullet.endGroup();
          parser2.gullet.endGroup();
          var cols = new Array(body[0].length).fill({
            type: "align",
            align: "c",
            pregap: 0.25,
            postgap: 0.25
          });
          return {
            type: "array",
            mode: "math",
            body,
            arraystretch: 1,
            addJot: true,
            rowGaps: [null],
            cols,
            colSeparationType: "CD",
            hLinesBeforeRow: new Array(body.length + 1).fill([])
          };
        }
        defineFunction({
          type: "cdlabel",
          names: ["\\\\cdleft", "\\\\cdright"],
          props: {
            numArgs: 1
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            return {
              type: "cdlabel",
              mode: parser2.mode,
              side: funcName.slice(4),
              label: args[0]
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var newOptions = options.havingStyle(options.style.sup());
            var label = buildCommon.wrapFragment(buildGroup(group.label, newOptions, options), options);
            label.classes.push("cd-label-" + group.side);
            label.style.bottom = 0.8 - label.depth + "em";
            label.height = 0;
            label.depth = 0;
            return label;
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var label = new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.label, options)]);
            label = new mathMLTree.MathNode("mpadded", [label]);
            label.setAttribute("width", "0");
            if (group.side === "left") {
              label.setAttribute("lspace", "-1width");
            }
            label.setAttribute("voffset", "0.7em");
            label = new mathMLTree.MathNode("mstyle", [label]);
            label.setAttribute("displaystyle", "false");
            label.setAttribute("scriptlevel", "1");
            return label;
          }
        });
        defineFunction({
          type: "cdlabelparent",
          names: ["\\\\cdparent"],
          props: {
            numArgs: 1
          },
          handler: function handler(_ref2, args) {
            var parser2 = _ref2.parser;
            return {
              type: "cdlabelparent",
              mode: parser2.mode,
              fragment: args[0]
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var parent = buildCommon.wrapFragment(buildGroup(group.fragment, options), options);
            parent.classes.push("cd-vert-arrow");
            return parent;
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            return new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options)]);
          }
        });
        ;
        defineFunction({
          type: "textord",
          names: ["\\@char"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser;
            var arg = assertNodeType(args[0], "ordgroup");
            var group = arg.body;
            var number2 = "";
            for (var i2 = 0; i2 < group.length; i2++) {
              var node = assertNodeType(group[i2], "textord");
              number2 += node.text;
            }
            var code = parseInt(number2);
            if (isNaN(code)) {
              throw new src_ParseError("\\@char has non-numeric argument " + number2);
            }
            return {
              type: "textord",
              mode: parser2.mode,
              text: String.fromCharCode(code)
            };
          }
        });
        ;
        var color_htmlBuilder = function htmlBuilder2(group, options) {
          var elements = buildExpression(group.body, options.withColor(group.color), false);
          return buildCommon.makeFragment(elements);
        };
        var color_mathmlBuilder = function mathmlBuilder2(group, options) {
          var inner2 = buildMathML_buildExpression(group.body, options.withColor(group.color));
          var node = new mathMLTree.MathNode("mstyle", inner2);
          node.setAttribute("mathcolor", group.color);
          return node;
        };
        defineFunction({
          type: "color",
          names: ["\\textcolor"],
          props: {
            numArgs: 2,
            allowedInText: true,
            argTypes: ["color", "original"]
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser;
            var color = assertNodeType(args[0], "color-token").color;
            var body = args[1];
            return {
              type: "color",
              mode: parser2.mode,
              color,
              body: ordargument(body)
            };
          },
          htmlBuilder: color_htmlBuilder,
          mathmlBuilder: color_mathmlBuilder
        });
        defineFunction({
          type: "color",
          names: ["\\color"],
          props: {
            numArgs: 1,
            allowedInText: true,
            argTypes: ["color"]
          },
          handler: function handler(_ref2, args) {
            var parser2 = _ref2.parser, breakOnTokenText = _ref2.breakOnTokenText;
            var color = assertNodeType(args[0], "color-token").color;
            parser2.gullet.macros.set("\\current@color", color);
            var body = parser2.parseExpression(true, breakOnTokenText);
            return {
              type: "color",
              mode: parser2.mode,
              color,
              body
            };
          },
          htmlBuilder: color_htmlBuilder,
          mathmlBuilder: color_mathmlBuilder
        });
        ;
        defineFunction({
          type: "cr",
          names: ["\\\\"],
          props: {
            numArgs: 0,
            numOptionalArgs: 1,
            argTypes: ["size"],
            allowedInText: true
          },
          handler: function handler(_ref, args, optArgs) {
            var parser2 = _ref.parser;
            var size = optArgs[0];
            var newLine = !parser2.settings.displayMode || !parser2.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
            return {
              type: "cr",
              mode: parser2.mode,
              newLine,
              size: size && assertNodeType(size, "size").value
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var span = buildCommon.makeSpan(["mspace"], [], options);
            if (group.newLine) {
              span.classes.push("newline");
              if (group.size) {
                span.style.marginTop = calculateSize(group.size, options) + "em";
              }
            }
            return span;
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var node = new mathMLTree.MathNode("mspace");
            if (group.newLine) {
              node.setAttribute("linebreak", "newline");
              if (group.size) {
                node.setAttribute("height", calculateSize(group.size, options) + "em");
              }
            }
            return node;
          }
        });
        ;
        var globalMap = {
          "\\global": "\\global",
          "\\long": "\\\\globallong",
          "\\\\globallong": "\\\\globallong",
          "\\def": "\\gdef",
          "\\gdef": "\\gdef",
          "\\edef": "\\xdef",
          "\\xdef": "\\xdef",
          "\\let": "\\\\globallet",
          "\\futurelet": "\\\\globalfuture"
        };
        var checkControlSequence = function checkControlSequence2(tok) {
          var name2 = tok.text;
          if (/^(?:[\\{}$&#^_]|EOF)$/.test(name2)) {
            throw new src_ParseError("Expected a control sequence", tok);
          }
          return name2;
        };
        var getRHS = function getRHS2(parser2) {
          var tok = parser2.gullet.popToken();
          if (tok.text === "=") {
            tok = parser2.gullet.popToken();
            if (tok.text === " ") {
              tok = parser2.gullet.popToken();
            }
          }
          return tok;
        };
        var letCommand = function letCommand2(parser2, name2, tok, global2) {
          var macro = parser2.gullet.macros.get(tok.text);
          if (macro == null) {
            tok.noexpand = true;
            macro = {
              tokens: [tok],
              numArgs: 0,
              unexpandable: !parser2.gullet.isExpandable(tok.text)
            };
          }
          parser2.gullet.macros.set(name2, macro, global2);
        };
        defineFunction({
          type: "internal",
          names: [
            "\\global",
            "\\long",
            "\\\\globallong"
          ],
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler: function handler(_ref) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            parser2.consumeSpaces();
            var token = parser2.fetch();
            if (globalMap[token.text]) {
              if (funcName === "\\global" || funcName === "\\\\globallong") {
                token.text = globalMap[token.text];
              }
              return assertNodeType(parser2.parseFunction(), "internal");
            }
            throw new src_ParseError("Invalid token after macro prefix", token);
          }
        });
        defineFunction({
          type: "internal",
          names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler: function handler(_ref2) {
            var parser2 = _ref2.parser, funcName = _ref2.funcName;
            var tok = parser2.gullet.popToken();
            var name2 = tok.text;
            if (/^(?:[\\{}$&#^_]|EOF)$/.test(name2)) {
              throw new src_ParseError("Expected a control sequence", tok);
            }
            var numArgs = 0;
            var insert2;
            var delimiters2 = [[]];
            while (parser2.gullet.future().text !== "{") {
              tok = parser2.gullet.popToken();
              if (tok.text === "#") {
                if (parser2.gullet.future().text === "{") {
                  insert2 = parser2.gullet.future();
                  delimiters2[numArgs].push("{");
                  break;
                }
                tok = parser2.gullet.popToken();
                if (!/^[1-9]$/.test(tok.text)) {
                  throw new src_ParseError('Invalid argument number "' + tok.text + '"');
                }
                if (parseInt(tok.text) !== numArgs + 1) {
                  throw new src_ParseError('Argument number "' + tok.text + '" out of order');
                }
                numArgs++;
                delimiters2.push([]);
              } else if (tok.text === "EOF") {
                throw new src_ParseError("Expected a macro definition");
              } else {
                delimiters2[numArgs].push(tok.text);
              }
            }
            var _parser$gullet$consum = parser2.gullet.consumeArg(), tokens = _parser$gullet$consum.tokens;
            if (insert2) {
              tokens.unshift(insert2);
            }
            if (funcName === "\\edef" || funcName === "\\xdef") {
              tokens = parser2.gullet.expandTokens(tokens);
              tokens.reverse();
            }
            parser2.gullet.macros.set(name2, {
              tokens,
              numArgs,
              delimiters: delimiters2
            }, funcName === globalMap[funcName]);
            return {
              type: "internal",
              mode: parser2.mode
            };
          }
        });
        defineFunction({
          type: "internal",
          names: [
            "\\let",
            "\\\\globallet"
          ],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler: function handler(_ref3) {
            var parser2 = _ref3.parser, funcName = _ref3.funcName;
            var name2 = checkControlSequence(parser2.gullet.popToken());
            parser2.gullet.consumeSpaces();
            var tok = getRHS(parser2);
            letCommand(parser2, name2, tok, funcName === "\\\\globallet");
            return {
              type: "internal",
              mode: parser2.mode
            };
          }
        });
        defineFunction({
          type: "internal",
          names: [
            "\\futurelet",
            "\\\\globalfuture"
          ],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler: function handler(_ref4) {
            var parser2 = _ref4.parser, funcName = _ref4.funcName;
            var name2 = checkControlSequence(parser2.gullet.popToken());
            var middle = parser2.gullet.popToken();
            var tok = parser2.gullet.popToken();
            letCommand(parser2, name2, tok, funcName === "\\\\globalfuture");
            parser2.gullet.pushToken(tok);
            parser2.gullet.pushToken(middle);
            return {
              type: "internal",
              mode: parser2.mode
            };
          }
        });
        ;
        var getMetrics = function getMetrics2(symbol, font, mode) {
          var replace = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
          var metrics = getCharacterMetrics(replace || symbol, font, mode);
          if (!metrics) {
            throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
          }
          return metrics;
        };
        var styleWrap = function styleWrap2(delim, toStyle, options, classes) {
          var newOptions = options.havingBaseStyle(toStyle);
          var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
          var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
          span.height *= delimSizeMultiplier;
          span.depth *= delimSizeMultiplier;
          span.maxFontSize = newOptions.sizeMultiplier;
          return span;
        };
        var centerSpan = function centerSpan2(span, options, style) {
          var newOptions = options.havingBaseStyle(style);
          var shift2 = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
          span.classes.push("delimcenter");
          span.style.top = shift2 + "em";
          span.height -= shift2;
          span.depth += shift2;
        };
        var makeSmallDelim = function makeSmallDelim2(delim, style, center, options, mode, classes) {
          var text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
          var span = styleWrap(text, style, options, classes);
          if (center) {
            centerSpan(span, options, style);
          }
          return span;
        };
        var mathrmSize = function mathrmSize2(value, size, mode, options) {
          return buildCommon.makeSymbol(value, "Size" + size + "-Regular", mode, options);
        };
        var makeLargeDelim = function makeLargeDelim2(delim, size, center, options, mode, classes) {
          var inner2 = mathrmSize(delim, size, mode, options);
          var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size], [inner2], options), src_Style.TEXT, options, classes);
          if (center) {
            centerSpan(span, options, src_Style.TEXT);
          }
          return span;
        };
        var makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
          var sizeClass;
          if (font === "Size1-Regular") {
            sizeClass = "delim-size1";
          } else {
            sizeClass = "delim-size4";
          }
          var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
          return {
            type: "elem",
            elem: corner
          };
        };
        var makeInner = function makeInner2(ch2, height, options) {
          var width = fontMetricsData["Size4-Regular"][ch2.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch2.charCodeAt(0)][4].toFixed(3) : fontMetricsData["Size1-Regular"][ch2.charCodeAt(0)][4].toFixed(3);
          var path2 = new PathNode("inner", innerPath(ch2, Math.round(1e3 * height)));
          var svgNode = new SvgNode([path2], {
            "width": width + "em",
            "height": height + "em",
            "style": "width:" + width + "em",
            "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
            "preserveAspectRatio": "xMinYMin"
          });
          var span = buildCommon.makeSvgSpan([], [svgNode], options);
          span.height = height;
          span.style.height = height + "em";
          span.style.width = width + "em";
          return {
            type: "elem",
            elem: span
          };
        };
        var lapInEms = 8e-3;
        var lap = {
          type: "kern",
          size: -1 * lapInEms
        };
        var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
        var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
        var makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options, mode, classes) {
          var top2;
          var middle;
          var repeat;
          var bottom;
          top2 = repeat = bottom = delim;
          middle = null;
          var font = "Size1-Regular";
          if (delim === "\\uparrow") {
            repeat = bottom = "\u23D0";
          } else if (delim === "\\Uparrow") {
            repeat = bottom = "\u2016";
          } else if (delim === "\\downarrow") {
            top2 = repeat = "\u23D0";
          } else if (delim === "\\Downarrow") {
            top2 = repeat = "\u2016";
          } else if (delim === "\\updownarrow") {
            top2 = "\\uparrow";
            repeat = "\u23D0";
            bottom = "\\downarrow";
          } else if (delim === "\\Updownarrow") {
            top2 = "\\Uparrow";
            repeat = "\u2016";
            bottom = "\\Downarrow";
          } else if (utils.contains(verts, delim)) {
            repeat = "\u2223";
          } else if (utils.contains(doubleVerts, delim)) {
            repeat = "\u2225";
          } else if (delim === "[" || delim === "\\lbrack") {
            top2 = "\u23A1";
            repeat = "\u23A2";
            bottom = "\u23A3";
            font = "Size4-Regular";
          } else if (delim === "]" || delim === "\\rbrack") {
            top2 = "\u23A4";
            repeat = "\u23A5";
            bottom = "\u23A6";
            font = "Size4-Regular";
          } else if (delim === "\\lfloor" || delim === "\u230A") {
            repeat = top2 = "\u23A2";
            bottom = "\u23A3";
            font = "Size4-Regular";
          } else if (delim === "\\lceil" || delim === "\u2308") {
            top2 = "\u23A1";
            repeat = bottom = "\u23A2";
            font = "Size4-Regular";
          } else if (delim === "\\rfloor" || delim === "\u230B") {
            repeat = top2 = "\u23A5";
            bottom = "\u23A6";
            font = "Size4-Regular";
          } else if (delim === "\\rceil" || delim === "\u2309") {
            top2 = "\u23A4";
            repeat = bottom = "\u23A5";
            font = "Size4-Regular";
          } else if (delim === "(" || delim === "\\lparen") {
            top2 = "\u239B";
            repeat = "\u239C";
            bottom = "\u239D";
            font = "Size4-Regular";
          } else if (delim === ")" || delim === "\\rparen") {
            top2 = "\u239E";
            repeat = "\u239F";
            bottom = "\u23A0";
            font = "Size4-Regular";
          } else if (delim === "\\{" || delim === "\\lbrace") {
            top2 = "\u23A7";
            middle = "\u23A8";
            bottom = "\u23A9";
            repeat = "\u23AA";
            font = "Size4-Regular";
          } else if (delim === "\\}" || delim === "\\rbrace") {
            top2 = "\u23AB";
            middle = "\u23AC";
            bottom = "\u23AD";
            repeat = "\u23AA";
            font = "Size4-Regular";
          } else if (delim === "\\lgroup" || delim === "\u27EE") {
            top2 = "\u23A7";
            bottom = "\u23A9";
            repeat = "\u23AA";
            font = "Size4-Regular";
          } else if (delim === "\\rgroup" || delim === "\u27EF") {
            top2 = "\u23AB";
            bottom = "\u23AD";
            repeat = "\u23AA";
            font = "Size4-Regular";
          } else if (delim === "\\lmoustache" || delim === "\u23B0") {
            top2 = "\u23A7";
            bottom = "\u23AD";
            repeat = "\u23AA";
            font = "Size4-Regular";
          } else if (delim === "\\rmoustache" || delim === "\u23B1") {
            top2 = "\u23AB";
            bottom = "\u23A9";
            repeat = "\u23AA";
            font = "Size4-Regular";
          }
          var topMetrics = getMetrics(top2, font, mode);
          var topHeightTotal = topMetrics.height + topMetrics.depth;
          var repeatMetrics = getMetrics(repeat, font, mode);
          var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
          var bottomMetrics = getMetrics(bottom, font, mode);
          var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
          var middleHeightTotal = 0;
          var middleFactor = 1;
          if (middle !== null) {
            var middleMetrics = getMetrics(middle, font, mode);
            middleHeightTotal = middleMetrics.height + middleMetrics.depth;
            middleFactor = 2;
          }
          var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
          var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
          var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
          var axisHeight = options.fontMetrics().axisHeight;
          if (center) {
            axisHeight *= options.sizeMultiplier;
          }
          var depth = realHeightTotal / 2 - axisHeight;
          var stack = [];
          stack.push(makeGlyphSpan(bottom, font, mode));
          stack.push(lap);
          if (middle === null) {
            var innerHeight2 = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
            stack.push(makeInner(repeat, innerHeight2, options));
          } else {
            var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
            stack.push(makeInner(repeat, _innerHeight, options));
            stack.push(lap);
            stack.push(makeGlyphSpan(middle, font, mode));
            stack.push(lap);
            stack.push(makeInner(repeat, _innerHeight, options));
          }
          stack.push(lap);
          stack.push(makeGlyphSpan(top2, font, mode));
          var newOptions = options.havingBaseStyle(src_Style.TEXT);
          var inner2 = buildCommon.makeVList({
            positionType: "bottom",
            positionData: depth,
            children: stack
          }, newOptions);
          return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), src_Style.TEXT, options, classes);
        };
        var vbPad = 80;
        var emPad = 0.08;
        var sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraViniculum, options) {
          var path2 = sqrtPath(sqrtName, extraViniculum, viewBoxHeight);
          var pathNode = new PathNode(sqrtName, path2);
          var svg = new SvgNode([pathNode], {
            "width": "400em",
            "height": height + "em",
            "viewBox": "0 0 400000 " + viewBoxHeight,
            "preserveAspectRatio": "xMinYMin slice"
          });
          return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
        };
        var makeSqrtImage = function makeSqrtImage2(height, options) {
          var newOptions = options.havingBaseSizing();
          var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
          var sizeMultiplier = newOptions.sizeMultiplier;
          var extraViniculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
          var span;
          var spanHeight = 0;
          var texHeight = 0;
          var viewBoxHeight = 0;
          var advanceWidth;
          if (delim.type === "small") {
            viewBoxHeight = 1e3 + 1e3 * extraViniculum + vbPad;
            if (height < 1) {
              sizeMultiplier = 1;
            } else if (height < 1.4) {
              sizeMultiplier = 0.7;
            }
            spanHeight = (1 + extraViniculum + emPad) / sizeMultiplier;
            texHeight = (1 + extraViniculum) / sizeMultiplier;
            span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraViniculum, options);
            span.style.minWidth = "0.853em";
            advanceWidth = 0.833 / sizeMultiplier;
          } else if (delim.type === "large") {
            viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
            texHeight = (sizeToMaxHeight[delim.size] + extraViniculum) / sizeMultiplier;
            spanHeight = (sizeToMaxHeight[delim.size] + extraViniculum + emPad) / sizeMultiplier;
            span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraViniculum, options);
            span.style.minWidth = "1.02em";
            advanceWidth = 1 / sizeMultiplier;
          } else {
            spanHeight = height + extraViniculum + emPad;
            texHeight = height + extraViniculum;
            viewBoxHeight = Math.floor(1e3 * height + extraViniculum) + vbPad;
            span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraViniculum, options);
            span.style.minWidth = "0.742em";
            advanceWidth = 1.056;
          }
          span.height = texHeight;
          span.style.height = spanHeight + "em";
          return {
            span,
            advanceWidth,
            ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraViniculum) * sizeMultiplier
          };
        };
        var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "\\surd"];
        var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1"];
        var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
        var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
        var makeSizedDelim = function makeSizedDelim2(delim, size, options, mode, classes) {
          if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
            delim = "\\langle";
          } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
            delim = "\\rangle";
          }
          if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
            return makeLargeDelim(delim, size, false, options, mode, classes);
          } else if (utils.contains(stackAlwaysDelimiters, delim)) {
            return makeStackedDelim(delim, sizeToMaxHeight[size], false, options, mode, classes);
          } else {
            throw new src_ParseError("Illegal delimiter: '" + delim + "'");
          }
        };
        var stackNeverDelimiterSequence = [{
          type: "small",
          style: src_Style.SCRIPTSCRIPT
        }, {
          type: "small",
          style: src_Style.SCRIPT
        }, {
          type: "small",
          style: src_Style.TEXT
        }, {
          type: "large",
          size: 1
        }, {
          type: "large",
          size: 2
        }, {
          type: "large",
          size: 3
        }, {
          type: "large",
          size: 4
        }];
        var stackAlwaysDelimiterSequence = [{
          type: "small",
          style: src_Style.SCRIPTSCRIPT
        }, {
          type: "small",
          style: src_Style.SCRIPT
        }, {
          type: "small",
          style: src_Style.TEXT
        }, {
          type: "stack"
        }];
        var stackLargeDelimiterSequence = [{
          type: "small",
          style: src_Style.SCRIPTSCRIPT
        }, {
          type: "small",
          style: src_Style.SCRIPT
        }, {
          type: "small",
          style: src_Style.TEXT
        }, {
          type: "large",
          size: 1
        }, {
          type: "large",
          size: 2
        }, {
          type: "large",
          size: 3
        }, {
          type: "large",
          size: 4
        }, {
          type: "stack"
        }];
        var delimTypeToFont = function delimTypeToFont2(type) {
          if (type.type === "small") {
            return "Main-Regular";
          } else if (type.type === "large") {
            return "Size" + type.size + "-Regular";
          } else if (type.type === "stack") {
            return "Size4-Regular";
          } else {
            throw new Error("Add support for delim type '" + type.type + "' here.");
          }
        };
        var traverseSequence = function traverseSequence2(delim, height, sequence, options) {
          var start2 = Math.min(2, 3 - options.style.size);
          for (var i2 = start2; i2 < sequence.length; i2++) {
            if (sequence[i2].type === "stack") {
              break;
            }
            var metrics = getMetrics(delim, delimTypeToFont(sequence[i2]), "math");
            var heightDepth = metrics.height + metrics.depth;
            if (sequence[i2].type === "small") {
              var newOptions = options.havingBaseStyle(sequence[i2].style);
              heightDepth *= newOptions.sizeMultiplier;
            }
            if (heightDepth > height) {
              return sequence[i2];
            }
          }
          return sequence[sequence.length - 1];
        };
        var makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options, mode, classes) {
          if (delim === "<" || delim === "\\lt" || delim === "\u27E8") {
            delim = "\\langle";
          } else if (delim === ">" || delim === "\\gt" || delim === "\u27E9") {
            delim = "\\rangle";
          }
          var sequence;
          if (utils.contains(stackNeverDelimiters, delim)) {
            sequence = stackNeverDelimiterSequence;
          } else if (utils.contains(stackLargeDelimiters, delim)) {
            sequence = stackLargeDelimiterSequence;
          } else {
            sequence = stackAlwaysDelimiterSequence;
          }
          var delimType = traverseSequence(delim, height, sequence, options);
          if (delimType.type === "small") {
            return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
          } else if (delimType.type === "large") {
            return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
          } else {
            return makeStackedDelim(delim, height, center, options, mode, classes);
          }
        };
        var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes) {
          var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
          var delimiterFactor = 901;
          var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
          var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
          var totalHeight = Math.max(maxDistFromAxis / 500 * delimiterFactor, 2 * maxDistFromAxis - delimiterExtend);
          return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
        };
        var delimiter = {
          sqrtImage: makeSqrtImage,
          sizedDelim: makeSizedDelim,
          sizeToMaxHeight,
          customSizedDelim: makeCustomSizedDelim,
          leftRightDelim: makeLeftRightDelim
        };
        ;
        var delimiterSizes = {
          "\\bigl": {
            mclass: "mopen",
            size: 1
          },
          "\\Bigl": {
            mclass: "mopen",
            size: 2
          },
          "\\biggl": {
            mclass: "mopen",
            size: 3
          },
          "\\Biggl": {
            mclass: "mopen",
            size: 4
          },
          "\\bigr": {
            mclass: "mclose",
            size: 1
          },
          "\\Bigr": {
            mclass: "mclose",
            size: 2
          },
          "\\biggr": {
            mclass: "mclose",
            size: 3
          },
          "\\Biggr": {
            mclass: "mclose",
            size: 4
          },
          "\\bigm": {
            mclass: "mrel",
            size: 1
          },
          "\\Bigm": {
            mclass: "mrel",
            size: 2
          },
          "\\biggm": {
            mclass: "mrel",
            size: 3
          },
          "\\Biggm": {
            mclass: "mrel",
            size: 4
          },
          "\\big": {
            mclass: "mord",
            size: 1
          },
          "\\Big": {
            mclass: "mord",
            size: 2
          },
          "\\bigg": {
            mclass: "mord",
            size: 3
          },
          "\\Bigg": {
            mclass: "mord",
            size: 4
          }
        };
        var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "\u230A", "\u230B", "\\lceil", "\\rceil", "\u2308", "\u2309", "<", ">", "\\langle", "\u27E8", "\\rangle", "\u27E9", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "\u27EE", "\u27EF", "\\lmoustache", "\\rmoustache", "\u23B0", "\u23B1", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
        function checkDelimiter(delim, context) {
          var symDelim = checkSymbolNodeType(delim);
          if (symDelim && utils.contains(delimiters, symDelim.text)) {
            return symDelim;
          } else if (symDelim) {
            throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
          } else {
            throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
          }
        }
        defineFunction({
          type: "delimsizing",
          names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
          props: {
            numArgs: 1,
            argTypes: ["primitive"]
          },
          handler: function handler(context, args) {
            var delim = checkDelimiter(args[0], context);
            return {
              type: "delimsizing",
              mode: context.parser.mode,
              size: delimiterSizes[context.funcName].size,
              mclass: delimiterSizes[context.funcName].mclass,
              delim: delim.text
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            if (group.delim === ".") {
              return buildCommon.makeSpan([group.mclass]);
            }
            return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
          },
          mathmlBuilder: function mathmlBuilder2(group) {
            var children = [];
            if (group.delim !== ".") {
              children.push(makeText(group.delim, group.mode));
            }
            var node = new mathMLTree.MathNode("mo", children);
            if (group.mclass === "mopen" || group.mclass === "mclose") {
              node.setAttribute("fence", "true");
            } else {
              node.setAttribute("fence", "false");
            }
            node.setAttribute("stretchy", "true");
            node.setAttribute("minsize", delimiter.sizeToMaxHeight[group.size] + "em");
            node.setAttribute("maxsize", delimiter.sizeToMaxHeight[group.size] + "em");
            return node;
          }
        });
        function assertParsed(group) {
          if (!group.body) {
            throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
          }
        }
        defineFunction({
          type: "leftright-right",
          names: ["\\right"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: function handler(context, args) {
            var color = context.parser.gullet.macros.get("\\current@color");
            if (color && typeof color !== "string") {
              throw new src_ParseError("\\current@color set to non-string in \\right");
            }
            return {
              type: "leftright-right",
              mode: context.parser.mode,
              delim: checkDelimiter(args[0], context).text,
              color
            };
          }
        });
        defineFunction({
          type: "leftright",
          names: ["\\left"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: function handler(context, args) {
            var delim = checkDelimiter(args[0], context);
            var parser2 = context.parser;
            ++parser2.leftrightDepth;
            var body = parser2.parseExpression(false);
            --parser2.leftrightDepth;
            parser2.expect("\\right", false);
            var right = assertNodeType(parser2.parseFunction(), "leftright-right");
            return {
              type: "leftright",
              mode: parser2.mode,
              body,
              left: delim.text,
              right: right.delim,
              rightColor: right.color
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            assertParsed(group);
            var inner2 = buildExpression(group.body, options, true, ["mopen", "mclose"]);
            var innerHeight2 = 0;
            var innerDepth = 0;
            var hadMiddle = false;
            for (var i2 = 0; i2 < inner2.length; i2++) {
              if (inner2[i2].isMiddle) {
                hadMiddle = true;
              } else {
                innerHeight2 = Math.max(inner2[i2].height, innerHeight2);
                innerDepth = Math.max(inner2[i2].depth, innerDepth);
              }
            }
            innerHeight2 *= options.sizeMultiplier;
            innerDepth *= options.sizeMultiplier;
            var leftDelim;
            if (group.left === ".") {
              leftDelim = makeNullDelimiter(options, ["mopen"]);
            } else {
              leftDelim = delimiter.leftRightDelim(group.left, innerHeight2, innerDepth, options, group.mode, ["mopen"]);
            }
            inner2.unshift(leftDelim);
            if (hadMiddle) {
              for (var _i6 = 1; _i6 < inner2.length; _i6++) {
                var middleDelim = inner2[_i6];
                var isMiddle = middleDelim.isMiddle;
                if (isMiddle) {
                  inner2[_i6] = delimiter.leftRightDelim(isMiddle.delim, innerHeight2, innerDepth, isMiddle.options, group.mode, []);
                }
              }
            }
            var rightDelim;
            if (group.right === ".") {
              rightDelim = makeNullDelimiter(options, ["mclose"]);
            } else {
              var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
              rightDelim = delimiter.leftRightDelim(group.right, innerHeight2, innerDepth, colorOptions, group.mode, ["mclose"]);
            }
            inner2.push(rightDelim);
            return buildCommon.makeSpan(["minner"], inner2, options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            assertParsed(group);
            var inner2 = buildMathML_buildExpression(group.body, options);
            if (group.left !== ".") {
              var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
              leftNode.setAttribute("fence", "true");
              inner2.unshift(leftNode);
            }
            if (group.right !== ".") {
              var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
              rightNode.setAttribute("fence", "true");
              if (group.rightColor) {
                rightNode.setAttribute("mathcolor", group.rightColor);
              }
              inner2.push(rightNode);
            }
            return makeRow(inner2);
          }
        });
        defineFunction({
          type: "middle",
          names: ["\\middle"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: function handler(context, args) {
            var delim = checkDelimiter(args[0], context);
            if (!context.parser.leftrightDepth) {
              throw new src_ParseError("\\middle without preceding \\left", delim);
            }
            return {
              type: "middle",
              mode: context.parser.mode,
              delim: delim.text
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var middleDelim;
            if (group.delim === ".") {
              middleDelim = makeNullDelimiter(options, []);
            } else {
              middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
              var isMiddle = {
                delim: group.delim,
                options
              };
              middleDelim.isMiddle = isMiddle;
            }
            return middleDelim;
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
            var middleNode = new mathMLTree.MathNode("mo", [textNode]);
            middleNode.setAttribute("fence", "true");
            middleNode.setAttribute("lspace", "0.05em");
            middleNode.setAttribute("rspace", "0.05em");
            return middleNode;
          }
        });
        ;
        var enclose_htmlBuilder = function htmlBuilder2(group, options) {
          var inner2 = buildCommon.wrapFragment(buildGroup(group.body, options), options);
          var label = group.label.substr(1);
          var scale = options.sizeMultiplier;
          var img;
          var imgShift = 0;
          var isSingleChar = utils.isCharacterBox(group.body);
          if (label === "sout") {
            img = buildCommon.makeSpan(["stretchy", "sout"]);
            img.height = options.fontMetrics().defaultRuleThickness / scale;
            imgShift = -0.5 * options.fontMetrics().xHeight;
          } else if (label === "phase") {
            var lineWeight = calculateSize({
              number: 0.6,
              unit: "pt"
            }, options);
            var clearance = calculateSize({
              number: 0.35,
              unit: "ex"
            }, options);
            var newOptions = options.havingBaseSizing();
            scale = scale / newOptions.sizeMultiplier;
            var angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
            inner2.style.paddingLeft = angleHeight / 2 + lineWeight + "em";
            var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
            var path2 = phasePath(viewBoxHeight);
            var svgNode = new SvgNode([new PathNode("phase", path2)], {
              "width": "400em",
              "height": viewBoxHeight / 1e3 + "em",
              "viewBox": "0 0 400000 " + viewBoxHeight,
              "preserveAspectRatio": "xMinYMin slice"
            });
            img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
            img.style.height = angleHeight + "em";
            imgShift = inner2.depth + lineWeight + clearance;
          } else {
            if (/cancel/.test(label)) {
              if (!isSingleChar) {
                inner2.classes.push("cancel-pad");
              }
            } else if (label === "angl") {
              inner2.classes.push("anglpad");
            } else {
              inner2.classes.push("boxpad");
            }
            var topPad = 0;
            var bottomPad = 0;
            var ruleThickness = 0;
            if (/box/.test(label)) {
              ruleThickness = Math.max(options.fontMetrics().fboxrule, options.minRuleThickness);
              topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
              bottomPad = topPad;
            } else if (label === "angl") {
              ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
              topPad = 4 * ruleThickness;
              bottomPad = Math.max(0, 0.25 - inner2.depth);
            } else {
              topPad = isSingleChar ? 0.2 : 0;
              bottomPad = topPad;
            }
            img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
            if (/fbox|boxed|fcolorbox/.test(label)) {
              img.style.borderStyle = "solid";
              img.style.borderWidth = ruleThickness + "em";
            } else if (label === "angl" && ruleThickness !== 0.049) {
              img.style.borderTopWidth = ruleThickness + "em";
              img.style.borderRightWidth = ruleThickness + "em";
            }
            imgShift = inner2.depth + bottomPad;
            if (group.backgroundColor) {
              img.style.backgroundColor = group.backgroundColor;
              if (group.borderColor) {
                img.style.borderColor = group.borderColor;
              }
            }
          }
          var vlist;
          if (group.backgroundColor) {
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [
                {
                  type: "elem",
                  elem: img,
                  shift: imgShift
                },
                {
                  type: "elem",
                  elem: inner2,
                  shift: 0
                }
              ]
            }, options);
          } else {
            var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
            vlist = buildCommon.makeVList({
              positionType: "individualShift",
              children: [
                {
                  type: "elem",
                  elem: inner2,
                  shift: 0
                },
                {
                  type: "elem",
                  elem: img,
                  shift: imgShift,
                  wrapperClasses: classes
                }
              ]
            }, options);
          }
          if (/cancel/.test(label)) {
            vlist.height = inner2.height;
            vlist.depth = inner2.depth;
          }
          if (/cancel/.test(label) && !isSingleChar) {
            return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
          } else {
            return buildCommon.makeSpan(["mord"], [vlist], options);
          }
        };
        var enclose_mathmlBuilder = function mathmlBuilder2(group, options) {
          var fboxsep = 0;
          var node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
          switch (group.label) {
            case "\\cancel":
              node.setAttribute("notation", "updiagonalstrike");
              break;
            case "\\bcancel":
              node.setAttribute("notation", "downdiagonalstrike");
              break;
            case "\\phase":
              node.setAttribute("notation", "phasorangle");
              break;
            case "\\sout":
              node.setAttribute("notation", "horizontalstrike");
              break;
            case "\\fbox":
              node.setAttribute("notation", "box");
              break;
            case "\\angl":
              node.setAttribute("notation", "actuarial");
              break;
            case "\\fcolorbox":
            case "\\colorbox":
              fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
              node.setAttribute("width", "+" + 2 * fboxsep + "pt");
              node.setAttribute("height", "+" + 2 * fboxsep + "pt");
              node.setAttribute("lspace", fboxsep + "pt");
              node.setAttribute("voffset", fboxsep + "pt");
              if (group.label === "\\fcolorbox") {
                var thk = Math.max(options.fontMetrics().fboxrule, options.minRuleThickness);
                node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
              }
              break;
            case "\\xcancel":
              node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
              break;
          }
          if (group.backgroundColor) {
            node.setAttribute("mathbackground", group.backgroundColor);
          }
          return node;
        };
        defineFunction({
          type: "enclose",
          names: ["\\colorbox"],
          props: {
            numArgs: 2,
            allowedInText: true,
            argTypes: ["color", "text"]
          },
          handler: function handler(_ref, args, optArgs) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            var color = assertNodeType(args[0], "color-token").color;
            var body = args[1];
            return {
              type: "enclose",
              mode: parser2.mode,
              label: funcName,
              backgroundColor: color,
              body
            };
          },
          htmlBuilder: enclose_htmlBuilder,
          mathmlBuilder: enclose_mathmlBuilder
        });
        defineFunction({
          type: "enclose",
          names: ["\\fcolorbox"],
          props: {
            numArgs: 3,
            allowedInText: true,
            argTypes: ["color", "color", "text"]
          },
          handler: function handler(_ref2, args, optArgs) {
            var parser2 = _ref2.parser, funcName = _ref2.funcName;
            var borderColor = assertNodeType(args[0], "color-token").color;
            var backgroundColor = assertNodeType(args[1], "color-token").color;
            var body = args[2];
            return {
              type: "enclose",
              mode: parser2.mode,
              label: funcName,
              backgroundColor,
              borderColor,
              body
            };
          },
          htmlBuilder: enclose_htmlBuilder,
          mathmlBuilder: enclose_mathmlBuilder
        });
        defineFunction({
          type: "enclose",
          names: ["\\fbox"],
          props: {
            numArgs: 1,
            argTypes: ["hbox"],
            allowedInText: true
          },
          handler: function handler(_ref3, args) {
            var parser2 = _ref3.parser;
            return {
              type: "enclose",
              mode: parser2.mode,
              label: "\\fbox",
              body: args[0]
            };
          }
        });
        defineFunction({
          type: "enclose",
          names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
          props: {
            numArgs: 1
          },
          handler: function handler(_ref4, args) {
            var parser2 = _ref4.parser, funcName = _ref4.funcName;
            var body = args[0];
            return {
              type: "enclose",
              mode: parser2.mode,
              label: funcName,
              body
            };
          },
          htmlBuilder: enclose_htmlBuilder,
          mathmlBuilder: enclose_mathmlBuilder
        });
        defineFunction({
          type: "enclose",
          names: ["\\angl"],
          props: {
            numArgs: 1,
            argTypes: ["hbox"],
            allowedInText: false
          },
          handler: function handler(_ref5, args) {
            var parser2 = _ref5.parser;
            return {
              type: "enclose",
              mode: parser2.mode,
              label: "\\angl",
              body: args[0]
            };
          }
        });
        ;
        var _environments = {};
        function defineEnvironment(_ref) {
          var type = _ref.type, names = _ref.names, props = _ref.props, handler = _ref.handler, htmlBuilder2 = _ref.htmlBuilder, mathmlBuilder2 = _ref.mathmlBuilder;
          var data = {
            type,
            numArgs: props.numArgs || 0,
            allowedInText: false,
            numOptionalArgs: 0,
            handler
          };
          for (var i2 = 0; i2 < names.length; ++i2) {
            _environments[names[i2]] = data;
          }
          if (htmlBuilder2) {
            _htmlGroupBuilders[type] = htmlBuilder2;
          }
          if (mathmlBuilder2) {
            _mathmlGroupBuilders[type] = mathmlBuilder2;
          }
        }
        ;
        function getHLines(parser2) {
          var hlineInfo = [];
          parser2.consumeSpaces();
          var nxt = parser2.fetch().text;
          while (nxt === "\\hline" || nxt === "\\hdashline") {
            parser2.consume();
            hlineInfo.push(nxt === "\\hdashline");
            parser2.consumeSpaces();
            nxt = parser2.fetch().text;
          }
          return hlineInfo;
        }
        var validateAmsEnvironmentContext = function validateAmsEnvironmentContext2(context) {
          var settings = context.parser.settings;
          if (!settings.displayMode) {
            throw new src_ParseError("{" + context.envName + "} can be used only in display mode.");
          }
        };
        function parseArray(parser2, _ref, style) {
          var hskipBeforeAndAfter = _ref.hskipBeforeAndAfter, addJot = _ref.addJot, cols = _ref.cols, arraystretch = _ref.arraystretch, colSeparationType = _ref.colSeparationType, addEqnNum = _ref.addEqnNum, singleRow = _ref.singleRow, emptySingleRow = _ref.emptySingleRow, maxNumCols = _ref.maxNumCols, leqno = _ref.leqno;
          parser2.gullet.beginGroup();
          if (!singleRow) {
            parser2.gullet.macros.set("\\cr", "\\\\\\relax");
          }
          if (!arraystretch) {
            var stretch = parser2.gullet.expandMacroAsText("\\arraystretch");
            if (stretch == null) {
              arraystretch = 1;
            } else {
              arraystretch = parseFloat(stretch);
              if (!arraystretch || arraystretch < 0) {
                throw new src_ParseError("Invalid \\arraystretch: " + stretch);
              }
            }
          }
          parser2.gullet.beginGroup();
          var row = [];
          var body = [row];
          var rowGaps = [];
          var hLinesBeforeRow = [];
          hLinesBeforeRow.push(getHLines(parser2));
          while (true) {
            var cell = parser2.parseExpression(false, singleRow ? "\\end" : "\\\\");
            parser2.gullet.endGroup();
            parser2.gullet.beginGroup();
            cell = {
              type: "ordgroup",
              mode: parser2.mode,
              body: cell
            };
            if (style) {
              cell = {
                type: "styling",
                mode: parser2.mode,
                style,
                body: [cell]
              };
            }
            row.push(cell);
            var next = parser2.fetch().text;
            if (next === "&") {
              if (maxNumCols && row.length === maxNumCols) {
                if (singleRow || colSeparationType) {
                  throw new src_ParseError("Too many tab characters: &", parser2.nextToken);
                } else {
                  parser2.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
                }
              }
              parser2.consume();
            } else if (next === "\\end") {
              if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
                body.pop();
              }
              if (hLinesBeforeRow.length < body.length + 1) {
                hLinesBeforeRow.push([]);
              }
              break;
            } else if (next === "\\\\") {
              parser2.consume();
              var size = void 0;
              if (parser2.gullet.future().text !== " ") {
                size = parser2.parseSizeGroup(true);
              }
              rowGaps.push(size ? size.value : null);
              hLinesBeforeRow.push(getHLines(parser2));
              row = [];
              body.push(row);
            } else {
              throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser2.nextToken);
            }
          }
          parser2.gullet.endGroup();
          parser2.gullet.endGroup();
          return {
            type: "array",
            mode: parser2.mode,
            addJot,
            arraystretch,
            body,
            cols,
            rowGaps,
            hskipBeforeAndAfter,
            hLinesBeforeRow,
            colSeparationType,
            addEqnNum,
            leqno
          };
        }
        function dCellStyle(envName) {
          if (envName.substr(0, 1) === "d") {
            return "display";
          } else {
            return "text";
          }
        }
        var array_htmlBuilder = function htmlBuilder2(group, options) {
          var r2;
          var c;
          var nr = group.body.length;
          var hLinesBeforeRow = group.hLinesBeforeRow;
          var nc = 0;
          var body = new Array(nr);
          var hlines = [];
          var ruleThickness = Math.max(options.fontMetrics().arrayRuleWidth, options.minRuleThickness);
          var pt = 1 / options.fontMetrics().ptPerEm;
          var arraycolsep = 5 * pt;
          if (group.colSeparationType && group.colSeparationType === "small") {
            var localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
            arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
          }
          var baselineskip = group.colSeparationType === "CD" ? calculateSize({
            number: 3,
            unit: "ex"
          }, options) : 12 * pt;
          var jot = 3 * pt;
          var arrayskip = group.arraystretch * baselineskip;
          var arstrutHeight = 0.7 * arrayskip;
          var arstrutDepth = 0.3 * arrayskip;
          var totalHeight = 0;
          function setHLinePos(hlinesInGap) {
            for (var i2 = 0; i2 < hlinesInGap.length; ++i2) {
              if (i2 > 0) {
                totalHeight += 0.25;
              }
              hlines.push({
                pos: totalHeight,
                isDashed: hlinesInGap[i2]
              });
            }
          }
          setHLinePos(hLinesBeforeRow[0]);
          for (r2 = 0; r2 < group.body.length; ++r2) {
            var inrow = group.body[r2];
            var height = arstrutHeight;
            var depth = arstrutDepth;
            if (nc < inrow.length) {
              nc = inrow.length;
            }
            var outrow = new Array(inrow.length);
            for (c = 0; c < inrow.length; ++c) {
              var elt = buildGroup(inrow[c], options);
              if (depth < elt.depth) {
                depth = elt.depth;
              }
              if (height < elt.height) {
                height = elt.height;
              }
              outrow[c] = elt;
            }
            var rowGap = group.rowGaps[r2];
            var gap = 0;
            if (rowGap) {
              gap = calculateSize(rowGap, options);
              if (gap > 0) {
                gap += arstrutDepth;
                if (depth < gap) {
                  depth = gap;
                }
                gap = 0;
              }
            }
            if (group.addJot) {
              depth += jot;
            }
            outrow.height = height;
            outrow.depth = depth;
            totalHeight += height;
            outrow.pos = totalHeight;
            totalHeight += depth + gap;
            body[r2] = outrow;
            setHLinePos(hLinesBeforeRow[r2 + 1]);
          }
          var offset = totalHeight / 2 + options.fontMetrics().axisHeight;
          var colDescriptions = group.cols || [];
          var cols = [];
          var colSep;
          var colDescrNum;
          var eqnNumSpans = [];
          if (group.addEqnNum) {
            for (r2 = 0; r2 < nr; ++r2) {
              var rw = body[r2];
              var shift2 = rw.pos - offset;
              var eqnTag = buildCommon.makeSpan(["eqn-num"], [], options);
              eqnTag.depth = rw.depth;
              eqnTag.height = rw.height;
              eqnNumSpans.push({
                type: "elem",
                elem: eqnTag,
                shift: shift2
              });
            }
          }
          for (c = 0, colDescrNum = 0; c < nc || colDescrNum < colDescriptions.length; ++c, ++colDescrNum) {
            var colDescr = colDescriptions[colDescrNum] || {};
            var firstSeparator = true;
            while (colDescr.type === "separator") {
              if (!firstSeparator) {
                colSep = buildCommon.makeSpan(["arraycolsep"], []);
                colSep.style.width = options.fontMetrics().doubleRuleSep + "em";
                cols.push(colSep);
              }
              if (colDescr.separator === "|" || colDescr.separator === ":") {
                var lineType = colDescr.separator === "|" ? "solid" : "dashed";
                var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
                separator.style.height = totalHeight + "em";
                separator.style.borderRightWidth = ruleThickness + "em";
                separator.style.borderRightStyle = lineType;
                separator.style.margin = "0 -" + ruleThickness / 2 + "em";
                separator.style.verticalAlign = -(totalHeight - offset) + "em";
                cols.push(separator);
              } else {
                throw new src_ParseError("Invalid separator type: " + colDescr.separator);
              }
              colDescrNum++;
              colDescr = colDescriptions[colDescrNum] || {};
              firstSeparator = false;
            }
            if (c >= nc) {
              continue;
            }
            var sepwidth = void 0;
            if (c > 0 || group.hskipBeforeAndAfter) {
              sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
              if (sepwidth !== 0) {
                colSep = buildCommon.makeSpan(["arraycolsep"], []);
                colSep.style.width = sepwidth + "em";
                cols.push(colSep);
              }
            }
            var col = [];
            for (r2 = 0; r2 < nr; ++r2) {
              var row = body[r2];
              var elem = row[c];
              if (!elem) {
                continue;
              }
              var _shift = row.pos - offset;
              elem.depth = row.depth;
              elem.height = row.height;
              col.push({
                type: "elem",
                elem,
                shift: _shift
              });
            }
            col = buildCommon.makeVList({
              positionType: "individualShift",
              children: col
            }, options);
            col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
            cols.push(col);
            if (c < nc - 1 || group.hskipBeforeAndAfter) {
              sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
              if (sepwidth !== 0) {
                colSep = buildCommon.makeSpan(["arraycolsep"], []);
                colSep.style.width = sepwidth + "em";
                cols.push(colSep);
              }
            }
          }
          body = buildCommon.makeSpan(["mtable"], cols);
          if (hlines.length > 0) {
            var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
            var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
            var vListElems = [{
              type: "elem",
              elem: body,
              shift: 0
            }];
            while (hlines.length > 0) {
              var hline = hlines.pop();
              var lineShift = hline.pos - offset;
              if (hline.isDashed) {
                vListElems.push({
                  type: "elem",
                  elem: dashes,
                  shift: lineShift
                });
              } else {
                vListElems.push({
                  type: "elem",
                  elem: line,
                  shift: lineShift
                });
              }
            }
            body = buildCommon.makeVList({
              positionType: "individualShift",
              children: vListElems
            }, options);
          }
          if (!group.addEqnNum) {
            return buildCommon.makeSpan(["mord"], [body], options);
          } else {
            var eqnNumCol = buildCommon.makeVList({
              positionType: "individualShift",
              children: eqnNumSpans
            }, options);
            eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
            return buildCommon.makeFragment([body, eqnNumCol]);
          }
        };
        var alignMap = {
          c: "center ",
          l: "left ",
          r: "right "
        };
        var array_mathmlBuilder = function mathmlBuilder2(group, options) {
          var tbl = [];
          var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
          var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
          for (var i2 = 0; i2 < group.body.length; i2++) {
            var rw = group.body[i2];
            var row = [];
            for (var j = 0; j < rw.length; j++) {
              row.push(new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(rw[j], options)]));
            }
            if (group.addEqnNum) {
              row.unshift(glue);
              row.push(glue);
              if (group.leqno) {
                row.unshift(tag);
              } else {
                row.push(tag);
              }
            }
            tbl.push(new mathMLTree.MathNode("mtr", row));
          }
          var table = new mathMLTree.MathNode("mtable", tbl);
          var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
          table.setAttribute("rowspacing", gap.toFixed(4) + "em");
          var menclose = "";
          var align = "";
          if (group.cols && group.cols.length > 0) {
            var cols = group.cols;
            var columnLines = "";
            var prevTypeWasAlign = false;
            var iStart = 0;
            var iEnd = cols.length;
            if (cols[0].type === "separator") {
              menclose += "top ";
              iStart = 1;
            }
            if (cols[cols.length - 1].type === "separator") {
              menclose += "bottom ";
              iEnd -= 1;
            }
            for (var _i6 = iStart; _i6 < iEnd; _i6++) {
              if (cols[_i6].type === "align") {
                align += alignMap[cols[_i6].align];
                if (prevTypeWasAlign) {
                  columnLines += "none ";
                }
                prevTypeWasAlign = true;
              } else if (cols[_i6].type === "separator") {
                if (prevTypeWasAlign) {
                  columnLines += cols[_i6].separator === "|" ? "solid " : "dashed ";
                  prevTypeWasAlign = false;
                }
              }
            }
            table.setAttribute("columnalign", align.trim());
            if (/[sd]/.test(columnLines)) {
              table.setAttribute("columnlines", columnLines.trim());
            }
          }
          if (group.colSeparationType === "align") {
            var _cols = group.cols || [];
            var spacing2 = "";
            for (var _i22 = 1; _i22 < _cols.length; _i22++) {
              spacing2 += _i22 % 2 ? "0em " : "1em ";
            }
            table.setAttribute("columnspacing", spacing2.trim());
          } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
            table.setAttribute("columnspacing", "0em");
          } else if (group.colSeparationType === "small") {
            table.setAttribute("columnspacing", "0.2778em");
          } else if (group.colSeparationType === "CD") {
            table.setAttribute("columnspacing", "0.5em");
          } else {
            table.setAttribute("columnspacing", "1em");
          }
          var rowLines = "";
          var hlines = group.hLinesBeforeRow;
          menclose += hlines[0].length > 0 ? "left " : "";
          menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
          for (var _i32 = 1; _i32 < hlines.length - 1; _i32++) {
            rowLines += hlines[_i32].length === 0 ? "none " : hlines[_i32][0] ? "dashed " : "solid ";
          }
          if (/[sd]/.test(rowLines)) {
            table.setAttribute("rowlines", rowLines.trim());
          }
          if (menclose !== "") {
            table = new mathMLTree.MathNode("menclose", [table]);
            table.setAttribute("notation", menclose.trim());
          }
          if (group.arraystretch && group.arraystretch < 1) {
            table = new mathMLTree.MathNode("mstyle", [table]);
            table.setAttribute("scriptlevel", "1");
          }
          return table;
        };
        var alignedHandler = function alignedHandler2(context, args) {
          if (context.envName.indexOf("ed") === -1) {
            validateAmsEnvironmentContext(context);
          }
          var cols = [];
          var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
          var res = parseArray(context.parser, {
            cols,
            addJot: true,
            addEqnNum: context.envName === "align" || context.envName === "alignat",
            emptySingleRow: true,
            colSeparationType: separationType,
            maxNumCols: context.envName === "split" ? 2 : void 0,
            leqno: context.parser.settings.leqno
          }, "display");
          var numMaths;
          var numCols = 0;
          var emptyGroup = {
            type: "ordgroup",
            mode: context.mode,
            body: []
          };
          if (args[0] && args[0].type === "ordgroup") {
            var arg0 = "";
            for (var i2 = 0; i2 < args[0].body.length; i2++) {
              var textord2 = assertNodeType(args[0].body[i2], "textord");
              arg0 += textord2.text;
            }
            numMaths = Number(arg0);
            numCols = numMaths * 2;
          }
          var isAligned = !numCols;
          res.body.forEach(function(row) {
            for (var _i42 = 1; _i42 < row.length; _i42 += 2) {
              var styling = assertNodeType(row[_i42], "styling");
              var ordgroup = assertNodeType(styling.body[0], "ordgroup");
              ordgroup.body.unshift(emptyGroup);
            }
            if (!isAligned) {
              var curMaths = row.length / 2;
              if (numMaths < curMaths) {
                throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
              }
            } else if (numCols < row.length) {
              numCols = row.length;
            }
          });
          for (var _i52 = 0; _i52 < numCols; ++_i52) {
            var align = "r";
            var pregap = 0;
            if (_i52 % 2 === 1) {
              align = "l";
            } else if (_i52 > 0 && isAligned) {
              pregap = 1;
            }
            cols[_i52] = {
              type: "align",
              align,
              pregap,
              postgap: 0
            };
          }
          res.colSeparationType = isAligned ? "align" : "alignat";
          return res;
        };
        defineEnvironment({
          type: "array",
          names: ["array", "darray"],
          props: {
            numArgs: 1
          },
          handler: function handler(context, args) {
            var symNode = checkSymbolNodeType(args[0]);
            var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
            var cols = colalign.map(function(nde) {
              var node = assertSymbolNodeType(nde);
              var ca = node.text;
              if ("lcr".indexOf(ca) !== -1) {
                return {
                  type: "align",
                  align: ca
                };
              } else if (ca === "|") {
                return {
                  type: "separator",
                  separator: "|"
                };
              } else if (ca === ":") {
                return {
                  type: "separator",
                  separator: ":"
                };
              }
              throw new src_ParseError("Unknown column alignment: " + ca, nde);
            });
            var res = {
              cols,
              hskipBeforeAndAfter: true,
              maxNumCols: cols.length
            };
            return parseArray(context.parser, res, dCellStyle(context.envName));
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
          props: {
            numArgs: 0
          },
          handler: function handler(context) {
            var delimiters2 = {
              "matrix": null,
              "pmatrix": ["(", ")"],
              "bmatrix": ["[", "]"],
              "Bmatrix": ["\\{", "\\}"],
              "vmatrix": ["|", "|"],
              "Vmatrix": ["\\Vert", "\\Vert"]
            }[context.envName.replace("*", "")];
            var colAlign = "c";
            var payload = {
              hskipBeforeAndAfter: false,
              cols: [{
                type: "align",
                align: colAlign
              }]
            };
            if (context.envName.charAt(context.envName.length - 1) === "*") {
              var parser2 = context.parser;
              parser2.consumeSpaces();
              if (parser2.fetch().text === "[") {
                parser2.consume();
                parser2.consumeSpaces();
                colAlign = parser2.fetch().text;
                if ("lcr".indexOf(colAlign) === -1) {
                  throw new src_ParseError("Expected l or c or r", parser2.nextToken);
                }
                parser2.consume();
                parser2.consumeSpaces();
                parser2.expect("]");
                parser2.consume();
                payload.cols = [{
                  type: "align",
                  align: colAlign
                }];
              }
            }
            var res = parseArray(context.parser, payload, dCellStyle(context.envName));
            var numCols = Math.max.apply(Math, [0].concat(res.body.map(function(row) {
              return row.length;
            })));
            res.cols = new Array(numCols).fill({
              type: "align",
              align: colAlign
            });
            return delimiters2 ? {
              type: "leftright",
              mode: context.mode,
              body: [res],
              left: delimiters2[0],
              right: delimiters2[1],
              rightColor: void 0
            } : res;
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["smallmatrix"],
          props: {
            numArgs: 0
          },
          handler: function handler(context) {
            var payload = {
              arraystretch: 0.5
            };
            var res = parseArray(context.parser, payload, "script");
            res.colSeparationType = "small";
            return res;
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["subarray"],
          props: {
            numArgs: 1
          },
          handler: function handler(context, args) {
            var symNode = checkSymbolNodeType(args[0]);
            var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
            var cols = colalign.map(function(nde) {
              var node = assertSymbolNodeType(nde);
              var ca = node.text;
              if ("lc".indexOf(ca) !== -1) {
                return {
                  type: "align",
                  align: ca
                };
              }
              throw new src_ParseError("Unknown column alignment: " + ca, nde);
            });
            if (cols.length > 1) {
              throw new src_ParseError("{subarray} can contain only one column");
            }
            var res = {
              cols,
              hskipBeforeAndAfter: false,
              arraystretch: 0.5
            };
            res = parseArray(context.parser, res, "script");
            if (res.body.length > 0 && res.body[0].length > 1) {
              throw new src_ParseError("{subarray} can contain only one column");
            }
            return res;
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["cases", "dcases", "rcases", "drcases"],
          props: {
            numArgs: 0
          },
          handler: function handler(context) {
            var payload = {
              arraystretch: 1.2,
              cols: [{
                type: "align",
                align: "l",
                pregap: 0,
                postgap: 1
              }, {
                type: "align",
                align: "l",
                pregap: 0,
                postgap: 0
              }]
            };
            var res = parseArray(context.parser, payload, dCellStyle(context.envName));
            return {
              type: "leftright",
              mode: context.mode,
              body: [res],
              left: context.envName.indexOf("r") > -1 ? "." : "\\{",
              right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
              rightColor: void 0
            };
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["align", "align*", "aligned", "split"],
          props: {
            numArgs: 0
          },
          handler: alignedHandler,
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["gathered", "gather", "gather*"],
          props: {
            numArgs: 0
          },
          handler: function handler(context) {
            if (utils.contains(["gather", "gather*"], context.envName)) {
              validateAmsEnvironmentContext(context);
            }
            var res = {
              cols: [{
                type: "align",
                align: "c"
              }],
              addJot: true,
              colSeparationType: "gather",
              addEqnNum: context.envName === "gather",
              emptySingleRow: true,
              leqno: context.parser.settings.leqno
            };
            return parseArray(context.parser, res, "display");
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["alignat", "alignat*", "alignedat"],
          props: {
            numArgs: 1
          },
          handler: alignedHandler,
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["equation", "equation*"],
          props: {
            numArgs: 0
          },
          handler: function handler(context) {
            validateAmsEnvironmentContext(context);
            var res = {
              addEqnNum: context.envName === "equation",
              emptySingleRow: true,
              singleRow: true,
              maxNumCols: 1,
              leqno: context.parser.settings.leqno
            };
            return parseArray(context.parser, res, "display");
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineEnvironment({
          type: "array",
          names: ["CD"],
          props: {
            numArgs: 0
          },
          handler: function handler(context) {
            validateAmsEnvironmentContext(context);
            return parseCD(context.parser);
          },
          htmlBuilder: array_htmlBuilder,
          mathmlBuilder: array_mathmlBuilder
        });
        defineFunction({
          type: "text",
          names: ["\\hline", "\\hdashline"],
          props: {
            numArgs: 0,
            allowedInText: true,
            allowedInMath: true
          },
          handler: function handler(context, args) {
            throw new src_ParseError(context.funcName + " valid only within array environment");
          }
        });
        ;
        var environments = _environments;
        var src_environments = environments;
        ;
        defineFunction({
          type: "environment",
          names: ["\\begin", "\\end"],
          props: {
            numArgs: 1,
            argTypes: ["text"]
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            var nameGroup = args[0];
            if (nameGroup.type !== "ordgroup") {
              throw new src_ParseError("Invalid environment name", nameGroup);
            }
            var envName = "";
            for (var i2 = 0; i2 < nameGroup.body.length; ++i2) {
              envName += assertNodeType(nameGroup.body[i2], "textord").text;
            }
            if (funcName === "\\begin") {
              if (!src_environments.hasOwnProperty(envName)) {
                throw new src_ParseError("No such environment: " + envName, nameGroup);
              }
              var env = src_environments[envName];
              var _parser$parseArgument = parser2.parseArguments("\\begin{" + envName + "}", env), _args = _parser$parseArgument.args, optArgs = _parser$parseArgument.optArgs;
              var context = {
                mode: parser2.mode,
                envName,
                parser: parser2
              };
              var result = env.handler(context, _args, optArgs);
              parser2.expect("\\end", false);
              var endNameToken = parser2.nextToken;
              var end = assertNodeType(parser2.parseFunction(), "environment");
              if (end.name !== envName) {
                throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
              }
              return result;
            }
            return {
              type: "environment",
              mode: parser2.mode,
              name: envName,
              nameGroup
            };
          }
        });
        ;
        var mclass_makeSpan = buildCommon.makeSpan;
        function mclass_htmlBuilder(group, options) {
          var elements = buildExpression(group.body, options, true);
          return mclass_makeSpan([group.mclass], elements, options);
        }
        function mclass_mathmlBuilder(group, options) {
          var node;
          var inner2 = buildMathML_buildExpression(group.body, options);
          if (group.mclass === "minner") {
            return mathMLTree.newDocumentFragment(inner2);
          } else if (group.mclass === "mord") {
            if (group.isCharacterBox) {
              node = inner2[0];
              node.type = "mi";
            } else {
              node = new mathMLTree.MathNode("mi", inner2);
            }
          } else {
            if (group.isCharacterBox) {
              node = inner2[0];
              node.type = "mo";
            } else {
              node = new mathMLTree.MathNode("mo", inner2);
            }
            if (group.mclass === "mbin") {
              node.attributes.lspace = "0.22em";
              node.attributes.rspace = "0.22em";
            } else if (group.mclass === "mpunct") {
              node.attributes.lspace = "0em";
              node.attributes.rspace = "0.17em";
            } else if (group.mclass === "mopen" || group.mclass === "mclose") {
              node.attributes.lspace = "0em";
              node.attributes.rspace = "0em";
            }
          }
          return node;
        }
        defineFunction({
          type: "mclass",
          names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            var body = args[0];
            return {
              type: "mclass",
              mode: parser2.mode,
              mclass: "m" + funcName.substr(5),
              body: ordargument(body),
              isCharacterBox: utils.isCharacterBox(body)
            };
          },
          htmlBuilder: mclass_htmlBuilder,
          mathmlBuilder: mclass_mathmlBuilder
        });
        var binrelClass = function binrelClass2(arg) {
          var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
          if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
            return "m" + atom.family;
          } else {
            return "mord";
          }
        };
        defineFunction({
          type: "mclass",
          names: ["\\@binrel"],
          props: {
            numArgs: 2
          },
          handler: function handler(_ref2, args) {
            var parser2 = _ref2.parser;
            return {
              type: "mclass",
              mode: parser2.mode,
              mclass: binrelClass(args[0]),
              body: ordargument(args[1]),
              isCharacterBox: utils.isCharacterBox(args[1])
            };
          }
        });
        defineFunction({
          type: "mclass",
          names: ["\\stackrel", "\\overset", "\\underset"],
          props: {
            numArgs: 2
          },
          handler: function handler(_ref3, args) {
            var parser2 = _ref3.parser, funcName = _ref3.funcName;
            var baseArg = args[1];
            var shiftedArg = args[0];
            var mclass;
            if (funcName !== "\\stackrel") {
              mclass = binrelClass(baseArg);
            } else {
              mclass = "mrel";
            }
            var baseOp = {
              type: "op",
              mode: baseArg.mode,
              limits: true,
              alwaysHandleSupSub: true,
              parentIsSupSub: false,
              symbol: false,
              suppressBaseShift: funcName !== "\\stackrel",
              body: ordargument(baseArg)
            };
            var supsub = {
              type: "supsub",
              mode: shiftedArg.mode,
              base: baseOp,
              sup: funcName === "\\underset" ? null : shiftedArg,
              sub: funcName === "\\underset" ? shiftedArg : null
            };
            return {
              type: "mclass",
              mode: parser2.mode,
              mclass,
              body: [supsub],
              isCharacterBox: utils.isCharacterBox(supsub)
            };
          },
          htmlBuilder: mclass_htmlBuilder,
          mathmlBuilder: mclass_mathmlBuilder
        });
        ;
        var font_htmlBuilder = function htmlBuilder2(group, options) {
          var font = group.font;
          var newOptions = options.withFont(font);
          return buildGroup(group.body, newOptions);
        };
        var font_mathmlBuilder = function mathmlBuilder2(group, options) {
          var font = group.font;
          var newOptions = options.withFont(font);
          return buildMathML_buildGroup(group.body, newOptions);
        };
        var fontAliases = {
          "\\Bbb": "\\mathbb",
          "\\bold": "\\mathbf",
          "\\frak": "\\mathfrak",
          "\\bm": "\\boldsymbol"
        };
        defineFunction({
          type: "font",
          names: [
            "\\mathrm",
            "\\mathit",
            "\\mathbf",
            "\\mathnormal",
            "\\mathbb",
            "\\mathcal",
            "\\mathfrak",
            "\\mathscr",
            "\\mathsf",
            "\\mathtt",
            "\\Bbb",
            "\\bold",
            "\\frak"
          ],
          props: {
            numArgs: 1,
            allowedInArgument: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            var body = normalizeArgument(args[0]);
            var func = funcName;
            if (func in fontAliases) {
              func = fontAliases[func];
            }
            return {
              type: "font",
              mode: parser2.mode,
              font: func.slice(1),
              body
            };
          },
          htmlBuilder: font_htmlBuilder,
          mathmlBuilder: font_mathmlBuilder
        });
        defineFunction({
          type: "mclass",
          names: ["\\boldsymbol", "\\bm"],
          props: {
            numArgs: 1
          },
          handler: function handler(_ref2, args) {
            var parser2 = _ref2.parser;
            var body = args[0];
            var isCharacterBox2 = utils.isCharacterBox(body);
            return {
              type: "mclass",
              mode: parser2.mode,
              mclass: binrelClass(body),
              body: [{
                type: "font",
                mode: parser2.mode,
                font: "boldsymbol",
                body
              }],
              isCharacterBox: isCharacterBox2
            };
          }
        });
        defineFunction({
          type: "font",
          names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler: function handler(_ref3, args) {
            var parser2 = _ref3.parser, funcName = _ref3.funcName, breakOnTokenText = _ref3.breakOnTokenText;
            var mode = parser2.mode;
            var body = parser2.parseExpression(true, breakOnTokenText);
            var style = "math" + funcName.slice(1);
            return {
              type: "font",
              mode,
              font: style,
              body: {
                type: "ordgroup",
                mode: parser2.mode,
                body
              }
            };
          },
          htmlBuilder: font_htmlBuilder,
          mathmlBuilder: font_mathmlBuilder
        });
        ;
        var adjustStyle = function adjustStyle2(size, originalStyle) {
          var style = originalStyle;
          if (size === "display") {
            style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
          } else if (size === "text" && style.size === src_Style.DISPLAY.size) {
            style = src_Style.TEXT;
          } else if (size === "script") {
            style = src_Style.SCRIPT;
          } else if (size === "scriptscript") {
            style = src_Style.SCRIPTSCRIPT;
          }
          return style;
        };
        var genfrac_htmlBuilder = function htmlBuilder2(group, options) {
          var style = adjustStyle(group.size, options.style);
          var nstyle = style.fracNum();
          var dstyle = style.fracDen();
          var newOptions;
          newOptions = options.havingStyle(nstyle);
          var numerm = buildGroup(group.numer, newOptions, options);
          if (group.continued) {
            var hStrut = 8.5 / options.fontMetrics().ptPerEm;
            var dStrut = 3.5 / options.fontMetrics().ptPerEm;
            numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
            numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
          }
          newOptions = options.havingStyle(dstyle);
          var denomm = buildGroup(group.denom, newOptions, options);
          var rule;
          var ruleWidth;
          var ruleSpacing;
          if (group.hasBarLine) {
            if (group.barSize) {
              ruleWidth = calculateSize(group.barSize, options);
              rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
            } else {
              rule = buildCommon.makeLineSpan("frac-line", options);
            }
            ruleWidth = rule.height;
            ruleSpacing = rule.height;
          } else {
            rule = null;
            ruleWidth = 0;
            ruleSpacing = options.fontMetrics().defaultRuleThickness;
          }
          var numShift;
          var clearance;
          var denomShift;
          if (style.size === src_Style.DISPLAY.size || group.size === "display") {
            numShift = options.fontMetrics().num1;
            if (ruleWidth > 0) {
              clearance = 3 * ruleSpacing;
            } else {
              clearance = 7 * ruleSpacing;
            }
            denomShift = options.fontMetrics().denom1;
          } else {
            if (ruleWidth > 0) {
              numShift = options.fontMetrics().num2;
              clearance = ruleSpacing;
            } else {
              numShift = options.fontMetrics().num3;
              clearance = 3 * ruleSpacing;
            }
            denomShift = options.fontMetrics().denom2;
          }
          var frac;
          if (!rule) {
            var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
            if (candidateClearance < clearance) {
              numShift += 0.5 * (clearance - candidateClearance);
              denomShift += 0.5 * (clearance - candidateClearance);
            }
            frac = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: denomm,
                shift: denomShift
              }, {
                type: "elem",
                elem: numerm,
                shift: -numShift
              }]
            }, options);
          } else {
            var axisHeight = options.fontMetrics().axisHeight;
            if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
              numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
            }
            if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
              denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
            }
            var midShift = -(axisHeight - 0.5 * ruleWidth);
            frac = buildCommon.makeVList({
              positionType: "individualShift",
              children: [{
                type: "elem",
                elem: denomm,
                shift: denomShift
              }, {
                type: "elem",
                elem: rule,
                shift: midShift
              }, {
                type: "elem",
                elem: numerm,
                shift: -numShift
              }]
            }, options);
          }
          newOptions = options.havingStyle(style);
          frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
          frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
          var delimSize;
          if (style.size === src_Style.DISPLAY.size) {
            delimSize = options.fontMetrics().delim1;
          } else if (style.size === src_Style.SCRIPTSCRIPT.size) {
            delimSize = options.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;
          } else {
            delimSize = options.fontMetrics().delim2;
          }
          var leftDelim;
          var rightDelim;
          if (group.leftDelim == null) {
            leftDelim = makeNullDelimiter(options, ["mopen"]);
          } else {
            leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
          }
          if (group.continued) {
            rightDelim = buildCommon.makeSpan([]);
          } else if (group.rightDelim == null) {
            rightDelim = makeNullDelimiter(options, ["mclose"]);
          } else {
            rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
          }
          return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
        };
        var genfrac_mathmlBuilder = function mathmlBuilder2(group, options) {
          var node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
          if (!group.hasBarLine) {
            node.setAttribute("linethickness", "0px");
          } else if (group.barSize) {
            var ruleWidth = calculateSize(group.barSize, options);
            node.setAttribute("linethickness", ruleWidth + "em");
          }
          var style = adjustStyle(group.size, options.style);
          if (style.size !== options.style.size) {
            node = new mathMLTree.MathNode("mstyle", [node]);
            var isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
            node.setAttribute("displaystyle", isDisplay);
            node.setAttribute("scriptlevel", "0");
          }
          if (group.leftDelim != null || group.rightDelim != null) {
            var withDelims = [];
            if (group.leftDelim != null) {
              var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
              leftOp.setAttribute("fence", "true");
              withDelims.push(leftOp);
            }
            withDelims.push(node);
            if (group.rightDelim != null) {
              var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
              rightOp.setAttribute("fence", "true");
              withDelims.push(rightOp);
            }
            return makeRow(withDelims);
          }
          return node;
        };
        defineFunction({
          type: "genfrac",
          names: [
            "\\dfrac",
            "\\frac",
            "\\tfrac",
            "\\dbinom",
            "\\binom",
            "\\tbinom",
            "\\\\atopfrac",
            "\\\\bracefrac",
            "\\\\brackfrac"
          ],
          props: {
            numArgs: 2,
            allowedInArgument: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            var numer = args[0];
            var denom = args[1];
            var hasBarLine;
            var leftDelim = null;
            var rightDelim = null;
            var size = "auto";
            switch (funcName) {
              case "\\dfrac":
              case "\\frac":
              case "\\tfrac":
                hasBarLine = true;
                break;
              case "\\\\atopfrac":
                hasBarLine = false;
                break;
              case "\\dbinom":
              case "\\binom":
              case "\\tbinom":
                hasBarLine = false;
                leftDelim = "(";
                rightDelim = ")";
                break;
              case "\\\\bracefrac":
                hasBarLine = false;
                leftDelim = "\\{";
                rightDelim = "\\}";
                break;
              case "\\\\brackfrac":
                hasBarLine = false;
                leftDelim = "[";
                rightDelim = "]";
                break;
              default:
                throw new Error("Unrecognized genfrac command");
            }
            switch (funcName) {
              case "\\dfrac":
              case "\\dbinom":
                size = "display";
                break;
              case "\\tfrac":
              case "\\tbinom":
                size = "text";
                break;
            }
            return {
              type: "genfrac",
              mode: parser2.mode,
              continued: false,
              numer,
              denom,
              hasBarLine,
              leftDelim,
              rightDelim,
              size,
              barSize: null
            };
          },
          htmlBuilder: genfrac_htmlBuilder,
          mathmlBuilder: genfrac_mathmlBuilder
        });
        defineFunction({
          type: "genfrac",
          names: ["\\cfrac"],
          props: {
            numArgs: 2
          },
          handler: function handler(_ref2, args) {
            var parser2 = _ref2.parser, funcName = _ref2.funcName;
            var numer = args[0];
            var denom = args[1];
            return {
              type: "genfrac",
              mode: parser2.mode,
              continued: true,
              numer,
              denom,
              hasBarLine: true,
              leftDelim: null,
              rightDelim: null,
              size: "display",
              barSize: null
            };
          }
        });
        defineFunction({
          type: "infix",
          names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
          props: {
            numArgs: 0,
            infix: true
          },
          handler: function handler(_ref3) {
            var parser2 = _ref3.parser, funcName = _ref3.funcName, token = _ref3.token;
            var replaceWith;
            switch (funcName) {
              case "\\over":
                replaceWith = "\\frac";
                break;
              case "\\choose":
                replaceWith = "\\binom";
                break;
              case "\\atop":
                replaceWith = "\\\\atopfrac";
                break;
              case "\\brace":
                replaceWith = "\\\\bracefrac";
                break;
              case "\\brack":
                replaceWith = "\\\\brackfrac";
                break;
              default:
                throw new Error("Unrecognized infix genfrac command");
            }
            return {
              type: "infix",
              mode: parser2.mode,
              replaceWith,
              token
            };
          }
        });
        var stylArray = ["display", "text", "script", "scriptscript"];
        var delimFromValue = function delimFromValue2(delimString) {
          var delim = null;
          if (delimString.length > 0) {
            delim = delimString;
            delim = delim === "." ? null : delim;
          }
          return delim;
        };
        defineFunction({
          type: "genfrac",
          names: ["\\genfrac"],
          props: {
            numArgs: 6,
            allowedInArgument: true,
            argTypes: ["math", "math", "size", "text", "math", "math"]
          },
          handler: function handler(_ref4, args) {
            var parser2 = _ref4.parser;
            var numer = args[4];
            var denom = args[5];
            var leftNode = normalizeArgument(args[0]);
            var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
            var rightNode = normalizeArgument(args[1]);
            var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
            var barNode = assertNodeType(args[2], "size");
            var hasBarLine;
            var barSize = null;
            if (barNode.isBlank) {
              hasBarLine = true;
            } else {
              barSize = barNode.value;
              hasBarLine = barSize.number > 0;
            }
            var size = "auto";
            var styl = args[3];
            if (styl.type === "ordgroup") {
              if (styl.body.length > 0) {
                var textOrd = assertNodeType(styl.body[0], "textord");
                size = stylArray[Number(textOrd.text)];
              }
            } else {
              styl = assertNodeType(styl, "textord");
              size = stylArray[Number(styl.text)];
            }
            return {
              type: "genfrac",
              mode: parser2.mode,
              numer,
              denom,
              continued: false,
              hasBarLine,
              barSize,
              leftDelim,
              rightDelim,
              size
            };
          },
          htmlBuilder: genfrac_htmlBuilder,
          mathmlBuilder: genfrac_mathmlBuilder
        });
        defineFunction({
          type: "infix",
          names: ["\\above"],
          props: {
            numArgs: 1,
            argTypes: ["size"],
            infix: true
          },
          handler: function handler(_ref5, args) {
            var parser2 = _ref5.parser, funcName = _ref5.funcName, token = _ref5.token;
            return {
              type: "infix",
              mode: parser2.mode,
              replaceWith: "\\\\abovefrac",
              size: assertNodeType(args[0], "size").value,
              token
            };
          }
        });
        defineFunction({
          type: "genfrac",
          names: ["\\\\abovefrac"],
          props: {
            numArgs: 3,
            argTypes: ["math", "size", "math"]
          },
          handler: function handler(_ref6, args) {
            var parser2 = _ref6.parser, funcName = _ref6.funcName;
            var numer = args[0];
            var barSize = assert(assertNodeType(args[1], "infix").size);
            var denom = args[2];
            var hasBarLine = barSize.number > 0;
            return {
              type: "genfrac",
              mode: parser2.mode,
              numer,
              denom,
              continued: false,
              hasBarLine,
              barSize,
              leftDelim: null,
              rightDelim: null,
              size: "auto"
            };
          },
          htmlBuilder: genfrac_htmlBuilder,
          mathmlBuilder: genfrac_mathmlBuilder
        });
        ;
        var horizBrace_htmlBuilder = function htmlBuilder2(grp, options) {
          var style = options.style;
          var supSubGroup;
          var group;
          if (grp.type === "supsub") {
            supSubGroup = grp.sup ? buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildGroup(grp.sub, options.havingStyle(style.sub()), options);
            group = assertNodeType(grp.base, "horizBrace");
          } else {
            group = assertNodeType(grp, "horizBrace");
          }
          var body = buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY));
          var braceBody = stretchy.svgSpan(group, options);
          var vlist;
          if (group.isOver) {
            vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: body
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: braceBody
              }]
            }, options);
            vlist.children[0].children[0].children[1].classes.push("svg-align");
          } else {
            vlist = buildCommon.makeVList({
              positionType: "bottom",
              positionData: body.depth + 0.1 + braceBody.height,
              children: [{
                type: "elem",
                elem: braceBody
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: body
              }]
            }, options);
            vlist.children[0].children[0].children[0].classes.push("svg-align");
          }
          if (supSubGroup) {
            var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
            if (group.isOver) {
              vlist = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: vSpan
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: supSubGroup
                }]
              }, options);
            } else {
              vlist = buildCommon.makeVList({
                positionType: "bottom",
                positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
                children: [{
                  type: "elem",
                  elem: supSubGroup
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: vSpan
                }]
              }, options);
            }
          }
          return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
        };
        var horizBrace_mathmlBuilder = function mathmlBuilder2(group, options) {
          var accentNode = stretchy.mathMLnode(group.label);
          return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
        };
        defineFunction({
          type: "horizBrace",
          names: ["\\overbrace", "\\underbrace"],
          props: {
            numArgs: 1
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            return {
              type: "horizBrace",
              mode: parser2.mode,
              label: funcName,
              isOver: /^\\over/.test(funcName),
              base: args[0]
            };
          },
          htmlBuilder: horizBrace_htmlBuilder,
          mathmlBuilder: horizBrace_mathmlBuilder
        });
        ;
        defineFunction({
          type: "href",
          names: ["\\href"],
          props: {
            numArgs: 2,
            argTypes: ["url", "original"],
            allowedInText: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser;
            var body = args[1];
            var href = assertNodeType(args[0], "url").url;
            if (!parser2.settings.isTrusted({
              command: "\\href",
              url: href
            })) {
              return parser2.formatUnsupportedCmd("\\href");
            }
            return {
              type: "href",
              mode: parser2.mode,
              href,
              body: ordargument(body)
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var elements = buildExpression(group.body, options, false);
            return buildCommon.makeAnchor(group.href, [], elements, options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var math2 = buildExpressionRow(group.body, options);
            if (!(math2 instanceof MathNode)) {
              math2 = new MathNode("mrow", [math2]);
            }
            math2.setAttribute("href", group.href);
            return math2;
          }
        });
        defineFunction({
          type: "href",
          names: ["\\url"],
          props: {
            numArgs: 1,
            argTypes: ["url"],
            allowedInText: true
          },
          handler: function handler(_ref2, args) {
            var parser2 = _ref2.parser;
            var href = assertNodeType(args[0], "url").url;
            if (!parser2.settings.isTrusted({
              command: "\\url",
              url: href
            })) {
              return parser2.formatUnsupportedCmd("\\url");
            }
            var chars = [];
            for (var i2 = 0; i2 < href.length; i2++) {
              var c = href[i2];
              if (c === "~") {
                c = "\\textasciitilde";
              }
              chars.push({
                type: "textord",
                mode: "text",
                text: c
              });
            }
            var body = {
              type: "text",
              mode: parser2.mode,
              font: "\\texttt",
              body: chars
            };
            return {
              type: "href",
              mode: parser2.mode,
              href,
              body: ordargument(body)
            };
          }
        });
        ;
        defineFunction({
          type: "hbox",
          names: ["\\hbox"],
          props: {
            numArgs: 1,
            argTypes: ["text"],
            allowedInText: true,
            primitive: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser;
            return {
              type: "hbox",
              mode: parser2.mode,
              body: ordargument(args[0])
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var elements = buildExpression(group.body, options, false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            return new mathMLTree.MathNode("mrow", buildMathML_buildExpression(group.body, options));
          }
        });
        ;
        defineFunction({
          type: "html",
          names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
          props: {
            numArgs: 2,
            argTypes: ["raw", "original"],
            allowedInText: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName, token = _ref.token;
            var value = assertNodeType(args[0], "raw").string;
            var body = args[1];
            if (parser2.settings.strict) {
              parser2.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
            }
            var trustContext;
            var attributes = {};
            switch (funcName) {
              case "\\htmlClass":
                attributes.class = value;
                trustContext = {
                  command: "\\htmlClass",
                  class: value
                };
                break;
              case "\\htmlId":
                attributes.id = value;
                trustContext = {
                  command: "\\htmlId",
                  id: value
                };
                break;
              case "\\htmlStyle":
                attributes.style = value;
                trustContext = {
                  command: "\\htmlStyle",
                  style: value
                };
                break;
              case "\\htmlData": {
                var data = value.split(",");
                for (var i2 = 0; i2 < data.length; i2++) {
                  var keyVal = data[i2].split("=");
                  if (keyVal.length !== 2) {
                    throw new src_ParseError("Error parsing key-value for \\htmlData");
                  }
                  attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
                }
                trustContext = {
                  command: "\\htmlData",
                  attributes
                };
                break;
              }
              default:
                throw new Error("Unrecognized html command");
            }
            if (!parser2.settings.isTrusted(trustContext)) {
              return parser2.formatUnsupportedCmd(funcName);
            }
            return {
              type: "html",
              mode: parser2.mode,
              attributes,
              body: ordargument(body)
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var elements = buildExpression(group.body, options, false);
            var classes = ["enclosing"];
            if (group.attributes.class) {
              classes.push.apply(classes, group.attributes.class.trim().split(/\s+/));
            }
            var span = buildCommon.makeSpan(classes, elements, options);
            for (var attr in group.attributes) {
              if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
                span.setAttribute(attr, group.attributes[attr]);
              }
            }
            return span;
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            return buildExpressionRow(group.body, options);
          }
        });
        ;
        defineFunction({
          type: "htmlmathml",
          names: ["\\html@mathml"],
          props: {
            numArgs: 2,
            allowedInText: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser;
            return {
              type: "htmlmathml",
              mode: parser2.mode,
              html: ordargument(args[0]),
              mathml: ordargument(args[1])
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var elements = buildExpression(group.html, options, false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            return buildExpressionRow(group.mathml, options);
          }
        });
        ;
        var sizeData = function sizeData2(str) {
          if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
            return {
              number: +str,
              unit: "bp"
            };
          } else {
            var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
            if (!match) {
              throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
            }
            var data = {
              number: +(match[1] + match[2]),
              unit: match[3]
            };
            if (!validUnit(data)) {
              throw new src_ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
            }
            return data;
          }
        };
        defineFunction({
          type: "includegraphics",
          names: ["\\includegraphics"],
          props: {
            numArgs: 1,
            numOptionalArgs: 1,
            argTypes: ["raw", "url"],
            allowedInText: false
          },
          handler: function handler(_ref, args, optArgs) {
            var parser2 = _ref.parser;
            var width = {
              number: 0,
              unit: "em"
            };
            var height = {
              number: 0.9,
              unit: "em"
            };
            var totalheight = {
              number: 0,
              unit: "em"
            };
            var alt = "";
            if (optArgs[0]) {
              var attributeStr = assertNodeType(optArgs[0], "raw").string;
              var attributes = attributeStr.split(",");
              for (var i2 = 0; i2 < attributes.length; i2++) {
                var keyVal = attributes[i2].split("=");
                if (keyVal.length === 2) {
                  var str = keyVal[1].trim();
                  switch (keyVal[0].trim()) {
                    case "alt":
                      alt = str;
                      break;
                    case "width":
                      width = sizeData(str);
                      break;
                    case "height":
                      height = sizeData(str);
                      break;
                    case "totalheight":
                      totalheight = sizeData(str);
                      break;
                    default:
                      throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                  }
                }
              }
            }
            var src = assertNodeType(args[0], "url").url;
            if (alt === "") {
              alt = src;
              alt = alt.replace(/^.*[\\/]/, "");
              alt = alt.substring(0, alt.lastIndexOf("."));
            }
            if (!parser2.settings.isTrusted({
              command: "\\includegraphics",
              url: src
            })) {
              return parser2.formatUnsupportedCmd("\\includegraphics");
            }
            return {
              type: "includegraphics",
              mode: parser2.mode,
              alt,
              width,
              height,
              totalheight,
              src
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var height = calculateSize(group.height, options);
            var depth = 0;
            if (group.totalheight.number > 0) {
              depth = calculateSize(group.totalheight, options) - height;
              depth = Number(depth.toFixed(2));
            }
            var width = 0;
            if (group.width.number > 0) {
              width = calculateSize(group.width, options);
            }
            var style = {
              height: height + depth + "em"
            };
            if (width > 0) {
              style.width = width + "em";
            }
            if (depth > 0) {
              style.verticalAlign = -depth + "em";
            }
            var node = new Img(group.src, group.alt, style);
            node.height = height;
            node.depth = depth;
            return node;
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var node = new mathMLTree.MathNode("mglyph", []);
            node.setAttribute("alt", group.alt);
            var height = calculateSize(group.height, options);
            var depth = 0;
            if (group.totalheight.number > 0) {
              depth = calculateSize(group.totalheight, options) - height;
              depth = depth.toFixed(2);
              node.setAttribute("valign", "-" + depth + "em");
            }
            node.setAttribute("height", height + depth + "em");
            if (group.width.number > 0) {
              var width = calculateSize(group.width, options);
              node.setAttribute("width", width + "em");
            }
            node.setAttribute("src", group.src);
            return node;
          }
        });
        ;
        defineFunction({
          type: "kern",
          names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
          props: {
            numArgs: 1,
            argTypes: ["size"],
            primitive: true,
            allowedInText: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            var size = assertNodeType(args[0], "size");
            if (parser2.settings.strict) {
              var mathFunction = funcName[1] === "m";
              var muUnit = size.value.unit === "mu";
              if (mathFunction) {
                if (!muUnit) {
                  parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size.value.unit + " units"));
                }
                if (parser2.mode !== "math") {
                  parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
                }
              } else {
                if (muUnit) {
                  parser2.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
                }
              }
            }
            return {
              type: "kern",
              mode: parser2.mode,
              dimension: size.value
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            return buildCommon.makeGlue(group.dimension, options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var dimension = calculateSize(group.dimension, options);
            return new mathMLTree.SpaceNode(dimension);
          }
        });
        ;
        defineFunction({
          type: "lap",
          names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            var body = args[0];
            return {
              type: "lap",
              mode: parser2.mode,
              alignment: funcName.slice(5),
              body
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var inner2;
            if (group.alignment === "clap") {
              inner2 = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
              inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
            } else {
              inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
            }
            var fix = buildCommon.makeSpan(["fix"], []);
            var node = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
            var strut = buildCommon.makeSpan(["strut"]);
            strut.style.height = node.height + node.depth + "em";
            strut.style.verticalAlign = -node.depth + "em";
            node.children.unshift(strut);
            node = buildCommon.makeSpan(["thinbox"], [node], options);
            return buildCommon.makeSpan(["mord", "vbox"], [node], options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
            if (group.alignment !== "rlap") {
              var offset = group.alignment === "llap" ? "-1" : "-0.5";
              node.setAttribute("lspace", offset + "width");
            }
            node.setAttribute("width", "0px");
            return node;
          }
        });
        ;
        defineFunction({
          type: "styling",
          names: ["\\(", "$"],
          props: {
            numArgs: 0,
            allowedInText: true,
            allowedInMath: false
          },
          handler: function handler(_ref, args) {
            var funcName = _ref.funcName, parser2 = _ref.parser;
            var outerMode = parser2.mode;
            parser2.switchMode("math");
            var close = funcName === "\\(" ? "\\)" : "$";
            var body = parser2.parseExpression(false, close);
            parser2.expect(close);
            parser2.switchMode(outerMode);
            return {
              type: "styling",
              mode: parser2.mode,
              style: "text",
              body
            };
          }
        });
        defineFunction({
          type: "text",
          names: ["\\)", "\\]"],
          props: {
            numArgs: 0,
            allowedInText: true,
            allowedInMath: false
          },
          handler: function handler(context, args) {
            throw new src_ParseError("Mismatched " + context.funcName);
          }
        });
        ;
        var chooseMathStyle = function chooseMathStyle2(group, options) {
          switch (options.style.size) {
            case src_Style.DISPLAY.size:
              return group.display;
            case src_Style.TEXT.size:
              return group.text;
            case src_Style.SCRIPT.size:
              return group.script;
            case src_Style.SCRIPTSCRIPT.size:
              return group.scriptscript;
            default:
              return group.text;
          }
        };
        defineFunction({
          type: "mathchoice",
          names: ["\\mathchoice"],
          props: {
            numArgs: 4,
            primitive: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser;
            return {
              type: "mathchoice",
              mode: parser2.mode,
              display: ordargument(args[0]),
              text: ordargument(args[1]),
              script: ordargument(args[2]),
              scriptscript: ordargument(args[3])
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var body = chooseMathStyle(group, options);
            var elements = buildExpression(body, options, false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var body = chooseMathStyle(group, options);
            return buildExpressionRow(body, options);
          }
        });
        ;
        var assembleSupSub = function assembleSupSub2(base2, supGroup, subGroup, options, style, slant, baseShift) {
          base2 = buildCommon.makeSpan([], [base2]);
          var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
          var sub;
          var sup;
          if (supGroup) {
            var elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);
            sup = {
              elem,
              kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
            };
          }
          if (subGroup) {
            var _elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);
            sub = {
              elem: _elem,
              kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
            };
          }
          var finalGroup;
          if (sup && sub) {
            var bottom = options.fontMetrics().bigOpSpacing5 + sub.elem.height + sub.elem.depth + sub.kern + base2.depth + baseShift;
            finalGroup = buildCommon.makeVList({
              positionType: "bottom",
              positionData: bottom,
              children: [{
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }, {
                type: "elem",
                elem: sub.elem,
                marginLeft: -slant + "em"
              }, {
                type: "kern",
                size: sub.kern
              }, {
                type: "elem",
                elem: base2
              }, {
                type: "kern",
                size: sup.kern
              }, {
                type: "elem",
                elem: sup.elem,
                marginLeft: slant + "em"
              }, {
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }]
            }, options);
          } else if (sub) {
            var top2 = base2.height - baseShift;
            finalGroup = buildCommon.makeVList({
              positionType: "top",
              positionData: top2,
              children: [{
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }, {
                type: "elem",
                elem: sub.elem,
                marginLeft: -slant + "em"
              }, {
                type: "kern",
                size: sub.kern
              }, {
                type: "elem",
                elem: base2
              }]
            }, options);
          } else if (sup) {
            var _bottom = base2.depth + baseShift;
            finalGroup = buildCommon.makeVList({
              positionType: "bottom",
              positionData: _bottom,
              children: [{
                type: "elem",
                elem: base2
              }, {
                type: "kern",
                size: sup.kern
              }, {
                type: "elem",
                elem: sup.elem,
                marginLeft: slant + "em"
              }, {
                type: "kern",
                size: options.fontMetrics().bigOpSpacing5
              }]
            }, options);
          } else {
            return base2;
          }
          var parts = [finalGroup];
          if (sub && slant !== 0 && !subIsSingleCharacter) {
            var spacer = buildCommon.makeSpan(["mspace"], [], options);
            spacer.style.marginRight = slant + "em";
            parts.unshift(spacer);
          }
          return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
        };
        ;
        var noSuccessor = ["\\smallint"];
        var op_htmlBuilder = function htmlBuilder2(grp, options) {
          var supGroup;
          var subGroup;
          var hasLimits = false;
          var group;
          if (grp.type === "supsub") {
            supGroup = grp.sup;
            subGroup = grp.sub;
            group = assertNodeType(grp.base, "op");
            hasLimits = true;
          } else {
            group = assertNodeType(grp, "op");
          }
          var style = options.style;
          var large = false;
          if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
            large = true;
          }
          var base2;
          if (group.symbol) {
            var fontName = large ? "Size2-Regular" : "Size1-Regular";
            var stash = "";
            if (group.name === "\\oiint" || group.name === "\\oiiint") {
              stash = group.name.substr(1);
              group.name = stash === "oiint" ? "\\iint" : "\\iiint";
            }
            base2 = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
            if (stash.length > 0) {
              var italic = base2.italic;
              var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
              base2 = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: base2,
                  shift: 0
                }, {
                  type: "elem",
                  elem: oval,
                  shift: large ? 0.08 : 0
                }]
              }, options);
              group.name = "\\" + stash;
              base2.classes.unshift("mop");
              base2.italic = italic;
            }
          } else if (group.body) {
            var inner2 = buildExpression(group.body, options, true);
            if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
              base2 = inner2[0];
              base2.classes[0] = "mop";
            } else {
              base2 = buildCommon.makeSpan(["mop"], inner2, options);
            }
          } else {
            var output = [];
            for (var i2 = 1; i2 < group.name.length; i2++) {
              output.push(buildCommon.mathsym(group.name[i2], group.mode, options));
            }
            base2 = buildCommon.makeSpan(["mop"], output, options);
          }
          var baseShift = 0;
          var slant = 0;
          if ((base2 instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
            baseShift = (base2.height - base2.depth) / 2 - options.fontMetrics().axisHeight;
            slant = base2.italic;
          }
          if (hasLimits) {
            return assembleSupSub(base2, supGroup, subGroup, options, style, slant, baseShift);
          } else {
            if (baseShift) {
              base2.style.position = "relative";
              base2.style.top = baseShift + "em";
            }
            return base2;
          }
        };
        var op_mathmlBuilder = function mathmlBuilder2(group, options) {
          var node;
          if (group.symbol) {
            node = new MathNode("mo", [makeText(group.name, group.mode)]);
            if (utils.contains(noSuccessor, group.name)) {
              node.setAttribute("largeop", "false");
            }
          } else if (group.body) {
            node = new MathNode("mo", buildMathML_buildExpression(group.body, options));
          } else {
            node = new MathNode("mi", [new TextNode2(group.name.slice(1))]);
            var operator2 = new MathNode("mo", [makeText("\u2061", "text")]);
            if (group.parentIsSupSub) {
              node = new MathNode("mrow", [node, operator2]);
            } else {
              node = newDocumentFragment([node, operator2]);
            }
          }
          return node;
        };
        var singleCharBigOps = {
          "\u220F": "\\prod",
          "\u2210": "\\coprod",
          "\u2211": "\\sum",
          "\u22C0": "\\bigwedge",
          "\u22C1": "\\bigvee",
          "\u22C2": "\\bigcap",
          "\u22C3": "\\bigcup",
          "\u2A00": "\\bigodot",
          "\u2A01": "\\bigoplus",
          "\u2A02": "\\bigotimes",
          "\u2A04": "\\biguplus",
          "\u2A06": "\\bigsqcup"
        };
        defineFunction({
          type: "op",
          names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "\u220F", "\u2210", "\u2211", "\u22C0", "\u22C1", "\u22C2", "\u22C3", "\u2A00", "\u2A01", "\u2A02", "\u2A04", "\u2A06"],
          props: {
            numArgs: 0
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            var fName = funcName;
            if (fName.length === 1) {
              fName = singleCharBigOps[fName];
            }
            return {
              type: "op",
              mode: parser2.mode,
              limits: true,
              parentIsSupSub: false,
              symbol: true,
              name: fName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        defineFunction({
          type: "op",
          names: ["\\mathop"],
          props: {
            numArgs: 1,
            primitive: true
          },
          handler: function handler(_ref2, args) {
            var parser2 = _ref2.parser;
            var body = args[0];
            return {
              type: "op",
              mode: parser2.mode,
              limits: false,
              parentIsSupSub: false,
              symbol: false,
              body: ordargument(body)
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        var singleCharIntegrals = {
          "\u222B": "\\int",
          "\u222C": "\\iint",
          "\u222D": "\\iiint",
          "\u222E": "\\oint",
          "\u222F": "\\oiint",
          "\u2230": "\\oiiint"
        };
        defineFunction({
          type: "op",
          names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
          props: {
            numArgs: 0
          },
          handler: function handler(_ref3) {
            var parser2 = _ref3.parser, funcName = _ref3.funcName;
            return {
              type: "op",
              mode: parser2.mode,
              limits: false,
              parentIsSupSub: false,
              symbol: false,
              name: funcName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        defineFunction({
          type: "op",
          names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
          props: {
            numArgs: 0
          },
          handler: function handler(_ref4) {
            var parser2 = _ref4.parser, funcName = _ref4.funcName;
            return {
              type: "op",
              mode: parser2.mode,
              limits: true,
              parentIsSupSub: false,
              symbol: false,
              name: funcName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        defineFunction({
          type: "op",
          names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "\u222B", "\u222C", "\u222D", "\u222E", "\u222F", "\u2230"],
          props: {
            numArgs: 0
          },
          handler: function handler(_ref5) {
            var parser2 = _ref5.parser, funcName = _ref5.funcName;
            var fName = funcName;
            if (fName.length === 1) {
              fName = singleCharIntegrals[fName];
            }
            return {
              type: "op",
              mode: parser2.mode,
              limits: false,
              parentIsSupSub: false,
              symbol: true,
              name: fName
            };
          },
          htmlBuilder: op_htmlBuilder,
          mathmlBuilder: op_mathmlBuilder
        });
        ;
        var builtinMacros = {};
        var macros = builtinMacros;
        function defineMacro(name2, body) {
          builtinMacros[name2] = body;
        }
        defineMacro("\\noexpand", function(context) {
          var t2 = context.popToken();
          if (context.isExpandable(t2.text)) {
            t2.noexpand = true;
            t2.treatAsRelax = true;
          }
          return {
            tokens: [t2],
            numArgs: 0
          };
        });
        defineMacro("\\expandafter", function(context) {
          var t2 = context.popToken();
          context.expandOnce(true);
          return {
            tokens: [t2],
            numArgs: 0
          };
        });
        defineMacro("\\@firstoftwo", function(context) {
          var args = context.consumeArgs(2);
          return {
            tokens: args[0],
            numArgs: 0
          };
        });
        defineMacro("\\@secondoftwo", function(context) {
          var args = context.consumeArgs(2);
          return {
            tokens: args[1],
            numArgs: 0
          };
        });
        defineMacro("\\@ifnextchar", function(context) {
          var args = context.consumeArgs(3);
          context.consumeSpaces();
          var nextToken = context.future();
          if (args[0].length === 1 && args[0][0].text === nextToken.text) {
            return {
              tokens: args[1],
              numArgs: 0
            };
          } else {
            return {
              tokens: args[2],
              numArgs: 0
            };
          }
        });
        defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
        defineMacro("\\TextOrMath", function(context) {
          var args = context.consumeArgs(2);
          if (context.mode === "text") {
            return {
              tokens: args[0],
              numArgs: 0
            };
          } else {
            return {
              tokens: args[1],
              numArgs: 0
            };
          }
        });
        var digitToNumber = {
          "0": 0,
          "1": 1,
          "2": 2,
          "3": 3,
          "4": 4,
          "5": 5,
          "6": 6,
          "7": 7,
          "8": 8,
          "9": 9,
          "a": 10,
          "A": 10,
          "b": 11,
          "B": 11,
          "c": 12,
          "C": 12,
          "d": 13,
          "D": 13,
          "e": 14,
          "E": 14,
          "f": 15,
          "F": 15
        };
        defineMacro("\\char", function(context) {
          var token = context.popToken();
          var base2;
          var number2 = "";
          if (token.text === "'") {
            base2 = 8;
            token = context.popToken();
          } else if (token.text === '"') {
            base2 = 16;
            token = context.popToken();
          } else if (token.text === "`") {
            token = context.popToken();
            if (token.text[0] === "\\") {
              number2 = token.text.charCodeAt(1);
            } else if (token.text === "EOF") {
              throw new src_ParseError("\\char` missing argument");
            } else {
              number2 = token.text.charCodeAt(0);
            }
          } else {
            base2 = 10;
          }
          if (base2) {
            number2 = digitToNumber[token.text];
            if (number2 == null || number2 >= base2) {
              throw new src_ParseError("Invalid base-" + base2 + " digit " + token.text);
            }
            var digit;
            while ((digit = digitToNumber[context.future().text]) != null && digit < base2) {
              number2 *= base2;
              number2 += digit;
              context.popToken();
            }
          }
          return "\\@char{" + number2 + "}";
        });
        var newcommand = function newcommand2(context, existsOK, nonexistsOK) {
          var arg = context.consumeArg().tokens;
          if (arg.length !== 1) {
            throw new src_ParseError("\\newcommand's first argument must be a macro name");
          }
          var name2 = arg[0].text;
          var exists = context.isDefined(name2);
          if (exists && !existsOK) {
            throw new src_ParseError("\\newcommand{" + name2 + "} attempting to redefine " + (name2 + "; use \\renewcommand"));
          }
          if (!exists && !nonexistsOK) {
            throw new src_ParseError("\\renewcommand{" + name2 + "} when command " + name2 + " does not yet exist; use \\newcommand");
          }
          var numArgs = 0;
          arg = context.consumeArg().tokens;
          if (arg.length === 1 && arg[0].text === "[") {
            var argText = "";
            var token = context.expandNextToken();
            while (token.text !== "]" && token.text !== "EOF") {
              argText += token.text;
              token = context.expandNextToken();
            }
            if (!argText.match(/^\s*[0-9]+\s*$/)) {
              throw new src_ParseError("Invalid number of arguments: " + argText);
            }
            numArgs = parseInt(argText);
            arg = context.consumeArg().tokens;
          }
          context.macros.set(name2, {
            tokens: arg,
            numArgs
          });
          return "";
        };
        defineMacro("\\newcommand", function(context) {
          return newcommand(context, false, true);
        });
        defineMacro("\\renewcommand", function(context) {
          return newcommand(context, true, false);
        });
        defineMacro("\\providecommand", function(context) {
          return newcommand(context, true, true);
        });
        defineMacro("\\message", function(context) {
          var arg = context.consumeArgs(1)[0];
          console.log(arg.reverse().map(function(token) {
            return token.text;
          }).join(""));
          return "";
        });
        defineMacro("\\errmessage", function(context) {
          var arg = context.consumeArgs(1)[0];
          console.error(arg.reverse().map(function(token) {
            return token.text;
          }).join(""));
          return "";
        });
        defineMacro("\\show", function(context) {
          var tok = context.popToken();
          var name2 = tok.text;
          console.log(tok, context.macros.get(name2), src_functions[name2], src_symbols.math[name2], src_symbols.text[name2]);
          return "";
        });
        defineMacro("\\bgroup", "{");
        defineMacro("\\egroup", "}");
        defineMacro("~", "\\nobreakspace");
        defineMacro("\\lq", "`");
        defineMacro("\\rq", "'");
        defineMacro("\\aa", "\\r a");
        defineMacro("\\AA", "\\r A");
        defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`\xA9}");
        defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
        defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`\xAE}");
        defineMacro("\u212C", "\\mathscr{B}");
        defineMacro("\u2130", "\\mathscr{E}");
        defineMacro("\u2131", "\\mathscr{F}");
        defineMacro("\u210B", "\\mathscr{H}");
        defineMacro("\u2110", "\\mathscr{I}");
        defineMacro("\u2112", "\\mathscr{L}");
        defineMacro("\u2133", "\\mathscr{M}");
        defineMacro("\u211B", "\\mathscr{R}");
        defineMacro("\u212D", "\\mathfrak{C}");
        defineMacro("\u210C", "\\mathfrak{H}");
        defineMacro("\u2128", "\\mathfrak{Z}");
        defineMacro("\\Bbbk", "\\Bbb{k}");
        defineMacro("\xB7", "\\cdotp");
        defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
        defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
        defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
        defineMacro("\\mathstrut", "\\vphantom{(}");
        defineMacro("\\underbar", "\\underline{\\text{#1}}");
        defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
        defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`\u2260}}");
        defineMacro("\\ne", "\\neq");
        defineMacro("\u2260", "\\neq");
        defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`\u2209}}");
        defineMacro("\u2209", "\\notin");
        defineMacro("\u2258", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`\u2258}}");
        defineMacro("\u2259", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`\u2258}}");
        defineMacro("\u225A", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`\u225A}}");
        defineMacro("\u225B", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`\u225B}}");
        defineMacro("\u225D", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`\u225D}}");
        defineMacro("\u225E", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`\u225E}}");
        defineMacro("\u225F", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`\u225F}}");
        defineMacro("\u27C2", "\\perp");
        defineMacro("\u203C", "\\mathclose{!\\mkern-0.8mu!}");
        defineMacro("\u220C", "\\notni");
        defineMacro("\u231C", "\\ulcorner");
        defineMacro("\u231D", "\\urcorner");
        defineMacro("\u231E", "\\llcorner");
        defineMacro("\u231F", "\\lrcorner");
        defineMacro("\xA9", "\\copyright");
        defineMacro("\xAE", "\\textregistered");
        defineMacro("\uFE0F", "\\textregistered");
        defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
        defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
        defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
        defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
        defineMacro("\\vdots", "\\mathord{\\varvdots\\rule{0pt}{15pt}}");
        defineMacro("\u22EE", "\\vdots");
        defineMacro("\\varGamma", "\\mathit{\\Gamma}");
        defineMacro("\\varDelta", "\\mathit{\\Delta}");
        defineMacro("\\varTheta", "\\mathit{\\Theta}");
        defineMacro("\\varLambda", "\\mathit{\\Lambda}");
        defineMacro("\\varXi", "\\mathit{\\Xi}");
        defineMacro("\\varPi", "\\mathit{\\Pi}");
        defineMacro("\\varSigma", "\\mathit{\\Sigma}");
        defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
        defineMacro("\\varPhi", "\\mathit{\\Phi}");
        defineMacro("\\varPsi", "\\mathit{\\Psi}");
        defineMacro("\\varOmega", "\\mathit{\\Omega}");
        defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
        defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu");
        defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
        defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
        defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
        defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
        var dotsByToken = {
          ",": "\\dotsc",
          "\\not": "\\dotsb",
          "+": "\\dotsb",
          "=": "\\dotsb",
          "<": "\\dotsb",
          ">": "\\dotsb",
          "-": "\\dotsb",
          "*": "\\dotsb",
          ":": "\\dotsb",
          "\\DOTSB": "\\dotsb",
          "\\coprod": "\\dotsb",
          "\\bigvee": "\\dotsb",
          "\\bigwedge": "\\dotsb",
          "\\biguplus": "\\dotsb",
          "\\bigcap": "\\dotsb",
          "\\bigcup": "\\dotsb",
          "\\prod": "\\dotsb",
          "\\sum": "\\dotsb",
          "\\bigotimes": "\\dotsb",
          "\\bigoplus": "\\dotsb",
          "\\bigodot": "\\dotsb",
          "\\bigsqcup": "\\dotsb",
          "\\And": "\\dotsb",
          "\\longrightarrow": "\\dotsb",
          "\\Longrightarrow": "\\dotsb",
          "\\longleftarrow": "\\dotsb",
          "\\Longleftarrow": "\\dotsb",
          "\\longleftrightarrow": "\\dotsb",
          "\\Longleftrightarrow": "\\dotsb",
          "\\mapsto": "\\dotsb",
          "\\longmapsto": "\\dotsb",
          "\\hookrightarrow": "\\dotsb",
          "\\doteq": "\\dotsb",
          "\\mathbin": "\\dotsb",
          "\\mathrel": "\\dotsb",
          "\\relbar": "\\dotsb",
          "\\Relbar": "\\dotsb",
          "\\xrightarrow": "\\dotsb",
          "\\xleftarrow": "\\dotsb",
          "\\DOTSI": "\\dotsi",
          "\\int": "\\dotsi",
          "\\oint": "\\dotsi",
          "\\iint": "\\dotsi",
          "\\iiint": "\\dotsi",
          "\\iiiint": "\\dotsi",
          "\\idotsint": "\\dotsi",
          "\\DOTSX": "\\dotsx"
        };
        defineMacro("\\dots", function(context) {
          var thedots = "\\dotso";
          var next = context.expandAfterFuture().text;
          if (next in dotsByToken) {
            thedots = dotsByToken[next];
          } else if (next.substr(0, 4) === "\\not") {
            thedots = "\\dotsb";
          } else if (next in src_symbols.math) {
            if (utils.contains(["bin", "rel"], src_symbols.math[next].group)) {
              thedots = "\\dotsb";
            }
          }
          return thedots;
        });
        var spaceAfterDots = {
          ")": true,
          "]": true,
          "\\rbrack": true,
          "\\}": true,
          "\\rbrace": true,
          "\\rangle": true,
          "\\rceil": true,
          "\\rfloor": true,
          "\\rgroup": true,
          "\\rmoustache": true,
          "\\right": true,
          "\\bigr": true,
          "\\biggr": true,
          "\\Bigr": true,
          "\\Biggr": true,
          "$": true,
          ";": true,
          ".": true,
          ",": true
        };
        defineMacro("\\dotso", function(context) {
          var next = context.future().text;
          if (next in spaceAfterDots) {
            return "\\ldots\\,";
          } else {
            return "\\ldots";
          }
        });
        defineMacro("\\dotsc", function(context) {
          var next = context.future().text;
          if (next in spaceAfterDots && next !== ",") {
            return "\\ldots\\,";
          } else {
            return "\\ldots";
          }
        });
        defineMacro("\\cdots", function(context) {
          var next = context.future().text;
          if (next in spaceAfterDots) {
            return "\\@cdots\\,";
          } else {
            return "\\@cdots";
          }
        });
        defineMacro("\\dotsb", "\\cdots");
        defineMacro("\\dotsm", "\\cdots");
        defineMacro("\\dotsi", "\\!\\cdots");
        defineMacro("\\dotsx", "\\ldots\\,");
        defineMacro("\\DOTSI", "\\relax");
        defineMacro("\\DOTSB", "\\relax");
        defineMacro("\\DOTSX", "\\relax");
        defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
        defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
        defineMacro("\\thinspace", "\\,");
        defineMacro("\\>", "\\mskip{4mu}");
        defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
        defineMacro("\\medspace", "\\:");
        defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
        defineMacro("\\thickspace", "\\;");
        defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
        defineMacro("\\negthinspace", "\\!");
        defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
        defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
        defineMacro("\\enspace", "\\kern.5em ");
        defineMacro("\\enskip", "\\hskip.5em\\relax");
        defineMacro("\\quad", "\\hskip1em\\relax");
        defineMacro("\\qquad", "\\hskip2em\\relax");
        defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
        defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
        defineMacro("\\tag@literal", function(context) {
          if (context.macros.get("\\df@tag")) {
            throw new src_ParseError("Multiple \\tag");
          }
          return "\\gdef\\df@tag{\\text{#1}}";
        });
        defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
        defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
        defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
        defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
        defineMacro("\\pmb", "\\html@mathml{\\@binrel{#1}{\\mathrlap{#1}\\kern0.5px#1}}{\\mathbf{#1}}");
        defineMacro("\\newline", "\\\\\\relax");
        defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
        var latexRaiseA = fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1] + "em";
        defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
        defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
        defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
        defineMacro("\\@hspace", "\\hskip #1\\relax");
        defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
        defineMacro("\\ordinarycolon", ":");
        defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
        defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
        defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
        defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
        defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
        defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
        defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
        defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
        defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
        defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
        defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
        defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
        defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
        defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
        defineMacro("\u2237", "\\dblcolon");
        defineMacro("\u2239", "\\eqcolon");
        defineMacro("\u2254", "\\coloneqq");
        defineMacro("\u2255", "\\eqqcolon");
        defineMacro("\u2A74", "\\Coloneqq");
        defineMacro("\\ratio", "\\vcentcolon");
        defineMacro("\\coloncolon", "\\dblcolon");
        defineMacro("\\colonequals", "\\coloneqq");
        defineMacro("\\coloncolonequals", "\\Coloneqq");
        defineMacro("\\equalscolon", "\\eqqcolon");
        defineMacro("\\equalscoloncolon", "\\Eqqcolon");
        defineMacro("\\colonminus", "\\coloneq");
        defineMacro("\\coloncolonminus", "\\Coloneq");
        defineMacro("\\minuscolon", "\\eqcolon");
        defineMacro("\\minuscoloncolon", "\\Eqcolon");
        defineMacro("\\coloncolonapprox", "\\Colonapprox");
        defineMacro("\\coloncolonsim", "\\Colonsim");
        defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
        defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
        defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
        defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
        defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`\u220C}}");
        defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
        defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
        defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
        defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
        defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
        defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
        defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
        defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
        defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{\u2269}");
        defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{\u2268}");
        defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{\u2271}");
        defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{\u2271}");
        defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{\u2270}");
        defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{\u2270}");
        defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{\u2224}");
        defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{\u2226}");
        defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{\u2288}");
        defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{\u2289}");
        defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{\u228A}");
        defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{\u2ACB}");
        defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{\u228B}");
        defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{\u2ACC}");
        defineMacro("\\imath", "\\html@mathml{\\@imath}{\u0131}");
        defineMacro("\\jmath", "\\html@mathml{\\@jmath}{\u0237}");
        defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`\u27E6}}");
        defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`\u27E7}}");
        defineMacro("\u27E6", "\\llbracket");
        defineMacro("\u27E7", "\\rrbracket");
        defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`\u2983}}");
        defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`\u2984}}");
        defineMacro("\u2983", "\\lBrace");
        defineMacro("\u2984", "\\rBrace");
        defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`\u29B5}}");
        defineMacro("\u29B5", "\\minuso");
        defineMacro("\\darr", "\\downarrow");
        defineMacro("\\dArr", "\\Downarrow");
        defineMacro("\\Darr", "\\Downarrow");
        defineMacro("\\lang", "\\langle");
        defineMacro("\\rang", "\\rangle");
        defineMacro("\\uarr", "\\uparrow");
        defineMacro("\\uArr", "\\Uparrow");
        defineMacro("\\Uarr", "\\Uparrow");
        defineMacro("\\N", "\\mathbb{N}");
        defineMacro("\\R", "\\mathbb{R}");
        defineMacro("\\Z", "\\mathbb{Z}");
        defineMacro("\\alef", "\\aleph");
        defineMacro("\\alefsym", "\\aleph");
        defineMacro("\\Alpha", "\\mathrm{A}");
        defineMacro("\\Beta", "\\mathrm{B}");
        defineMacro("\\bull", "\\bullet");
        defineMacro("\\Chi", "\\mathrm{X}");
        defineMacro("\\clubs", "\\clubsuit");
        defineMacro("\\cnums", "\\mathbb{C}");
        defineMacro("\\Complex", "\\mathbb{C}");
        defineMacro("\\Dagger", "\\ddagger");
        defineMacro("\\diamonds", "\\diamondsuit");
        defineMacro("\\empty", "\\emptyset");
        defineMacro("\\Epsilon", "\\mathrm{E}");
        defineMacro("\\Eta", "\\mathrm{H}");
        defineMacro("\\exist", "\\exists");
        defineMacro("\\harr", "\\leftrightarrow");
        defineMacro("\\hArr", "\\Leftrightarrow");
        defineMacro("\\Harr", "\\Leftrightarrow");
        defineMacro("\\hearts", "\\heartsuit");
        defineMacro("\\image", "\\Im");
        defineMacro("\\infin", "\\infty");
        defineMacro("\\Iota", "\\mathrm{I}");
        defineMacro("\\isin", "\\in");
        defineMacro("\\Kappa", "\\mathrm{K}");
        defineMacro("\\larr", "\\leftarrow");
        defineMacro("\\lArr", "\\Leftarrow");
        defineMacro("\\Larr", "\\Leftarrow");
        defineMacro("\\lrarr", "\\leftrightarrow");
        defineMacro("\\lrArr", "\\Leftrightarrow");
        defineMacro("\\Lrarr", "\\Leftrightarrow");
        defineMacro("\\Mu", "\\mathrm{M}");
        defineMacro("\\natnums", "\\mathbb{N}");
        defineMacro("\\Nu", "\\mathrm{N}");
        defineMacro("\\Omicron", "\\mathrm{O}");
        defineMacro("\\plusmn", "\\pm");
        defineMacro("\\rarr", "\\rightarrow");
        defineMacro("\\rArr", "\\Rightarrow");
        defineMacro("\\Rarr", "\\Rightarrow");
        defineMacro("\\real", "\\Re");
        defineMacro("\\reals", "\\mathbb{R}");
        defineMacro("\\Reals", "\\mathbb{R}");
        defineMacro("\\Rho", "\\mathrm{P}");
        defineMacro("\\sdot", "\\cdot");
        defineMacro("\\sect", "\\S");
        defineMacro("\\spades", "\\spadesuit");
        defineMacro("\\sub", "\\subset");
        defineMacro("\\sube", "\\subseteq");
        defineMacro("\\supe", "\\supseteq");
        defineMacro("\\Tau", "\\mathrm{T}");
        defineMacro("\\thetasym", "\\vartheta");
        defineMacro("\\weierp", "\\wp");
        defineMacro("\\Zeta", "\\mathrm{Z}");
        defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
        defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
        defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
        defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
        defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
        defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
        defineMacro("\\Bra", "\\left\\langle#1\\right|");
        defineMacro("\\Ket", "\\left|#1\\right\\rangle");
        defineMacro("\\angln", "{\\angl n}");
        defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
        defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
        defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
        defineMacro("\\red", "\\textcolor{##df0030}{#1}");
        defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
        defineMacro("\\gray", "\\textcolor{gray}{#1}");
        defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
        defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
        defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
        defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
        defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
        defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
        defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
        defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
        defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
        defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
        defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
        defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
        defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
        defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
        defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
        defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
        defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
        defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
        defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
        defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
        defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
        defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
        defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
        defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
        defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
        defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
        defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
        defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
        defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
        defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
        defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
        defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
        defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
        defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
        defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
        defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
        defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
        defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
        defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
        defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
        defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
        defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
        defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
        defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
        defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
        defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
        defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
        defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
        defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
        defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
        ;
        var operatorname_htmlBuilder = function htmlBuilder2(grp, options) {
          var supGroup;
          var subGroup;
          var hasLimits = false;
          var group;
          if (grp.type === "supsub") {
            supGroup = grp.sup;
            subGroup = grp.sub;
            group = assertNodeType(grp.base, "operatorname");
            hasLimits = true;
          } else {
            group = assertNodeType(grp, "operatorname");
          }
          var base2;
          if (group.body.length > 0) {
            var body = group.body.map(function(child2) {
              var childText = child2.text;
              if (typeof childText === "string") {
                return {
                  type: "textord",
                  mode: child2.mode,
                  text: childText
                };
              } else {
                return child2;
              }
            });
            var expression = buildExpression(body, options.withFont("mathrm"), true);
            for (var i2 = 0; i2 < expression.length; i2++) {
              var child = expression[i2];
              if (child instanceof SymbolNode) {
                child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
              }
            }
            base2 = buildCommon.makeSpan(["mop"], expression, options);
          } else {
            base2 = buildCommon.makeSpan(["mop"], [], options);
          }
          if (hasLimits) {
            return assembleSupSub(base2, supGroup, subGroup, options, options.style, 0, 0);
          } else {
            return base2;
          }
        };
        var operatorname_mathmlBuilder = function mathmlBuilder2(group, options) {
          var expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
          var isAllString = true;
          for (var i2 = 0; i2 < expression.length; i2++) {
            var node = expression[i2];
            if (node instanceof mathMLTree.SpaceNode) {
            } else if (node instanceof mathMLTree.MathNode) {
              switch (node.type) {
                case "mi":
                case "mn":
                case "ms":
                case "mspace":
                case "mtext":
                  break;
                case "mo": {
                  var child = node.children[0];
                  if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                    child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                  } else {
                    isAllString = false;
                  }
                  break;
                }
                default:
                  isAllString = false;
              }
            } else {
              isAllString = false;
            }
          }
          if (isAllString) {
            var word = expression.map(function(node2) {
              return node2.toText();
            }).join("");
            expression = [new mathMLTree.TextNode(word)];
          }
          var identifier = new mathMLTree.MathNode("mi", expression);
          identifier.setAttribute("mathvariant", "normal");
          var operator2 = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
          if (group.parentIsSupSub) {
            return new mathMLTree.MathNode("mrow", [identifier, operator2]);
          } else {
            return mathMLTree.newDocumentFragment([identifier, operator2]);
          }
        };
        defineFunction({
          type: "operatorname",
          names: ["\\operatorname@", "\\operatornamewithlimits"],
          props: {
            numArgs: 1
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            var body = args[0];
            return {
              type: "operatorname",
              mode: parser2.mode,
              body: ordargument(body),
              alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
              limits: false,
              parentIsSupSub: false
            };
          },
          htmlBuilder: operatorname_htmlBuilder,
          mathmlBuilder: operatorname_mathmlBuilder
        });
        defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
        ;
        defineFunctionBuilders({
          type: "ordgroup",
          htmlBuilder: function htmlBuilder2(group, options) {
            if (group.semisimple) {
              return buildCommon.makeFragment(buildExpression(group.body, options, false));
            }
            return buildCommon.makeSpan(["mord"], buildExpression(group.body, options, true), options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            return buildExpressionRow(group.body, options, true);
          }
        });
        ;
        defineFunction({
          type: "overline",
          names: ["\\overline"],
          props: {
            numArgs: 1
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser;
            var body = args[0];
            return {
              type: "overline",
              mode: parser2.mode,
              body
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var innerGroup = buildGroup(group.body, options.havingCrampedStyle());
            var line = buildCommon.makeLineSpan("overline-line", options);
            var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
            var vlist = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: innerGroup
              }, {
                type: "kern",
                size: 3 * defaultRuleThickness
              }, {
                type: "elem",
                elem: line
              }, {
                type: "kern",
                size: defaultRuleThickness
              }]
            }, options);
            return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var operator2 = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
            operator2.setAttribute("stretchy", "true");
            var node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator2]);
            node.setAttribute("accent", "true");
            return node;
          }
        });
        ;
        defineFunction({
          type: "phantom",
          names: ["\\phantom"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser;
            var body = args[0];
            return {
              type: "phantom",
              mode: parser2.mode,
              body: ordargument(body)
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var elements = buildExpression(group.body, options.withPhantom(), false);
            return buildCommon.makeFragment(elements);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var inner2 = buildMathML_buildExpression(group.body, options);
            return new mathMLTree.MathNode("mphantom", inner2);
          }
        });
        defineFunction({
          type: "hphantom",
          names: ["\\hphantom"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: function handler(_ref2, args) {
            var parser2 = _ref2.parser;
            var body = args[0];
            return {
              type: "hphantom",
              mode: parser2.mode,
              body
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var node = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
            node.height = 0;
            node.depth = 0;
            if (node.children) {
              for (var i2 = 0; i2 < node.children.length; i2++) {
                node.children[i2].height = 0;
                node.children[i2].depth = 0;
              }
            }
            node = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: node
              }]
            }, options);
            return buildCommon.makeSpan(["mord"], [node], options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var inner2 = buildMathML_buildExpression(ordargument(group.body), options);
            var phantom = new mathMLTree.MathNode("mphantom", inner2);
            var node = new mathMLTree.MathNode("mpadded", [phantom]);
            node.setAttribute("height", "0px");
            node.setAttribute("depth", "0px");
            return node;
          }
        });
        defineFunction({
          type: "vphantom",
          names: ["\\vphantom"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: function handler(_ref3, args) {
            var parser2 = _ref3.parser;
            var body = args[0];
            return {
              type: "vphantom",
              mode: parser2.mode,
              body
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
            var fix = buildCommon.makeSpan(["fix"], []);
            return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var inner2 = buildMathML_buildExpression(ordargument(group.body), options);
            var phantom = new mathMLTree.MathNode("mphantom", inner2);
            var node = new mathMLTree.MathNode("mpadded", [phantom]);
            node.setAttribute("width", "0px");
            return node;
          }
        });
        ;
        defineFunction({
          type: "raisebox",
          names: ["\\raisebox"],
          props: {
            numArgs: 2,
            argTypes: ["size", "hbox"],
            allowedInText: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser;
            var amount = assertNodeType(args[0], "size").value;
            var body = args[1];
            return {
              type: "raisebox",
              mode: parser2.mode,
              dy: amount,
              body
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var body = buildGroup(group.body, options);
            var dy = calculateSize(group.dy, options);
            return buildCommon.makeVList({
              positionType: "shift",
              positionData: -dy,
              children: [{
                type: "elem",
                elem: body
              }]
            }, options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
            var dy = group.dy.number + group.dy.unit;
            node.setAttribute("voffset", dy);
            return node;
          }
        });
        ;
        defineFunction({
          type: "rule",
          names: ["\\rule"],
          props: {
            numArgs: 2,
            numOptionalArgs: 1,
            argTypes: ["size", "size", "size"]
          },
          handler: function handler(_ref, args, optArgs) {
            var parser2 = _ref.parser;
            var shift2 = optArgs[0];
            var width = assertNodeType(args[0], "size");
            var height = assertNodeType(args[1], "size");
            return {
              type: "rule",
              mode: parser2.mode,
              shift: shift2 && assertNodeType(shift2, "size").value,
              width: width.value,
              height: height.value
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
            var width = calculateSize(group.width, options);
            var height = calculateSize(group.height, options);
            var shift2 = group.shift ? calculateSize(group.shift, options) : 0;
            rule.style.borderRightWidth = width + "em";
            rule.style.borderTopWidth = height + "em";
            rule.style.bottom = shift2 + "em";
            rule.width = width;
            rule.height = height + shift2;
            rule.depth = -shift2;
            rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
            return rule;
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var width = calculateSize(group.width, options);
            var height = calculateSize(group.height, options);
            var shift2 = group.shift ? calculateSize(group.shift, options) : 0;
            var color = options.color && options.getColor() || "black";
            var rule = new mathMLTree.MathNode("mspace");
            rule.setAttribute("mathbackground", color);
            rule.setAttribute("width", width + "em");
            rule.setAttribute("height", height + "em");
            var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
            if (shift2 >= 0) {
              wrapper.setAttribute("height", "+" + shift2 + "em");
            } else {
              wrapper.setAttribute("height", shift2 + "em");
              wrapper.setAttribute("depth", "+" + -shift2 + "em");
            }
            wrapper.setAttribute("voffset", shift2 + "em");
            return wrapper;
          }
        });
        ;
        function sizingGroup(value, options, baseOptions) {
          var inner2 = buildExpression(value, options, false);
          var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
          for (var i2 = 0; i2 < inner2.length; i2++) {
            var pos = inner2[i2].classes.indexOf("sizing");
            if (pos < 0) {
              Array.prototype.push.apply(inner2[i2].classes, options.sizingClasses(baseOptions));
            } else if (inner2[i2].classes[pos + 1] === "reset-size" + options.size) {
              inner2[i2].classes[pos + 1] = "reset-size" + baseOptions.size;
            }
            inner2[i2].height *= multiplier;
            inner2[i2].depth *= multiplier;
          }
          return buildCommon.makeFragment(inner2);
        }
        var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
        var sizing_htmlBuilder = function htmlBuilder2(group, options) {
          var newOptions = options.havingSize(group.size);
          return sizingGroup(group.body, newOptions, options);
        };
        defineFunction({
          type: "sizing",
          names: sizeFuncs,
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler: function handler(_ref, args) {
            var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser2 = _ref.parser;
            var body = parser2.parseExpression(false, breakOnTokenText);
            return {
              type: "sizing",
              mode: parser2.mode,
              size: sizeFuncs.indexOf(funcName) + 1,
              body
            };
          },
          htmlBuilder: sizing_htmlBuilder,
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var newOptions = options.havingSize(group.size);
            var inner2 = buildMathML_buildExpression(group.body, newOptions);
            var node = new mathMLTree.MathNode("mstyle", inner2);
            node.setAttribute("mathsize", newOptions.sizeMultiplier + "em");
            return node;
          }
        });
        ;
        defineFunction({
          type: "smash",
          names: ["\\smash"],
          props: {
            numArgs: 1,
            numOptionalArgs: 1,
            allowedInText: true
          },
          handler: function handler(_ref, args, optArgs) {
            var parser2 = _ref.parser;
            var smashHeight = false;
            var smashDepth = false;
            var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
            if (tbArg) {
              var letter = "";
              for (var i2 = 0; i2 < tbArg.body.length; ++i2) {
                var node = tbArg.body[i2];
                letter = node.text;
                if (letter === "t") {
                  smashHeight = true;
                } else if (letter === "b") {
                  smashDepth = true;
                } else {
                  smashHeight = false;
                  smashDepth = false;
                  break;
                }
              }
            } else {
              smashHeight = true;
              smashDepth = true;
            }
            var body = args[0];
            return {
              type: "smash",
              mode: parser2.mode,
              body,
              smashHeight,
              smashDepth
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var node = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
            if (!group.smashHeight && !group.smashDepth) {
              return node;
            }
            if (group.smashHeight) {
              node.height = 0;
              if (node.children) {
                for (var i2 = 0; i2 < node.children.length; i2++) {
                  node.children[i2].height = 0;
                }
              }
            }
            if (group.smashDepth) {
              node.depth = 0;
              if (node.children) {
                for (var _i6 = 0; _i6 < node.children.length; _i6++) {
                  node.children[_i6].depth = 0;
                }
              }
            }
            var smashedNode = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: node
              }]
            }, options);
            return buildCommon.makeSpan(["mord"], [smashedNode], options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
            if (group.smashHeight) {
              node.setAttribute("height", "0px");
            }
            if (group.smashDepth) {
              node.setAttribute("depth", "0px");
            }
            return node;
          }
        });
        ;
        defineFunction({
          type: "sqrt",
          names: ["\\sqrt"],
          props: {
            numArgs: 1,
            numOptionalArgs: 1
          },
          handler: function handler(_ref, args, optArgs) {
            var parser2 = _ref.parser;
            var index = optArgs[0];
            var body = args[0];
            return {
              type: "sqrt",
              mode: parser2.mode,
              body,
              index
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var inner2 = buildGroup(group.body, options.havingCrampedStyle());
            if (inner2.height === 0) {
              inner2.height = options.fontMetrics().xHeight;
            }
            inner2 = buildCommon.wrapFragment(inner2, options);
            var metrics = options.fontMetrics();
            var theta = metrics.defaultRuleThickness;
            var phi = theta;
            if (options.style.id < src_Style.TEXT.id) {
              phi = options.fontMetrics().xHeight;
            }
            var lineClearance = theta + phi / 4;
            var minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
            var _delimiter$sqrtImage = delimiter.sqrtImage(minDelimiterHeight, options), img = _delimiter$sqrtImage.span, ruleWidth = _delimiter$sqrtImage.ruleWidth, advanceWidth = _delimiter$sqrtImage.advanceWidth;
            var delimDepth = img.height - ruleWidth;
            if (delimDepth > inner2.height + inner2.depth + lineClearance) {
              lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
            }
            var imgShift = img.height - inner2.height - lineClearance - ruleWidth;
            inner2.style.paddingLeft = advanceWidth + "em";
            var body = buildCommon.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: inner2,
                wrapperClasses: ["svg-align"]
              }, {
                type: "kern",
                size: -(inner2.height + imgShift)
              }, {
                type: "elem",
                elem: img
              }, {
                type: "kern",
                size: ruleWidth
              }]
            }, options);
            if (!group.index) {
              return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
            } else {
              var newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
              var rootm = buildGroup(group.index, newOptions, options);
              var toShift = 0.6 * (body.height - body.depth);
              var rootVList = buildCommon.makeVList({
                positionType: "shift",
                positionData: -toShift,
                children: [{
                  type: "elem",
                  elem: rootm
                }]
              }, options);
              var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
              return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
            }
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var body = group.body, index = group.index;
            return index ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
          }
        });
        ;
        var styling_styleMap = {
          "display": src_Style.DISPLAY,
          "text": src_Style.TEXT,
          "script": src_Style.SCRIPT,
          "scriptscript": src_Style.SCRIPTSCRIPT
        };
        defineFunction({
          type: "styling",
          names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
          props: {
            numArgs: 0,
            allowedInText: true,
            primitive: true
          },
          handler: function handler(_ref, args) {
            var breakOnTokenText = _ref.breakOnTokenText, funcName = _ref.funcName, parser2 = _ref.parser;
            var body = parser2.parseExpression(true, breakOnTokenText);
            var style = funcName.slice(1, funcName.length - 5);
            return {
              type: "styling",
              mode: parser2.mode,
              style,
              body
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var newStyle = styling_styleMap[group.style];
            var newOptions = options.havingStyle(newStyle).withFont("");
            return sizingGroup(group.body, newOptions, options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var newStyle = styling_styleMap[group.style];
            var newOptions = options.havingStyle(newStyle);
            var inner2 = buildMathML_buildExpression(group.body, newOptions);
            var node = new mathMLTree.MathNode("mstyle", inner2);
            var styleAttributes = {
              "display": ["0", "true"],
              "text": ["0", "false"],
              "script": ["1", "false"],
              "scriptscript": ["2", "false"]
            };
            var attr = styleAttributes[group.style];
            node.setAttribute("scriptlevel", attr[0]);
            node.setAttribute("displaystyle", attr[1]);
            return node;
          }
        });
        ;
        var htmlBuilderDelegate = function htmlBuilderDelegate2(group, options) {
          var base2 = group.base;
          if (!base2) {
            return null;
          } else if (base2.type === "op") {
            var delegate = base2.limits && (options.style.size === src_Style.DISPLAY.size || base2.alwaysHandleSupSub);
            return delegate ? op_htmlBuilder : null;
          } else if (base2.type === "operatorname") {
            var _delegate = base2.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base2.limits);
            return _delegate ? operatorname_htmlBuilder : null;
          } else if (base2.type === "accent") {
            return utils.isCharacterBox(base2.base) ? htmlBuilder : null;
          } else if (base2.type === "horizBrace") {
            var isSup = !group.sub;
            return isSup === base2.isOver ? horizBrace_htmlBuilder : null;
          } else {
            return null;
          }
        };
        defineFunctionBuilders({
          type: "supsub",
          htmlBuilder: function htmlBuilder2(group, options) {
            var builderDelegate = htmlBuilderDelegate(group, options);
            if (builderDelegate) {
              return builderDelegate(group, options);
            }
            var valueBase = group.base, valueSup = group.sup, valueSub = group.sub;
            var base2 = buildGroup(valueBase, options);
            var supm;
            var subm;
            var metrics = options.fontMetrics();
            var supShift = 0;
            var subShift = 0;
            var isCharacterBox2 = valueBase && utils.isCharacterBox(valueBase);
            if (valueSup) {
              var newOptions = options.havingStyle(options.style.sup());
              supm = buildGroup(valueSup, newOptions, options);
              if (!isCharacterBox2) {
                supShift = base2.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
              }
            }
            if (valueSub) {
              var _newOptions = options.havingStyle(options.style.sub());
              subm = buildGroup(valueSub, _newOptions, options);
              if (!isCharacterBox2) {
                subShift = base2.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
              }
            }
            var minSupShift;
            if (options.style === src_Style.DISPLAY) {
              minSupShift = metrics.sup1;
            } else if (options.style.cramped) {
              minSupShift = metrics.sup3;
            } else {
              minSupShift = metrics.sup2;
            }
            var multiplier = options.sizeMultiplier;
            var marginRight = 0.5 / metrics.ptPerEm / multiplier + "em";
            var marginLeft = null;
            if (subm) {
              var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
              if (base2 instanceof SymbolNode || isOiint) {
                marginLeft = -base2.italic + "em";
              }
            }
            var supsub;
            if (supm && subm) {
              supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
              subShift = Math.max(subShift, metrics.sub2);
              var ruleWidth = metrics.defaultRuleThickness;
              var maxWidth = 4 * ruleWidth;
              if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
                subShift = maxWidth - (supShift - supm.depth) + subm.height;
                var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
                if (psi > 0) {
                  supShift += psi;
                  subShift -= psi;
                }
              }
              var vlistElem = [{
                type: "elem",
                elem: subm,
                shift: subShift,
                marginRight,
                marginLeft
              }, {
                type: "elem",
                elem: supm,
                shift: -supShift,
                marginRight
              }];
              supsub = buildCommon.makeVList({
                positionType: "individualShift",
                children: vlistElem
              }, options);
            } else if (subm) {
              subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
              var _vlistElem = [{
                type: "elem",
                elem: subm,
                marginLeft,
                marginRight
              }];
              supsub = buildCommon.makeVList({
                positionType: "shift",
                positionData: subShift,
                children: _vlistElem
              }, options);
            } else if (supm) {
              supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
              supsub = buildCommon.makeVList({
                positionType: "shift",
                positionData: -supShift,
                children: [{
                  type: "elem",
                  elem: supm,
                  marginRight
                }]
              }, options);
            } else {
              throw new Error("supsub must have either sup or sub.");
            }
            var mclass = getTypeOfDomTree(base2, "right") || "mord";
            return buildCommon.makeSpan([mclass], [base2, buildCommon.makeSpan(["msupsub"], [supsub])], options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var isBrace = false;
            var isOver;
            var isSup;
            if (group.base && group.base.type === "horizBrace") {
              isSup = !!group.sup;
              if (isSup === group.base.isOver) {
                isBrace = true;
                isOver = group.base.isOver;
              }
            }
            if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
              group.base.parentIsSupSub = true;
            }
            var children = [buildMathML_buildGroup(group.base, options)];
            if (group.sub) {
              children.push(buildMathML_buildGroup(group.sub, options));
            }
            if (group.sup) {
              children.push(buildMathML_buildGroup(group.sup, options));
            }
            var nodeType;
            if (isBrace) {
              nodeType = isOver ? "mover" : "munder";
            } else if (!group.sub) {
              var base2 = group.base;
              if (base2 && base2.type === "op" && base2.limits && (options.style === src_Style.DISPLAY || base2.alwaysHandleSupSub)) {
                nodeType = "mover";
              } else if (base2 && base2.type === "operatorname" && base2.alwaysHandleSupSub && (base2.limits || options.style === src_Style.DISPLAY)) {
                nodeType = "mover";
              } else {
                nodeType = "msup";
              }
            } else if (!group.sup) {
              var _base = group.base;
              if (_base && _base.type === "op" && _base.limits && (options.style === src_Style.DISPLAY || _base.alwaysHandleSupSub)) {
                nodeType = "munder";
              } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === src_Style.DISPLAY)) {
                nodeType = "munder";
              } else {
                nodeType = "msub";
              }
            } else {
              var _base2 = group.base;
              if (_base2 && _base2.type === "op" && _base2.limits && options.style === src_Style.DISPLAY) {
                nodeType = "munderover";
              } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || _base2.limits)) {
                nodeType = "munderover";
              } else {
                nodeType = "msubsup";
              }
            }
            return new mathMLTree.MathNode(nodeType, children);
          }
        });
        ;
        defineFunctionBuilders({
          type: "atom",
          htmlBuilder: function htmlBuilder2(group, options) {
            return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
            if (group.family === "bin") {
              var variant = getVariant(group, options);
              if (variant === "bold-italic") {
                node.setAttribute("mathvariant", variant);
              }
            } else if (group.family === "punct") {
              node.setAttribute("separator", "true");
            } else if (group.family === "open" || group.family === "close") {
              node.setAttribute("stretchy", "false");
            }
            return node;
          }
        });
        ;
        var defaultVariant = {
          "mi": "italic",
          "mn": "normal",
          "mtext": "normal"
        };
        defineFunctionBuilders({
          type: "mathord",
          htmlBuilder: function htmlBuilder2(group, options) {
            return buildCommon.makeOrd(group, options, "mathord");
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
            var variant = getVariant(group, options) || "italic";
            if (variant !== defaultVariant[node.type]) {
              node.setAttribute("mathvariant", variant);
            }
            return node;
          }
        });
        defineFunctionBuilders({
          type: "textord",
          htmlBuilder: function htmlBuilder2(group, options) {
            return buildCommon.makeOrd(group, options, "textord");
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var text = makeText(group.text, group.mode, options);
            var variant = getVariant(group, options) || "normal";
            var node;
            if (group.mode === "text") {
              node = new mathMLTree.MathNode("mtext", [text]);
            } else if (/[0-9]/.test(group.text)) {
              node = new mathMLTree.MathNode("mn", [text]);
            } else if (group.text === "\\prime") {
              node = new mathMLTree.MathNode("mo", [text]);
            } else {
              node = new mathMLTree.MathNode("mi", [text]);
            }
            if (variant !== defaultVariant[node.type]) {
              node.setAttribute("mathvariant", variant);
            }
            return node;
          }
        });
        ;
        var cssSpace = {
          "\\nobreak": "nobreak",
          "\\allowbreak": "allowbreak"
        };
        var regularSpace = {
          " ": {},
          "\\ ": {},
          "~": {
            className: "nobreak"
          },
          "\\space": {},
          "\\nobreakspace": {
            className: "nobreak"
          }
        };
        defineFunctionBuilders({
          type: "spacing",
          htmlBuilder: function htmlBuilder2(group, options) {
            if (regularSpace.hasOwnProperty(group.text)) {
              var className = regularSpace[group.text].className || "";
              if (group.mode === "text") {
                var ord = buildCommon.makeOrd(group, options, "textord");
                ord.classes.push(className);
                return ord;
              } else {
                return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
              }
            } else if (cssSpace.hasOwnProperty(group.text)) {
              return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
            } else {
              throw new src_ParseError('Unknown type of space "' + group.text + '"');
            }
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var node;
            if (regularSpace.hasOwnProperty(group.text)) {
              node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\xA0")]);
            } else if (cssSpace.hasOwnProperty(group.text)) {
              return new mathMLTree.MathNode("mspace");
            } else {
              throw new src_ParseError('Unknown type of space "' + group.text + '"');
            }
            return node;
          }
        });
        ;
        var pad = function pad2() {
          var padNode = new mathMLTree.MathNode("mtd", []);
          padNode.setAttribute("width", "50%");
          return padNode;
        };
        defineFunctionBuilders({
          type: "tag",
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
            table.setAttribute("width", "100%");
            return table;
          }
        });
        ;
        var textFontFamilies = {
          "\\text": void 0,
          "\\textrm": "textrm",
          "\\textsf": "textsf",
          "\\texttt": "texttt",
          "\\textnormal": "textrm"
        };
        var textFontWeights = {
          "\\textbf": "textbf",
          "\\textmd": "textmd"
        };
        var textFontShapes = {
          "\\textit": "textit",
          "\\textup": "textup"
        };
        var optionsWithFont = function optionsWithFont2(group, options) {
          var font = group.font;
          if (!font) {
            return options;
          } else if (textFontFamilies[font]) {
            return options.withTextFontFamily(textFontFamilies[font]);
          } else if (textFontWeights[font]) {
            return options.withTextFontWeight(textFontWeights[font]);
          } else {
            return options.withTextFontShape(textFontShapes[font]);
          }
        };
        defineFunction({
          type: "text",
          names: [
            "\\text",
            "\\textrm",
            "\\textsf",
            "\\texttt",
            "\\textnormal",
            "\\textbf",
            "\\textmd",
            "\\textit",
            "\\textup"
          ],
          props: {
            numArgs: 1,
            argTypes: ["text"],
            allowedInArgument: true,
            allowedInText: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser, funcName = _ref.funcName;
            var body = args[0];
            return {
              type: "text",
              mode: parser2.mode,
              body: ordargument(body),
              font: funcName
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var newOptions = optionsWithFont(group, options);
            var inner2 = buildExpression(group.body, newOptions, true);
            return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var newOptions = optionsWithFont(group, options);
            return buildExpressionRow(group.body, newOptions);
          }
        });
        ;
        defineFunction({
          type: "underline",
          names: ["\\underline"],
          props: {
            numArgs: 1,
            allowedInText: true
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser;
            return {
              type: "underline",
              mode: parser2.mode,
              body: args[0]
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var innerGroup = buildGroup(group.body, options);
            var line = buildCommon.makeLineSpan("underline-line", options);
            var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
            var vlist = buildCommon.makeVList({
              positionType: "top",
              positionData: innerGroup.height,
              children: [{
                type: "kern",
                size: defaultRuleThickness
              }, {
                type: "elem",
                elem: line
              }, {
                type: "kern",
                size: 3 * defaultRuleThickness
              }, {
                type: "elem",
                elem: innerGroup
              }]
            }, options);
            return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var operator2 = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("\u203E")]);
            operator2.setAttribute("stretchy", "true");
            var node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator2]);
            node.setAttribute("accentunder", "true");
            return node;
          }
        });
        ;
        defineFunction({
          type: "vcenter",
          names: ["\\vcenter"],
          props: {
            numArgs: 1,
            argTypes: ["original"],
            allowedInText: false
          },
          handler: function handler(_ref, args) {
            var parser2 = _ref.parser;
            return {
              type: "vcenter",
              mode: parser2.mode,
              body: args[0]
            };
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var body = buildGroup(group.body, options);
            var axisHeight = options.fontMetrics().axisHeight;
            var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
            return buildCommon.makeVList({
              positionType: "shift",
              positionData: dy,
              children: [{
                type: "elem",
                elem: body
              }]
            }, options);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            return new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)], ["vcenter"]);
          }
        });
        ;
        defineFunction({
          type: "verb",
          names: ["\\verb"],
          props: {
            numArgs: 0,
            allowedInText: true
          },
          handler: function handler(context, args, optArgs) {
            throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
          },
          htmlBuilder: function htmlBuilder2(group, options) {
            var text = makeVerb(group);
            var body = [];
            var newOptions = options.havingStyle(options.style.text());
            for (var i2 = 0; i2 < text.length; i2++) {
              var c = text[i2];
              if (c === "~") {
                c = "\\textasciitilde";
              }
              body.push(buildCommon.makeSymbol(c, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
            }
            return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
          },
          mathmlBuilder: function mathmlBuilder2(group, options) {
            var text = new mathMLTree.TextNode(makeVerb(group));
            var node = new mathMLTree.MathNode("mtext", [text]);
            node.setAttribute("mathvariant", "monospace");
            return node;
          }
        });
        var makeVerb = function makeVerb2(group) {
          return group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");
        };
        ;
        var functions = _functions;
        var src_functions = functions;
        ;
        var SourceLocation = /* @__PURE__ */ function() {
          function SourceLocation2(lexer, start2, end) {
            this.lexer = void 0;
            this.start = void 0;
            this.end = void 0;
            this.lexer = lexer;
            this.start = start2;
            this.end = end;
          }
          SourceLocation2.range = function range(first, second) {
            if (!second) {
              return first && first.loc;
            } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
              return null;
            } else {
              return new SourceLocation2(first.loc.lexer, first.loc.start, second.loc.end);
            }
          };
          return SourceLocation2;
        }();
        ;
        var Token2 = /* @__PURE__ */ function() {
          function Token3(text, loc) {
            this.text = void 0;
            this.loc = void 0;
            this.noexpand = void 0;
            this.treatAsRelax = void 0;
            this.text = text;
            this.loc = loc;
          }
          var _proto = Token3.prototype;
          _proto.range = function range(endToken, text) {
            return new Token3(text, SourceLocation.range(this, endToken));
          };
          return Token3;
        }();
        ;
        var spaceRegexString = "[ \r\n	]";
        var controlWordRegexString = "\\\\[a-zA-Z@]+";
        var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
        var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
        var controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
        var combiningDiacriticalMarkString = "[\u0300-\u036F]";
        var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
        var tokenRegexString = "(" + spaceRegexString + "+)|" + (controlSpaceRegexString + "|") + "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + (combiningDiacriticalMarkString + "*") + "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + (combiningDiacriticalMarkString + "*") + "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + ("|" + controlWordWhitespaceRegexString) + ("|" + controlSymbolRegexString + ")");
        var Lexer = /* @__PURE__ */ function() {
          function Lexer2(input, settings) {
            this.input = void 0;
            this.settings = void 0;
            this.tokenRegex = void 0;
            this.catcodes = void 0;
            this.input = input;
            this.settings = settings;
            this.tokenRegex = new RegExp(tokenRegexString, "g");
            this.catcodes = {
              "%": 14,
              "~": 13
            };
          }
          var _proto = Lexer2.prototype;
          _proto.setCatcode = function setCatcode(char, code) {
            this.catcodes[char] = code;
          };
          _proto.lex = function lex() {
            var input = this.input;
            var pos = this.tokenRegex.lastIndex;
            if (pos === input.length) {
              return new Token2("EOF", new SourceLocation(this, pos, pos));
            }
            var match = this.tokenRegex.exec(input);
            if (match === null || match.index !== pos) {
              throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token2(input[pos], new SourceLocation(this, pos, pos + 1)));
            }
            var text = match[6] || match[3] || (match[2] ? "\\ " : " ");
            if (this.catcodes[text] === 14) {
              var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
              if (nlIndex === -1) {
                this.tokenRegex.lastIndex = input.length;
                this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
              } else {
                this.tokenRegex.lastIndex = nlIndex + 1;
              }
              return this.lex();
            }
            return new Token2(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
          };
          return Lexer2;
        }();
        ;
        var Namespace = /* @__PURE__ */ function() {
          function Namespace2(builtins, globalMacros) {
            if (builtins === void 0) {
              builtins = {};
            }
            if (globalMacros === void 0) {
              globalMacros = {};
            }
            this.current = void 0;
            this.builtins = void 0;
            this.undefStack = void 0;
            this.current = globalMacros;
            this.builtins = builtins;
            this.undefStack = [];
          }
          var _proto = Namespace2.prototype;
          _proto.beginGroup = function beginGroup() {
            this.undefStack.push({});
          };
          _proto.endGroup = function endGroup() {
            if (this.undefStack.length === 0) {
              throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
            }
            var undefs = this.undefStack.pop();
            for (var undef in undefs) {
              if (undefs.hasOwnProperty(undef)) {
                if (undefs[undef] === void 0) {
                  delete this.current[undef];
                } else {
                  this.current[undef] = undefs[undef];
                }
              }
            }
          };
          _proto.has = function has(name2) {
            return this.current.hasOwnProperty(name2) || this.builtins.hasOwnProperty(name2);
          };
          _proto.get = function get(name2) {
            if (this.current.hasOwnProperty(name2)) {
              return this.current[name2];
            } else {
              return this.builtins[name2];
            }
          };
          _proto.set = function set(name2, value, global2) {
            if (global2 === void 0) {
              global2 = false;
            }
            if (global2) {
              for (var i2 = 0; i2 < this.undefStack.length; i2++) {
                delete this.undefStack[i2][name2];
              }
              if (this.undefStack.length > 0) {
                this.undefStack[this.undefStack.length - 1][name2] = value;
              }
            } else {
              var top2 = this.undefStack[this.undefStack.length - 1];
              if (top2 && !top2.hasOwnProperty(name2)) {
                top2[name2] = this.current[name2];
              }
            }
            this.current[name2] = value;
          };
          return Namespace2;
        }();
        ;
        var implicitCommands = {
          "\\relax": true,
          "^": true,
          "_": true,
          "\\limits": true,
          "\\nolimits": true
        };
        var MacroExpander = /* @__PURE__ */ function() {
          function MacroExpander2(input, settings, mode) {
            this.settings = void 0;
            this.expansionCount = void 0;
            this.lexer = void 0;
            this.macros = void 0;
            this.stack = void 0;
            this.mode = void 0;
            this.settings = settings;
            this.expansionCount = 0;
            this.feed(input);
            this.macros = new Namespace(macros, settings.macros);
            this.mode = mode;
            this.stack = [];
          }
          var _proto = MacroExpander2.prototype;
          _proto.feed = function feed(input) {
            this.lexer = new Lexer(input, this.settings);
          };
          _proto.switchMode = function switchMode(newMode) {
            this.mode = newMode;
          };
          _proto.beginGroup = function beginGroup() {
            this.macros.beginGroup();
          };
          _proto.endGroup = function endGroup() {
            this.macros.endGroup();
          };
          _proto.future = function future() {
            if (this.stack.length === 0) {
              this.pushToken(this.lexer.lex());
            }
            return this.stack[this.stack.length - 1];
          };
          _proto.popToken = function popToken() {
            this.future();
            return this.stack.pop();
          };
          _proto.pushToken = function pushToken(token) {
            this.stack.push(token);
          };
          _proto.pushTokens = function pushTokens(tokens) {
            var _this$stack;
            (_this$stack = this.stack).push.apply(_this$stack, tokens);
          };
          _proto.scanArgument = function scanArgument(isOptional) {
            var start2;
            var end;
            var tokens;
            if (isOptional) {
              this.consumeSpaces();
              if (this.future().text !== "[") {
                return null;
              }
              start2 = this.popToken();
              var _this$consumeArg = this.consumeArg(["]"]);
              tokens = _this$consumeArg.tokens;
              end = _this$consumeArg.end;
            } else {
              var _this$consumeArg2 = this.consumeArg();
              tokens = _this$consumeArg2.tokens;
              start2 = _this$consumeArg2.start;
              end = _this$consumeArg2.end;
            }
            this.pushToken(new Token2("EOF", end.loc));
            this.pushTokens(tokens);
            return start2.range(end, "");
          };
          _proto.consumeSpaces = function consumeSpaces() {
            for (; ; ) {
              var token = this.future();
              if (token.text === " ") {
                this.stack.pop();
              } else {
                break;
              }
            }
          };
          _proto.consumeArg = function consumeArg(delims) {
            var tokens = [];
            var isDelimited = delims && delims.length > 0;
            if (!isDelimited) {
              this.consumeSpaces();
            }
            var start2 = this.future();
            var tok;
            var depth = 0;
            var match = 0;
            do {
              tok = this.popToken();
              tokens.push(tok);
              if (tok.text === "{") {
                ++depth;
              } else if (tok.text === "}") {
                --depth;
                if (depth === -1) {
                  throw new src_ParseError("Extra }", tok);
                }
              } else if (tok.text === "EOF") {
                throw new src_ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
              }
              if (delims && isDelimited) {
                if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
                  ++match;
                  if (match === delims.length) {
                    tokens.splice(-match, match);
                    break;
                  }
                } else {
                  match = 0;
                }
              }
            } while (depth !== 0 || isDelimited);
            if (start2.text === "{" && tokens[tokens.length - 1].text === "}") {
              tokens.pop();
              tokens.shift();
            }
            tokens.reverse();
            return {
              tokens,
              start: start2,
              end: tok
            };
          };
          _proto.consumeArgs = function consumeArgs(numArgs, delimiters2) {
            if (delimiters2) {
              if (delimiters2.length !== numArgs + 1) {
                throw new src_ParseError("The length of delimiters doesn't match the number of args!");
              }
              var delims = delimiters2[0];
              for (var i2 = 0; i2 < delims.length; i2++) {
                var tok = this.popToken();
                if (delims[i2] !== tok.text) {
                  throw new src_ParseError("Use of the macro doesn't match its definition", tok);
                }
              }
            }
            var args = [];
            for (var _i6 = 0; _i6 < numArgs; _i6++) {
              args.push(this.consumeArg(delimiters2 && delimiters2[_i6 + 1]).tokens);
            }
            return args;
          };
          _proto.expandOnce = function expandOnce(expandableOnly) {
            var topToken = this.popToken();
            var name2 = topToken.text;
            var expansion = !topToken.noexpand ? this._getExpansion(name2) : null;
            if (expansion == null || expandableOnly && expansion.unexpandable) {
              if (expandableOnly && expansion == null && name2[0] === "\\" && !this.isDefined(name2)) {
                throw new src_ParseError("Undefined control sequence: " + name2);
              }
              this.pushToken(topToken);
              return topToken;
            }
            this.expansionCount++;
            if (this.expansionCount > this.settings.maxExpand) {
              throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
            }
            var tokens = expansion.tokens;
            var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
            if (expansion.numArgs) {
              tokens = tokens.slice();
              for (var i2 = tokens.length - 1; i2 >= 0; --i2) {
                var tok = tokens[i2];
                if (tok.text === "#") {
                  if (i2 === 0) {
                    throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                  }
                  tok = tokens[--i2];
                  if (tok.text === "#") {
                    tokens.splice(i2 + 1, 1);
                  } else if (/^[1-9]$/.test(tok.text)) {
                    var _tokens;
                    (_tokens = tokens).splice.apply(_tokens, [i2, 2].concat(args[+tok.text - 1]));
                  } else {
                    throw new src_ParseError("Not a valid argument number", tok);
                  }
                }
              }
            }
            this.pushTokens(tokens);
            return tokens;
          };
          _proto.expandAfterFuture = function expandAfterFuture() {
            this.expandOnce();
            return this.future();
          };
          _proto.expandNextToken = function expandNextToken() {
            for (; ; ) {
              var expanded = this.expandOnce();
              if (expanded instanceof Token2) {
                if (expanded.text === "\\relax" || expanded.treatAsRelax) {
                  this.stack.pop();
                } else {
                  return this.stack.pop();
                }
              }
            }
            throw new Error();
          };
          _proto.expandMacro = function expandMacro(name2) {
            return this.macros.has(name2) ? this.expandTokens([new Token2(name2)]) : void 0;
          };
          _proto.expandTokens = function expandTokens(tokens) {
            var output = [];
            var oldStackLength = this.stack.length;
            this.pushTokens(tokens);
            while (this.stack.length > oldStackLength) {
              var expanded = this.expandOnce(true);
              if (expanded instanceof Token2) {
                if (expanded.treatAsRelax) {
                  expanded.noexpand = false;
                  expanded.treatAsRelax = false;
                }
                output.push(this.stack.pop());
              }
            }
            return output;
          };
          _proto.expandMacroAsText = function expandMacroAsText(name2) {
            var tokens = this.expandMacro(name2);
            if (tokens) {
              return tokens.map(function(token) {
                return token.text;
              }).join("");
            } else {
              return tokens;
            }
          };
          _proto._getExpansion = function _getExpansion(name2) {
            var definition = this.macros.get(name2);
            if (definition == null) {
              return definition;
            }
            if (name2.length === 1) {
              var catcode = this.lexer.catcodes[name2];
              if (catcode != null && catcode !== 13) {
                return;
              }
            }
            var expansion = typeof definition === "function" ? definition(this) : definition;
            if (typeof expansion === "string") {
              var numArgs = 0;
              if (expansion.indexOf("#") !== -1) {
                var stripped = expansion.replace(/##/g, "");
                while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                  ++numArgs;
                }
              }
              var bodyLexer = new Lexer(expansion, this.settings);
              var tokens = [];
              var tok = bodyLexer.lex();
              while (tok.text !== "EOF") {
                tokens.push(tok);
                tok = bodyLexer.lex();
              }
              tokens.reverse();
              var expanded = {
                tokens,
                numArgs
              };
              return expanded;
            }
            return expansion;
          };
          _proto.isDefined = function isDefined(name2) {
            return this.macros.has(name2) || src_functions.hasOwnProperty(name2) || src_symbols.math.hasOwnProperty(name2) || src_symbols.text.hasOwnProperty(name2) || implicitCommands.hasOwnProperty(name2);
          };
          _proto.isExpandable = function isExpandable(name2) {
            var macro = this.macros.get(name2);
            return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name2) && !src_functions[name2].primitive;
          };
          return MacroExpander2;
        }();
        ;
        var unicodeAccents = {
          "\u0301": {
            "text": "\\'",
            "math": "\\acute"
          },
          "\u0300": {
            "text": "\\`",
            "math": "\\grave"
          },
          "\u0308": {
            "text": '\\"',
            "math": "\\ddot"
          },
          "\u0303": {
            "text": "\\~",
            "math": "\\tilde"
          },
          "\u0304": {
            "text": "\\=",
            "math": "\\bar"
          },
          "\u0306": {
            "text": "\\u",
            "math": "\\breve"
          },
          "\u030C": {
            "text": "\\v",
            "math": "\\check"
          },
          "\u0302": {
            "text": "\\^",
            "math": "\\hat"
          },
          "\u0307": {
            "text": "\\.",
            "math": "\\dot"
          },
          "\u030A": {
            "text": "\\r",
            "math": "\\mathring"
          },
          "\u030B": {
            "text": "\\H"
          }
        };
        var unicodeSymbols = {
          "\xE1": "a\u0301",
          "\xE0": "a\u0300",
          "\xE4": "a\u0308",
          "\u01DF": "a\u0308\u0304",
          "\xE3": "a\u0303",
          "\u0101": "a\u0304",
          "\u0103": "a\u0306",
          "\u1EAF": "a\u0306\u0301",
          "\u1EB1": "a\u0306\u0300",
          "\u1EB5": "a\u0306\u0303",
          "\u01CE": "a\u030C",
          "\xE2": "a\u0302",
          "\u1EA5": "a\u0302\u0301",
          "\u1EA7": "a\u0302\u0300",
          "\u1EAB": "a\u0302\u0303",
          "\u0227": "a\u0307",
          "\u01E1": "a\u0307\u0304",
          "\xE5": "a\u030A",
          "\u01FB": "a\u030A\u0301",
          "\u1E03": "b\u0307",
          "\u0107": "c\u0301",
          "\u010D": "c\u030C",
          "\u0109": "c\u0302",
          "\u010B": "c\u0307",
          "\u010F": "d\u030C",
          "\u1E0B": "d\u0307",
          "\xE9": "e\u0301",
          "\xE8": "e\u0300",
          "\xEB": "e\u0308",
          "\u1EBD": "e\u0303",
          "\u0113": "e\u0304",
          "\u1E17": "e\u0304\u0301",
          "\u1E15": "e\u0304\u0300",
          "\u0115": "e\u0306",
          "\u011B": "e\u030C",
          "\xEA": "e\u0302",
          "\u1EBF": "e\u0302\u0301",
          "\u1EC1": "e\u0302\u0300",
          "\u1EC5": "e\u0302\u0303",
          "\u0117": "e\u0307",
          "\u1E1F": "f\u0307",
          "\u01F5": "g\u0301",
          "\u1E21": "g\u0304",
          "\u011F": "g\u0306",
          "\u01E7": "g\u030C",
          "\u011D": "g\u0302",
          "\u0121": "g\u0307",
          "\u1E27": "h\u0308",
          "\u021F": "h\u030C",
          "\u0125": "h\u0302",
          "\u1E23": "h\u0307",
          "\xED": "i\u0301",
          "\xEC": "i\u0300",
          "\xEF": "i\u0308",
          "\u1E2F": "i\u0308\u0301",
          "\u0129": "i\u0303",
          "\u012B": "i\u0304",
          "\u012D": "i\u0306",
          "\u01D0": "i\u030C",
          "\xEE": "i\u0302",
          "\u01F0": "j\u030C",
          "\u0135": "j\u0302",
          "\u1E31": "k\u0301",
          "\u01E9": "k\u030C",
          "\u013A": "l\u0301",
          "\u013E": "l\u030C",
          "\u1E3F": "m\u0301",
          "\u1E41": "m\u0307",
          "\u0144": "n\u0301",
          "\u01F9": "n\u0300",
          "\xF1": "n\u0303",
          "\u0148": "n\u030C",
          "\u1E45": "n\u0307",
          "\xF3": "o\u0301",
          "\xF2": "o\u0300",
          "\xF6": "o\u0308",
          "\u022B": "o\u0308\u0304",
          "\xF5": "o\u0303",
          "\u1E4D": "o\u0303\u0301",
          "\u1E4F": "o\u0303\u0308",
          "\u022D": "o\u0303\u0304",
          "\u014D": "o\u0304",
          "\u1E53": "o\u0304\u0301",
          "\u1E51": "o\u0304\u0300",
          "\u014F": "o\u0306",
          "\u01D2": "o\u030C",
          "\xF4": "o\u0302",
          "\u1ED1": "o\u0302\u0301",
          "\u1ED3": "o\u0302\u0300",
          "\u1ED7": "o\u0302\u0303",
          "\u022F": "o\u0307",
          "\u0231": "o\u0307\u0304",
          "\u0151": "o\u030B",
          "\u1E55": "p\u0301",
          "\u1E57": "p\u0307",
          "\u0155": "r\u0301",
          "\u0159": "r\u030C",
          "\u1E59": "r\u0307",
          "\u015B": "s\u0301",
          "\u1E65": "s\u0301\u0307",
          "\u0161": "s\u030C",
          "\u1E67": "s\u030C\u0307",
          "\u015D": "s\u0302",
          "\u1E61": "s\u0307",
          "\u1E97": "t\u0308",
          "\u0165": "t\u030C",
          "\u1E6B": "t\u0307",
          "\xFA": "u\u0301",
          "\xF9": "u\u0300",
          "\xFC": "u\u0308",
          "\u01D8": "u\u0308\u0301",
          "\u01DC": "u\u0308\u0300",
          "\u01D6": "u\u0308\u0304",
          "\u01DA": "u\u0308\u030C",
          "\u0169": "u\u0303",
          "\u1E79": "u\u0303\u0301",
          "\u016B": "u\u0304",
          "\u1E7B": "u\u0304\u0308",
          "\u016D": "u\u0306",
          "\u01D4": "u\u030C",
          "\xFB": "u\u0302",
          "\u016F": "u\u030A",
          "\u0171": "u\u030B",
          "\u1E7D": "v\u0303",
          "\u1E83": "w\u0301",
          "\u1E81": "w\u0300",
          "\u1E85": "w\u0308",
          "\u0175": "w\u0302",
          "\u1E87": "w\u0307",
          "\u1E98": "w\u030A",
          "\u1E8D": "x\u0308",
          "\u1E8B": "x\u0307",
          "\xFD": "y\u0301",
          "\u1EF3": "y\u0300",
          "\xFF": "y\u0308",
          "\u1EF9": "y\u0303",
          "\u0233": "y\u0304",
          "\u0177": "y\u0302",
          "\u1E8F": "y\u0307",
          "\u1E99": "y\u030A",
          "\u017A": "z\u0301",
          "\u017E": "z\u030C",
          "\u1E91": "z\u0302",
          "\u017C": "z\u0307",
          "\xC1": "A\u0301",
          "\xC0": "A\u0300",
          "\xC4": "A\u0308",
          "\u01DE": "A\u0308\u0304",
          "\xC3": "A\u0303",
          "\u0100": "A\u0304",
          "\u0102": "A\u0306",
          "\u1EAE": "A\u0306\u0301",
          "\u1EB0": "A\u0306\u0300",
          "\u1EB4": "A\u0306\u0303",
          "\u01CD": "A\u030C",
          "\xC2": "A\u0302",
          "\u1EA4": "A\u0302\u0301",
          "\u1EA6": "A\u0302\u0300",
          "\u1EAA": "A\u0302\u0303",
          "\u0226": "A\u0307",
          "\u01E0": "A\u0307\u0304",
          "\xC5": "A\u030A",
          "\u01FA": "A\u030A\u0301",
          "\u1E02": "B\u0307",
          "\u0106": "C\u0301",
          "\u010C": "C\u030C",
          "\u0108": "C\u0302",
          "\u010A": "C\u0307",
          "\u010E": "D\u030C",
          "\u1E0A": "D\u0307",
          "\xC9": "E\u0301",
          "\xC8": "E\u0300",
          "\xCB": "E\u0308",
          "\u1EBC": "E\u0303",
          "\u0112": "E\u0304",
          "\u1E16": "E\u0304\u0301",
          "\u1E14": "E\u0304\u0300",
          "\u0114": "E\u0306",
          "\u011A": "E\u030C",
          "\xCA": "E\u0302",
          "\u1EBE": "E\u0302\u0301",
          "\u1EC0": "E\u0302\u0300",
          "\u1EC4": "E\u0302\u0303",
          "\u0116": "E\u0307",
          "\u1E1E": "F\u0307",
          "\u01F4": "G\u0301",
          "\u1E20": "G\u0304",
          "\u011E": "G\u0306",
          "\u01E6": "G\u030C",
          "\u011C": "G\u0302",
          "\u0120": "G\u0307",
          "\u1E26": "H\u0308",
          "\u021E": "H\u030C",
          "\u0124": "H\u0302",
          "\u1E22": "H\u0307",
          "\xCD": "I\u0301",
          "\xCC": "I\u0300",
          "\xCF": "I\u0308",
          "\u1E2E": "I\u0308\u0301",
          "\u0128": "I\u0303",
          "\u012A": "I\u0304",
          "\u012C": "I\u0306",
          "\u01CF": "I\u030C",
          "\xCE": "I\u0302",
          "\u0130": "I\u0307",
          "\u0134": "J\u0302",
          "\u1E30": "K\u0301",
          "\u01E8": "K\u030C",
          "\u0139": "L\u0301",
          "\u013D": "L\u030C",
          "\u1E3E": "M\u0301",
          "\u1E40": "M\u0307",
          "\u0143": "N\u0301",
          "\u01F8": "N\u0300",
          "\xD1": "N\u0303",
          "\u0147": "N\u030C",
          "\u1E44": "N\u0307",
          "\xD3": "O\u0301",
          "\xD2": "O\u0300",
          "\xD6": "O\u0308",
          "\u022A": "O\u0308\u0304",
          "\xD5": "O\u0303",
          "\u1E4C": "O\u0303\u0301",
          "\u1E4E": "O\u0303\u0308",
          "\u022C": "O\u0303\u0304",
          "\u014C": "O\u0304",
          "\u1E52": "O\u0304\u0301",
          "\u1E50": "O\u0304\u0300",
          "\u014E": "O\u0306",
          "\u01D1": "O\u030C",
          "\xD4": "O\u0302",
          "\u1ED0": "O\u0302\u0301",
          "\u1ED2": "O\u0302\u0300",
          "\u1ED6": "O\u0302\u0303",
          "\u022E": "O\u0307",
          "\u0230": "O\u0307\u0304",
          "\u0150": "O\u030B",
          "\u1E54": "P\u0301",
          "\u1E56": "P\u0307",
          "\u0154": "R\u0301",
          "\u0158": "R\u030C",
          "\u1E58": "R\u0307",
          "\u015A": "S\u0301",
          "\u1E64": "S\u0301\u0307",
          "\u0160": "S\u030C",
          "\u1E66": "S\u030C\u0307",
          "\u015C": "S\u0302",
          "\u1E60": "S\u0307",
          "\u0164": "T\u030C",
          "\u1E6A": "T\u0307",
          "\xDA": "U\u0301",
          "\xD9": "U\u0300",
          "\xDC": "U\u0308",
          "\u01D7": "U\u0308\u0301",
          "\u01DB": "U\u0308\u0300",
          "\u01D5": "U\u0308\u0304",
          "\u01D9": "U\u0308\u030C",
          "\u0168": "U\u0303",
          "\u1E78": "U\u0303\u0301",
          "\u016A": "U\u0304",
          "\u1E7A": "U\u0304\u0308",
          "\u016C": "U\u0306",
          "\u01D3": "U\u030C",
          "\xDB": "U\u0302",
          "\u016E": "U\u030A",
          "\u0170": "U\u030B",
          "\u1E7C": "V\u0303",
          "\u1E82": "W\u0301",
          "\u1E80": "W\u0300",
          "\u1E84": "W\u0308",
          "\u0174": "W\u0302",
          "\u1E86": "W\u0307",
          "\u1E8C": "X\u0308",
          "\u1E8A": "X\u0307",
          "\xDD": "Y\u0301",
          "\u1EF2": "Y\u0300",
          "\u0178": "Y\u0308",
          "\u1EF8": "Y\u0303",
          "\u0232": "Y\u0304",
          "\u0176": "Y\u0302",
          "\u1E8E": "Y\u0307",
          "\u0179": "Z\u0301",
          "\u017D": "Z\u030C",
          "\u1E90": "Z\u0302",
          "\u017B": "Z\u0307",
          "\u03AC": "\u03B1\u0301",
          "\u1F70": "\u03B1\u0300",
          "\u1FB1": "\u03B1\u0304",
          "\u1FB0": "\u03B1\u0306",
          "\u03AD": "\u03B5\u0301",
          "\u1F72": "\u03B5\u0300",
          "\u03AE": "\u03B7\u0301",
          "\u1F74": "\u03B7\u0300",
          "\u03AF": "\u03B9\u0301",
          "\u1F76": "\u03B9\u0300",
          "\u03CA": "\u03B9\u0308",
          "\u0390": "\u03B9\u0308\u0301",
          "\u1FD2": "\u03B9\u0308\u0300",
          "\u1FD1": "\u03B9\u0304",
          "\u1FD0": "\u03B9\u0306",
          "\u03CC": "\u03BF\u0301",
          "\u1F78": "\u03BF\u0300",
          "\u03CD": "\u03C5\u0301",
          "\u1F7A": "\u03C5\u0300",
          "\u03CB": "\u03C5\u0308",
          "\u03B0": "\u03C5\u0308\u0301",
          "\u1FE2": "\u03C5\u0308\u0300",
          "\u1FE1": "\u03C5\u0304",
          "\u1FE0": "\u03C5\u0306",
          "\u03CE": "\u03C9\u0301",
          "\u1F7C": "\u03C9\u0300",
          "\u038E": "\u03A5\u0301",
          "\u1FEA": "\u03A5\u0300",
          "\u03AB": "\u03A5\u0308",
          "\u1FE9": "\u03A5\u0304",
          "\u1FE8": "\u03A5\u0306",
          "\u038F": "\u03A9\u0301",
          "\u1FFA": "\u03A9\u0300"
        };
        var Parser2 = /* @__PURE__ */ function() {
          function Parser3(input, settings) {
            this.mode = void 0;
            this.gullet = void 0;
            this.settings = void 0;
            this.leftrightDepth = void 0;
            this.nextToken = void 0;
            this.mode = "math";
            this.gullet = new MacroExpander(input, settings, this.mode);
            this.settings = settings;
            this.leftrightDepth = 0;
          }
          var _proto = Parser3.prototype;
          _proto.expect = function expect(text, consume) {
            if (consume === void 0) {
              consume = true;
            }
            if (this.fetch().text !== text) {
              throw new src_ParseError("Expected '" + text + "', got '" + this.fetch().text + "'", this.fetch());
            }
            if (consume) {
              this.consume();
            }
          };
          _proto.consume = function consume() {
            this.nextToken = null;
          };
          _proto.fetch = function fetch() {
            if (this.nextToken == null) {
              this.nextToken = this.gullet.expandNextToken();
            }
            return this.nextToken;
          };
          _proto.switchMode = function switchMode(newMode) {
            this.mode = newMode;
            this.gullet.switchMode(newMode);
          };
          _proto.parse = function parse() {
            if (!this.settings.globalGroup) {
              this.gullet.beginGroup();
            }
            if (this.settings.colorIsTextColor) {
              this.gullet.macros.set("\\color", "\\textcolor");
            }
            var parse2 = this.parseExpression(false);
            this.expect("EOF");
            if (!this.settings.globalGroup) {
              this.gullet.endGroup();
            }
            return parse2;
          };
          _proto.parseExpression = function parseExpression(breakOnInfix, breakOnTokenText) {
            var body = [];
            while (true) {
              if (this.mode === "math") {
                this.consumeSpaces();
              }
              var lex = this.fetch();
              if (Parser3.endOfExpression.indexOf(lex.text) !== -1) {
                break;
              }
              if (breakOnTokenText && lex.text === breakOnTokenText) {
                break;
              }
              if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
                break;
              }
              var atom = this.parseAtom(breakOnTokenText);
              if (!atom) {
                break;
              } else if (atom.type === "internal") {
                continue;
              }
              body.push(atom);
            }
            if (this.mode === "text") {
              this.formLigatures(body);
            }
            return this.handleInfixNodes(body);
          };
          _proto.handleInfixNodes = function handleInfixNodes(body) {
            var overIndex = -1;
            var funcName;
            for (var i2 = 0; i2 < body.length; i2++) {
              if (body[i2].type === "infix") {
                if (overIndex !== -1) {
                  throw new src_ParseError("only one infix operator per group", body[i2].token);
                }
                overIndex = i2;
                funcName = body[i2].replaceWith;
              }
            }
            if (overIndex !== -1 && funcName) {
              var numerNode;
              var denomNode;
              var numerBody = body.slice(0, overIndex);
              var denomBody = body.slice(overIndex + 1);
              if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
                numerNode = numerBody[0];
              } else {
                numerNode = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: numerBody
                };
              }
              if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
                denomNode = denomBody[0];
              } else {
                denomNode = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: denomBody
                };
              }
              var node;
              if (funcName === "\\\\abovefrac") {
                node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
              } else {
                node = this.callFunction(funcName, [numerNode, denomNode], []);
              }
              return [node];
            } else {
              return body;
            }
          };
          _proto.handleSupSubscript = function handleSupSubscript(name2) {
            var symbolToken = this.fetch();
            var symbol = symbolToken.text;
            this.consume();
            this.consumeSpaces();
            var group = this.parseGroup(name2);
            if (!group) {
              throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
            }
            return group;
          };
          _proto.formatUnsupportedCmd = function formatUnsupportedCmd(text) {
            var textordArray = [];
            for (var i2 = 0; i2 < text.length; i2++) {
              textordArray.push({
                type: "textord",
                mode: "text",
                text: text[i2]
              });
            }
            var textNode = {
              type: "text",
              mode: this.mode,
              body: textordArray
            };
            var colorNode = {
              type: "color",
              mode: this.mode,
              color: this.settings.errorColor,
              body: [textNode]
            };
            return colorNode;
          };
          _proto.parseAtom = function parseAtom(breakOnTokenText) {
            var base2 = this.parseGroup("atom", breakOnTokenText);
            if (this.mode === "text") {
              return base2;
            }
            var superscript;
            var subscript;
            while (true) {
              this.consumeSpaces();
              var lex = this.fetch();
              if (lex.text === "\\limits" || lex.text === "\\nolimits") {
                if (base2 && base2.type === "op") {
                  var limits = lex.text === "\\limits";
                  base2.limits = limits;
                  base2.alwaysHandleSupSub = true;
                } else if (base2 && base2.type === "operatorname") {
                  if (base2.alwaysHandleSupSub) {
                    base2.limits = lex.text === "\\limits";
                  }
                } else {
                  throw new src_ParseError("Limit controls must follow a math operator", lex);
                }
                this.consume();
              } else if (lex.text === "^") {
                if (superscript) {
                  throw new src_ParseError("Double superscript", lex);
                }
                superscript = this.handleSupSubscript("superscript");
              } else if (lex.text === "_") {
                if (subscript) {
                  throw new src_ParseError("Double subscript", lex);
                }
                subscript = this.handleSupSubscript("subscript");
              } else if (lex.text === "'") {
                if (superscript) {
                  throw new src_ParseError("Double superscript", lex);
                }
                var prime = {
                  type: "textord",
                  mode: this.mode,
                  text: "\\prime"
                };
                var primes = [prime];
                this.consume();
                while (this.fetch().text === "'") {
                  primes.push(prime);
                  this.consume();
                }
                if (this.fetch().text === "^") {
                  primes.push(this.handleSupSubscript("superscript"));
                }
                superscript = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: primes
                };
              } else {
                break;
              }
            }
            if (superscript || subscript) {
              return {
                type: "supsub",
                mode: this.mode,
                base: base2,
                sup: superscript,
                sub: subscript
              };
            } else {
              return base2;
            }
          };
          _proto.parseFunction = function parseFunction(breakOnTokenText, name2) {
            var token = this.fetch();
            var func = token.text;
            var funcData = src_functions[func];
            if (!funcData) {
              return null;
            }
            this.consume();
            if (name2 && name2 !== "atom" && !funcData.allowedInArgument) {
              throw new src_ParseError("Got function '" + func + "' with no arguments" + (name2 ? " as " + name2 : ""), token);
            } else if (this.mode === "text" && !funcData.allowedInText) {
              throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
            } else if (this.mode === "math" && funcData.allowedInMath === false) {
              throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
            }
            var _this$parseArguments = this.parseArguments(func, funcData), args = _this$parseArguments.args, optArgs = _this$parseArguments.optArgs;
            return this.callFunction(func, args, optArgs, token, breakOnTokenText);
          };
          _proto.callFunction = function callFunction(name2, args, optArgs, token, breakOnTokenText) {
            var context = {
              funcName: name2,
              parser: this,
              token,
              breakOnTokenText
            };
            var func = src_functions[name2];
            if (func && func.handler) {
              return func.handler(context, args, optArgs);
            } else {
              throw new src_ParseError("No function handler for " + name2);
            }
          };
          _proto.parseArguments = function parseArguments(func, funcData) {
            var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
            if (totalArgs === 0) {
              return {
                args: [],
                optArgs: []
              };
            }
            var args = [];
            var optArgs = [];
            for (var i2 = 0; i2 < totalArgs; i2++) {
              var argType = funcData.argTypes && funcData.argTypes[i2];
              var isOptional = i2 < funcData.numOptionalArgs;
              if (funcData.primitive && argType == null || funcData.type === "sqrt" && i2 === 1 && optArgs[0] == null) {
                argType = "primitive";
              }
              var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
              if (isOptional) {
                optArgs.push(arg);
              } else if (arg != null) {
                args.push(arg);
              } else {
                throw new src_ParseError("Null argument, please report this as a bug");
              }
            }
            return {
              args,
              optArgs
            };
          };
          _proto.parseGroupOfType = function parseGroupOfType(name2, type, optional) {
            switch (type) {
              case "color":
                return this.parseColorGroup(optional);
              case "size":
                return this.parseSizeGroup(optional);
              case "url":
                return this.parseUrlGroup(optional);
              case "math":
              case "text":
                return this.parseArgumentGroup(optional, type);
              case "hbox": {
                var group = this.parseArgumentGroup(optional, "text");
                return group != null ? {
                  type: "styling",
                  mode: group.mode,
                  body: [group],
                  style: "text"
                } : null;
              }
              case "raw": {
                var token = this.parseStringGroup("raw", optional);
                return token != null ? {
                  type: "raw",
                  mode: "text",
                  string: token.text
                } : null;
              }
              case "primitive": {
                if (optional) {
                  throw new src_ParseError("A primitive argument cannot be optional");
                }
                var _group = this.parseGroup(name2);
                if (_group == null) {
                  throw new src_ParseError("Expected group as " + name2, this.fetch());
                }
                return _group;
              }
              case "original":
              case null:
              case void 0:
                return this.parseArgumentGroup(optional);
              default:
                throw new src_ParseError("Unknown group type as " + name2, this.fetch());
            }
          };
          _proto.consumeSpaces = function consumeSpaces() {
            while (this.fetch().text === " ") {
              this.consume();
            }
          };
          _proto.parseStringGroup = function parseStringGroup(modeName, optional) {
            var argToken = this.gullet.scanArgument(optional);
            if (argToken == null) {
              return null;
            }
            var str = "";
            var nextToken;
            while ((nextToken = this.fetch()).text !== "EOF") {
              str += nextToken.text;
              this.consume();
            }
            this.consume();
            argToken.text = str;
            return argToken;
          };
          _proto.parseRegexGroup = function parseRegexGroup(regex, modeName) {
            var firstToken = this.fetch();
            var lastToken = firstToken;
            var str = "";
            var nextToken;
            while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
              lastToken = nextToken;
              str += lastToken.text;
              this.consume();
            }
            if (str === "") {
              throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
            }
            return firstToken.range(lastToken, str);
          };
          _proto.parseColorGroup = function parseColorGroup(optional) {
            var res = this.parseStringGroup("color", optional);
            if (res == null) {
              return null;
            }
            var match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
            if (!match) {
              throw new src_ParseError("Invalid color: '" + res.text + "'", res);
            }
            var color = match[0];
            if (/^[0-9a-f]{6}$/i.test(color)) {
              color = "#" + color;
            }
            return {
              type: "color-token",
              mode: this.mode,
              color
            };
          };
          _proto.parseSizeGroup = function parseSizeGroup(optional) {
            var res;
            var isBlank = false;
            this.gullet.consumeSpaces();
            if (!optional && this.gullet.future().text !== "{") {
              res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
            } else {
              res = this.parseStringGroup("size", optional);
            }
            if (!res) {
              return null;
            }
            if (!optional && res.text.length === 0) {
              res.text = "0pt";
              isBlank = true;
            }
            var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
            if (!match) {
              throw new src_ParseError("Invalid size: '" + res.text + "'", res);
            }
            var data = {
              number: +(match[1] + match[2]),
              unit: match[3]
            };
            if (!validUnit(data)) {
              throw new src_ParseError("Invalid unit: '" + data.unit + "'", res);
            }
            return {
              type: "size",
              mode: this.mode,
              value: data,
              isBlank
            };
          };
          _proto.parseUrlGroup = function parseUrlGroup(optional) {
            this.gullet.lexer.setCatcode("%", 13);
            this.gullet.lexer.setCatcode("~", 12);
            var res = this.parseStringGroup("url", optional);
            this.gullet.lexer.setCatcode("%", 14);
            this.gullet.lexer.setCatcode("~", 13);
            if (res == null) {
              return null;
            }
            var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
            return {
              type: "url",
              mode: this.mode,
              url
            };
          };
          _proto.parseArgumentGroup = function parseArgumentGroup(optional, mode) {
            var argToken = this.gullet.scanArgument(optional);
            if (argToken == null) {
              return null;
            }
            var outerMode = this.mode;
            if (mode) {
              this.switchMode(mode);
            }
            this.gullet.beginGroup();
            var expression = this.parseExpression(false, "EOF");
            this.expect("EOF");
            this.gullet.endGroup();
            var result = {
              type: "ordgroup",
              mode: this.mode,
              loc: argToken.loc,
              body: expression
            };
            if (mode) {
              this.switchMode(outerMode);
            }
            return result;
          };
          _proto.parseGroup = function parseGroup(name2, breakOnTokenText) {
            var firstToken = this.fetch();
            var text = firstToken.text;
            var result;
            if (text === "{" || text === "\\begingroup") {
              this.consume();
              var groupEnd = text === "{" ? "}" : "\\endgroup";
              this.gullet.beginGroup();
              var expression = this.parseExpression(false, groupEnd);
              var lastToken = this.fetch();
              this.expect(groupEnd);
              this.gullet.endGroup();
              result = {
                type: "ordgroup",
                mode: this.mode,
                loc: SourceLocation.range(firstToken, lastToken),
                body: expression,
                semisimple: text === "\\begingroup" || void 0
              };
            } else {
              result = this.parseFunction(breakOnTokenText, name2) || this.parseSymbol();
              if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
                if (this.settings.throwOnError) {
                  throw new src_ParseError("Undefined control sequence: " + text, firstToken);
                }
                result = this.formatUnsupportedCmd(text);
                this.consume();
              }
            }
            return result;
          };
          _proto.formLigatures = function formLigatures(group) {
            var n = group.length - 1;
            for (var i2 = 0; i2 < n; ++i2) {
              var a = group[i2];
              var v = a.text;
              if (v === "-" && group[i2 + 1].text === "-") {
                if (i2 + 1 < n && group[i2 + 2].text === "-") {
                  group.splice(i2, 3, {
                    type: "textord",
                    mode: "text",
                    loc: SourceLocation.range(a, group[i2 + 2]),
                    text: "---"
                  });
                  n -= 2;
                } else {
                  group.splice(i2, 2, {
                    type: "textord",
                    mode: "text",
                    loc: SourceLocation.range(a, group[i2 + 1]),
                    text: "--"
                  });
                  n -= 1;
                }
              }
              if ((v === "'" || v === "`") && group[i2 + 1].text === v) {
                group.splice(i2, 2, {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(a, group[i2 + 1]),
                  text: v + v
                });
                n -= 1;
              }
            }
          };
          _proto.parseSymbol = function parseSymbol() {
            var nucleus = this.fetch();
            var text = nucleus.text;
            if (/^\\verb[^a-zA-Z]/.test(text)) {
              this.consume();
              var arg = text.slice(5);
              var star = arg.charAt(0) === "*";
              if (star) {
                arg = arg.slice(1);
              }
              if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
                throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
              }
              arg = arg.slice(1, -1);
              return {
                type: "verb",
                mode: "text",
                body: arg,
                star
              };
            }
            if (unicodeSymbols.hasOwnProperty(text[0]) && !src_symbols[this.mode][text[0]]) {
              if (this.settings.strict && this.mode === "math") {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text[0] + '" used in math mode', nucleus);
              }
              text = unicodeSymbols[text[0]] + text.substr(1);
            }
            var match = combiningDiacriticalMarksEndRegex.exec(text);
            if (match) {
              text = text.substring(0, match.index);
              if (text === "i") {
                text = "\u0131";
              } else if (text === "j") {
                text = "\u0237";
              }
            }
            var symbol;
            if (src_symbols[this.mode][text]) {
              if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text) >= 0) {
                this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text[0] + '" used in math mode', nucleus);
              }
              var group = src_symbols[this.mode][text].group;
              var loc = SourceLocation.range(nucleus);
              var s;
              if (ATOMS.hasOwnProperty(group)) {
                var family = group;
                s = {
                  type: "atom",
                  mode: this.mode,
                  family,
                  loc,
                  text
                };
              } else {
                s = {
                  type: group,
                  mode: this.mode,
                  loc,
                  text
                };
              }
              symbol = s;
            } else if (text.charCodeAt(0) >= 128) {
              if (this.settings.strict) {
                if (!supportedCodepoint(text.charCodeAt(0))) {
                  this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text[0] + '"' + (" (" + text.charCodeAt(0) + ")"), nucleus);
                } else if (this.mode === "math") {
                  this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text[0] + '" used in math mode', nucleus);
                }
              }
              symbol = {
                type: "textord",
                mode: "text",
                loc: SourceLocation.range(nucleus),
                text
              };
            } else {
              return null;
            }
            this.consume();
            if (match) {
              for (var i2 = 0; i2 < match[0].length; i2++) {
                var accent2 = match[0][i2];
                if (!unicodeAccents[accent2]) {
                  throw new src_ParseError("Unknown accent ' " + accent2 + "'", nucleus);
                }
                var command = unicodeAccents[accent2][this.mode];
                if (!command) {
                  throw new src_ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
                }
                symbol = {
                  type: "accent",
                  mode: this.mode,
                  loc: SourceLocation.range(nucleus),
                  label: command,
                  isStretchy: false,
                  isShifty: true,
                  base: symbol
                };
              }
            }
            return symbol;
          };
          return Parser3;
        }();
        Parser2.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
        ;
        var parseTree = function parseTree2(toParse, settings) {
          if (!(typeof toParse === "string" || toParse instanceof String)) {
            throw new TypeError("KaTeX can only parse string typed expression");
          }
          var parser2 = new Parser2(toParse, settings);
          delete parser2.gullet.macros.current["\\df@tag"];
          var tree = parser2.parse();
          delete parser2.gullet.macros.current["\\current@color"];
          delete parser2.gullet.macros.current["\\color"];
          if (parser2.gullet.macros.get("\\df@tag")) {
            if (!settings.displayMode) {
              throw new src_ParseError("\\tag works only in display equations");
            }
            parser2.gullet.feed("\\df@tag");
            tree = [{
              type: "tag",
              mode: "text",
              body: tree,
              tag: parser2.parse()
            }];
          }
          return tree;
        };
        var src_parseTree = parseTree;
        ;
        var render = function render2(expression, baseNode, options) {
          baseNode.textContent = "";
          var node = renderToDomTree(expression, options).toNode();
          baseNode.appendChild(node);
        };
        if (typeof document !== "undefined") {
          if (document.compatMode !== "CSS1Compat") {
            typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
            render = function render2() {
              throw new src_ParseError("KaTeX doesn't work in quirks mode.");
            };
          }
        }
        var renderToString = function renderToString2(expression, options) {
          var markup = renderToDomTree(expression, options).toMarkup();
          return markup;
        };
        var generateParseTree = function generateParseTree2(expression, options) {
          var settings = new Settings(options);
          return src_parseTree(expression, settings);
        };
        var renderError = function renderError2(error, expression, options) {
          if (options.throwOnError || !(error instanceof src_ParseError)) {
            throw error;
          }
          var node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
          node.setAttribute("title", error.toString());
          node.setAttribute("style", "color:" + options.errorColor);
          return node;
        };
        var renderToDomTree = function renderToDomTree2(expression, options) {
          var settings = new Settings(options);
          try {
            var tree = src_parseTree(expression, settings);
            return buildTree2(tree, expression, settings);
          } catch (error) {
            return renderError(error, expression, settings);
          }
        };
        var renderToHTMLTree = function renderToHTMLTree2(expression, options) {
          var settings = new Settings(options);
          try {
            var tree = src_parseTree(expression, settings);
            return buildHTMLTree(tree, expression, settings);
          } catch (error) {
            return renderError(error, expression, settings);
          }
        };
        var katex2 = {
          version: "0.13.11",
          render,
          renderToString,
          ParseError: src_ParseError,
          __parse: generateParseTree,
          __renderToDomTree: renderToDomTree,
          __renderToHTMLTree: renderToHTMLTree,
          __setFontMetrics: setFontMetrics,
          __defineSymbol: defineSymbol,
          __defineMacro: defineMacro,
          __domTree: {
            Span,
            Anchor,
            SymbolNode,
            SvgNode,
            PathNode,
            LineNode
          }
        };
        ;
        var katex_webpack = katex2;
        __webpack_exports__ = __webpack_exports__.default;
        return __webpack_exports__;
      }();
    });
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.replace(/^\s*/, "").replace(/\s*$/, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend2(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content2) {
      if (content2.charCodeAt(0) === 65279) {
        content2 = content2.slice(1);
      }
      return content2;
    }
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend: extend2,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled,
        rejected
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function transformData(data, headers, fns) {
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name2) {
        if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name2];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var createError = require_createError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name2, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name2 + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name2) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove2(name2) {
          this.write(name2, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove2() {
        }
      };
    }();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser2(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(resolve, reject, response);
          request = null;
        };
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, "ECONNABORTED", request));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            if (config.responseType !== "json") {
              throw e;
            }
          }
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject(cancel);
            request = null;
          });
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    var defaults2 = {
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, "application/json;charset=utf-8");
          return JSON.stringify(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        if (typeof data === "string") {
          try {
            data = JSON.parse(data);
          } catch (e) {
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults2.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults2.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults2.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults2;
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults2 = require_defaults();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData(config.data, config.headers, config.transformRequest);
      config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config.headers[method];
      });
      var adapter = config.adapter || defaults2.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData(response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      var valueFromConfig2Keys = ["url", "method", "data"];
      var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
      var defaultToConfig2Keys = [
        "baseURL",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "timeoutMessage",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "decompress",
        "maxContentLength",
        "maxBodyLength",
        "maxRedirects",
        "transport",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath",
        "responseEncoding"
      ];
      var directMergeKeys = ["validateStatus"];
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      }
      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        }
      });
      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
      var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils.forEach(otherKeys, mergeDeepProperties);
      return config;
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var chain = [dispatchRequest, void 0];
      var promise = Promise.resolve(config);
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });
      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    module.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults2 = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      return instance;
    }
    var axios2 = createInstance(defaults2);
    axios2.Axios = Axios;
    axios2.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios2.defaults, instanceConfig));
    };
    axios2.Cancel = require_Cancel();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module.exports = axios2;
    module.exports.default = axios2;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// src/index.tsx
var import_react8 = __toModule(require_react());
var import_react_dom = __toModule(require_react_dom());

// node_modules/reactex/dist/bibliography.js
var import_react4 = __toModule(require_react());
var import_bibtex_parse_js = __toModule(require_bibtexParse());
var import_lodash3 = __toModule(require_lodash());

// node_modules/reactex/dist/document.js
var import_react3 = __toModule(require_react());

// node_modules/reactex/dist/tex.js
var import_react = __toModule(require_react());
var import_katex = __toModule(require_katex());
var TexContext = class {
  constructor() {
    this.macros = {};
  }
  render(contents) {
    let html = import_katex.default.renderToString(contents, { macros: this.macros });
    return /* @__PURE__ */ import_react.default.createElement("span", {
      dangerouslySetInnerHTML: { __html: html }
    });
  }
};
var ReactTexContext = import_react.default.createContext(null);
var Tex = ({ children }) => {
  let ctx = (0, import_react.useContext)(ReactTexContext);
  return ctx.render(children);
};
var $ = Tex;

// node_modules/reactex/dist/code.js
var import_react2 = __toModule(require_react());

// node_modules/@codemirror/text/dist/index.js
var extend = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
for (let i = 1; i < extend.length; i++)
  extend[i] += extend[i - 1];
function isExtendingChar(code) {
  for (let i = 1; i < extend.length; i += 2)
    if (extend[i] > code)
      return extend[i - 1] <= code;
  return false;
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
var ZWJ = 8205;
function findClusterBreak(str, pos, forward = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);
}
function nextClusterBreak(str, pos) {
  if (pos == str.length)
    return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
    pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0, i = pos - 2;
      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
        countBefore++;
        i -= 2;
      }
      if (countBefore % 2 == 0)
        break;
      else
        pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2);
    if (found < pos)
      return found;
    pos--;
  }
  return 0;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}
function findColumn(string2, col, tabSize) {
  let _compat = arguments[3];
  if (_compat != null) {
    col = tabSize;
    tabSize = _compat;
  }
  for (let i = 0, n = 0; i < string2.length; ) {
    if (n >= col)
      return i;
    n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
    i = findClusterBreak(string2, i);
  }
  return string2.length;
}
var Text = class {
  constructor() {
  }
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  line(n) {
    if (n < 1 || n > this.lines)
      throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  replace(from, to, text) {
    let parts = [];
    this.decompose(0, from, parts, 2);
    if (text.length)
      text.decompose(0, text.length, parts, 1 | 2);
    this.decompose(to, this.length, parts, 1);
    return TextNode.from(parts, this.length - (to - from) + text.length);
  }
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  slice(from, to = this.length) {
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let a = new RawTextCursor(this), b = new RawTextCursor(other);
    for (; ; ) {
      a.next();
      b.next();
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
        return false;
      if (a.done)
        return true;
    }
  }
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  iterRange(from, to = this.length) {
    return new PartialTextCursor(this, from, to);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  static of(text) {
    if (text.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0])
      return Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
};
if (typeof Symbol != "undefined")
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
var TextLeaf = class extends Text {
  constructor(text, length = textLength(text)) {
    super();
    this.text = text;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let string2 = this.text[i], end = offset + string2.length;
      if ((isLine ? line : end) >= target)
        return new Line(offset, end, line, string2);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to, target, open) {
    let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text.text, prev.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new TextLeaf(joined, prev.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from, to, text) {
    if (!(text instanceof TextLeaf))
      return super.replace(from, to, text);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text.length - (to - from);
    if (lines.length <= 32)
      return new TextLeaf(lines, newLen);
    return TextNode.from(TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    let result = "";
    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
      let line = this.text[i], end = pos + line.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line of this.text)
      target.push(line);
  }
  static split(text, target) {
    let part = [], len = -1;
    for (let line of text) {
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new TextLeaf(part, len));
    return target;
  }
};
var TextNode = class extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (let child of children)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0; ; i++) {
      let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target)
        return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to, target, open) {
    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from && end <= to && !childOpen)
          target.push(child);
        else
          child.decompose(from - pos, to - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to, text) {
    if (text.lines < this.lines)
      for (let i = 0, pos = 0; i < this.children.length; i++) {
        let child = this.children[i], end = pos + child.length;
        if (from >= pos && to <= end) {
          let updated = child.replace(from - pos, to - pos, text);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy = this.children.slice();
            copy[i] = updated;
            return new TextNode(copy, this.length - (to - from) + text.length);
          }
          return super.replace(pos, end, updated);
        }
        pos = end + 1;
      }
    return super.replace(from, to, text);
  }
  sliceString(from, to = this.length, lineSep = "\n") {
    let result = "";
    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos > from && i)
        result += lineSep;
      if (from < end && to > pos)
        result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children)
        ch.flatten(flat);
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add(child) {
      let last;
      if (child.lines > maxChunk && child instanceof TextNode) {
        for (let node of child.children)
          add(node);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children)
      add(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
  }
};
Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
function textLength(text) {
  let length = -1;
  for (let line of text)
    length += line.length + 1;
  return length;
}
function appendText(text, target, from = 0, to = 1e9) {
  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
    let line = text[i], end = pos + line.length;
    if (end >= from) {
      if (end > to)
        line = line.slice(0, to - pos);
      if (pos < from)
        line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else
        target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from, to) {
  return appendText(text, [""], from, to);
}
var RawTextCursor = class {
  constructor(text, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last = this.nodes.length - 1;
      let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0)
            this.offsets[last]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
};
var PartialTextCursor = class {
  constructor(text, start2, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start2 > end ? -1 : 1);
    this.pos = start2 > end ? text.length : 0;
    this.from = Math.min(start2, end);
    this.to = Math.max(start2, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    this.done = false;
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
};
var Line = class {
  constructor(from, to, number2, text) {
    this.from = from;
    this.to = to;
    this.number = number2;
    this.text = text;
  }
  get length() {
    return this.to - this.from;
  }
};

// node_modules/@codemirror/state/dist/index.js
var DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
var ChangeDesc = class {
  constructor(sections) {
    this.sections = sections;
  }
  get length() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2)
      result += this.sections[i];
    return result;
  }
  get newLength() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1];
      result += ins < 0 ? this.sections[i] : ins;
    }
    return result;
  }
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  iterGaps(f) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  iterChangedRanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  get invertedDesc() {
    let sections = [];
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0)
        sections.push(len, ins);
      else
        sections.push(ins, len);
    }
    return new ChangeDesc(sections);
  }
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  touchesRange(from, to = from) {
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to; ) {
      let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
      if (ins >= 0 && pos <= to && end >= from)
        return pos < from && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  toString() {
    let result = "";
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ChangeDesc(json);
  }
};
var ChangeSet = class extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  invert(doc2) {
    let sections = this.sections.slice(), inserted = [];
    for (let i = 0, pos = 0; i < sections.length; i += 2) {
      let len = sections[i], ins = sections[i + 1];
      if (ins >= 0) {
        sections[i] = ins;
        sections[i + 1] = len;
        let index = i >> 1;
        while (inserted.length < index)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new ChangeSet(sections, inserted);
  }
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  iterChanges(f, individual = false) {
    iterChanges(this, f, individual);
  }
  get desc() {
    return new ChangeDesc(this.sections);
  }
  filter(ranges) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done:
      for (let i = 0, pos = 0; ; ) {
        let next = i == ranges.length ? 1e9 : ranges[i++];
        while (pos < next || pos == next && iter.len == 0) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, next - pos);
          addSection(filteredSections, len, -1);
          let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection(resultSections, len, ins);
          if (ins > 0)
            addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        let end = ranges[i++];
        while (pos < end) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, end - pos);
          addSection(resultSections, len, -1);
          addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len);
          pos += len;
        }
      }
    return {
      changes: new ChangeSet(resultSections, resultInserted),
      filtered: new ChangeDesc(filteredSections)
    };
  }
  toJSON() {
    let parts = [];
    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i], ins = this.sections[i + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i >> 1].toJSON()));
    }
    return parts;
  }
  static of(changes, length, lineSep) {
    let sections = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections.length)
        return;
      if (pos < length)
        addSection(sections, length - pos, -1);
      let set = new ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof ChangeSet) {
        if (spec.length != length)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from, to = from, insert: insert2 } = spec;
        if (from > to || from < 0 || to > length)
          throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from == to && insLen == 0)
          return;
        if (from < pos)
          flush();
        if (from > pos)
          addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  static empty(length) {
    return new ChangeSet(length ? [length, -1] : [], []);
  }
  static fromJSON(json) {
    if (!Array.isArray(json))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [], inserted = [];
    for (let i = 0; i < json.length; i++) {
      let part = json[i];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i)
          inserted.push(Text.empty);
        inserted[i] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i].length);
      }
    }
    return new ChangeSet(sections, inserted);
  }
};
function addSection(sections, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1])
    sections[last] += len;
  else if (len == 0 && sections[last] == 0)
    sections[last + 1] += ins;
  else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else
    sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0)
    return;
  let index = sections.length - 2 >> 1;
  if (index < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index)
      values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
    let len = desc.sections[i++], ins = desc.sections[i++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text = text.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
          break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }
      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections = [], insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let posA = 0, posB = 0; ; ) {
    if (a.ins == -1) {
      posA += a.len;
      a.next();
    } else if (b.ins == -1 && posB < posA) {
      let skip = Math.min(b.len, posA - posB);
      b.forward(skip);
      addSection(sections, skip, -1);
      posB += skip;
    } else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {
      addSection(sections, b.ins, -1);
      while (posA > posB && !a.done && posA + a.len < posB + b.len) {
        posA += a.len;
        a.next();
      }
      posB += b.len;
      b.next();
    } else if (a.ins >= 0) {
      let len = 0, end = posA + a.len;
      for (; ; ) {
        if (b.ins >= 0 && posB > posA && posB + b.len < end) {
          len += b.ins;
          posB += b.len;
          b.next();
        } else if (b.ins == -1 && posB < end) {
          let skip = Math.min(b.len, end - posB);
          len += skip;
          b.forward(skip);
          posB += skip;
        } else {
          break;
        }
      }
      addSection(sections, len, a.ins);
      if (insert2)
        addInsert(insert2, sections, a.text);
      posA = end;
      a.next();
    } else if (a.done && b.done) {
      return insert2 ? new ChangeSet(sections, insert2) : new ChangeDesc(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections = [];
  let insert2 = mkSet ? [] : null;
  let a = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a.done && b.done) {
      return insert2 ? new ChangeSet(sections, insert2) : new ChangeDesc(sections);
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len), sectionLen = sections.length;
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert2)
          addInsert(insert2, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections, b.text);
      }
      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}
var SectionIter = class {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length ? Text.empty : inserted[index];
  }
  textBit(len) {
    let { inserted } = this.set, index = this.i - 2 >> 1;
    return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
};
var SelectionRange = class {
  constructor(from, to, flags) {
    this.from = from;
    this.to = to;
    this.flags = flags;
  }
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  get bidiLevel() {
    let level = this.flags & 3;
    return level == 3 ? null : level;
  }
  get goalColumn() {
    let value = this.flags >> 5;
    return value == 33554431 ? void 0 : value;
  }
  map(change, assoc = -1) {
    let from = change.mapPos(this.from, assoc), to = change.mapPos(this.to, assoc);
    return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
  }
  extend(from, to = from) {
    if (from <= this.anchor && to >= this.anchor)
      return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  eq(other) {
    return this.anchor == other.anchor && this.head == other.head;
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }
};
var EditorSelection = class {
  constructor(ranges, mainIndex = 0) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  map(change, assoc = -1) {
    if (change.empty)
      return this;
    return EditorSelection.create(this.ranges.map((r2) => r2.map(change, assoc)), this.mainIndex);
  }
  eq(other) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(other.ranges[i]))
        return false;
    return true;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main]);
  }
  addRange(range, main = true) {
    return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  replaceRange(range, which = this.mainIndex) {
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return EditorSelection.create(ranges, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((r2) => r2.toJSON()), main: this.mainIndex };
  }
  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new EditorSelection(json.ranges.map((r2) => SelectionRange.fromJSON(r2)), json.main);
  }
  static single(anchor, head = anchor) {
    return new EditorSelection([EditorSelection.range(anchor, head)], 0);
  }
  static create(ranges, mainIndex = 0) {
    if (ranges.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i = 0; i < ranges.length; i++) {
      let range = ranges[i];
      if (range.empty ? range.from <= pos : range.from < pos)
        return normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new EditorSelection(ranges, mainIndex);
  }
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
  }
  static range(anchor, head, goalColumn) {
    let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
    return head < anchor ? new SelectionRange(head, anchor, 16 | goal) : new SelectionRange(anchor, head, goal);
  }
};
function normalized(ranges, mainIndex = 0) {
  let main = ranges[mainIndex];
  ranges.sort((a, b) => a.from - b.from);
  mainIndex = ranges.indexOf(main);
  for (let i = 1; i < ranges.length; i++) {
    let range = ranges[i], prev = ranges[i - 1];
    if (range.empty ? range.from <= prev.to : range.from < prev.to) {
      let from = prev.from, to = Math.max(range.to, prev.to);
      if (i <= mainIndex)
        mainIndex--;
      ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
    }
  }
  return new EditorSelection(ranges, mainIndex);
}
function checkSelection(selection, docLength) {
  for (let range of selection.ranges)
    if (range.to > docLength)
      throw new RangeError("Selection points outside of document");
}
var nextID = 0;
var Facet = class {
  constructor(combine, compareInput, compare2, isStatic, extensions) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.extensions = extensions;
    this.id = nextID++;
    this.default = combine([]);
  }
  static define(config = {}) {
    return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
  }
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  compute(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  computeN(deps, get) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get)
      get = (x) => x;
    return this.compute([field], (state) => get(state.field(field)));
  }
};
function sameArray(a, b) {
  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
var FacetProvider = class {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let idx = addresses[this.id] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return (state, tr) => {
      if (!tr || tr.reconfigured) {
        state.values[idx] = getter(state);
        return 1;
      } else {
        let depChanged = depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || depAddrs.some((addr) => (ensureAddr(state, addr) & 1) > 0);
        if (!depChanged)
          return 0;
        let newVal = getter(state), oldVal = tr.startState.values[idx];
        if (multi ? compareArray(newVal, oldVal, compare2) : compare2(newVal, oldVal))
          return 0;
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
};
function compareArray(a, b, compare2) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!compare2(a[i], b[i]))
      return false;
  return true;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  return (state, tr) => {
    let oldAddr = !tr ? null : tr.reconfigured ? tr.startState.config.address[facet.id] : idx << 1;
    let changed = oldAddr == null;
    for (let dynAddr of dynamic) {
      if (ensureAddr(state, dynAddr) & 1)
        changed = true;
    }
    if (!changed)
      return 0;
    let values = [];
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2)
        for (let val of value)
          values.push(val);
      else
        values.push(value);
    }
    let newVal = facet.combine(values);
    if (oldAddr != null && facet.compare(newVal, getAddr(tr.startState, oldAddr)))
      return 0;
    state.values[idx] = newVal;
    return 1;
  };
}
function maybeIndex(state, id) {
  let found = state.config.address[id];
  return found == null ? null : found >> 1;
}
var initField = /* @__PURE__ */ Facet.define({ static: true });
var StateField = class {
  constructor(id, createF, updateF, compareF, spec) {
    this.id = id;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  static define(config) {
    let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
    if (config.provide)
      field.provides = config.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find((i) => i.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return (state, tr) => {
      if (!tr || tr.reconfigured && maybeIndex(tr.startState, this.id) == null) {
        state.values[idx] = this.create(state);
        return 1;
      }
      let oldVal, changed = 0;
      if (tr.reconfigured) {
        oldVal = tr.startState.values[maybeIndex(tr.startState, this.id)];
        changed = 1;
      } else {
        oldVal = tr.startState.values[idx];
      }
      let value = this.updateF(oldVal, tr);
      if (!changed && !this.compareF(oldVal, value))
        changed = 1;
      if (changed)
        state.values[idx] = value;
      return changed;
    };
  }
  init(create) {
    return [this, initField.of({ field: this, create })];
  }
  get extension() {
    return this;
  }
};
var Prec_ = { fallback: 3, default: 2, extend: 1, override: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
var Prec = {
  fallback: /* @__PURE__ */ prec(Prec_.fallback),
  default: /* @__PURE__ */ prec(Prec_.default),
  extend: /* @__PURE__ */ prec(Prec_.extend),
  override: /* @__PURE__ */ prec(Prec_.override)
};
var PrecExtension = class {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
};
var Compartment = class {
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  reconfigure(content2) {
    return Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  get(state) {
    return state.config.compartments.get(this);
  }
};
var CompartmentInstance = class {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
};
var Configuration = class {
  constructor(base2, compartments, dynamicSlots, address, staticValues) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(0);
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = Object.create(null);
    let newCompartments = new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a) => field.slot(a));
    }
    for (let id in facets) {
      let providers = facets[id], facet = providers[0].facet;
      if (providers.every((p) => p.type == 0)) {
        address[facet.id] = staticValues.length << 1 | 1;
        let value = facet.combine(providers.map((p) => p.value));
        let oldAddr = oldState ? oldState.config.address[facet.id] : null;
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (facet.compare(value, oldVal))
            value = oldVal;
        }
        staticValues.push(value);
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a) => p.dynamicSlot(a));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
      }
    }
    return new Configuration(base2, newCompartments, dynamicSlots.map((f) => f(address)), address, staticValues);
  }
};
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], []];
  let seen = new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known >= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e of ext)
        inner(e, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, prec2);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.config.dynamicSlots[idx](state, state.applying);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
var languageData = /* @__PURE__ */ Facet.define();
var allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((v) => v),
  static: true
});
var lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : void 0,
  static: true
});
var changeFilter = /* @__PURE__ */ Facet.define();
var transactionFilter = /* @__PURE__ */ Facet.define();
var transactionExtender = /* @__PURE__ */ Facet.define();
var Annotation = class {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  static define() {
    return new AnnotationType();
  }
};
var AnnotationType = class {
  of(value) {
    return new Annotation(this, value);
  }
};
var StateEffectType = class {
  constructor(map) {
    this.map = map;
  }
  of(value) {
    return new StateEffect(this, value);
  }
};
var StateEffect = class {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
  }
  is(type) {
    return this.type == type;
  }
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
};
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
var Transaction = class {
  constructor(startState, changes, selection, effects, annotations, scrollIntoView) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView;
    this._doc = null;
    this._state = null;
    if (selection)
      checkSelection(selection, changes.newLength);
    if (!annotations.some((a) => a.type == Transaction.time))
      this.annotations = annotations.concat(Transaction.time.of(Date.now()));
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  annotation(type) {
    for (let ann of this.annotations)
      if (ann.type == type)
        return ann.value;
    return void 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
};
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a, b) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from, to;
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to = b[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from)
      result.push(from, to);
    else if (result[result.length - 1] < to)
      result[result.length - 1] = to;
  }
}
function mergeTransaction(a, b, sequential) {
  var _a;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection;
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations: asArray(spec.annotations),
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false)
      filter = false;
    let seq = !!specs[i].sequential;
    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
  }
  let tr = new Transaction(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.invertedDesc;
    }
    tr = new Transaction(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr);
    if (extension && Object.keys(extension).length)
      spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : new Transaction(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
var none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
var wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_4) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char) => {
    if (!/\S/.test(char))
      return CharCategory.Space;
    if (hasWordChar(char))
      return CharCategory.Word;
    for (let i = 0; i < wordChars.length; i++)
      if (char.indexOf(wordChars[i]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
var EditorState = class {
  constructor(config, doc2, selection, tr = null) {
    this.config = config;
    this.doc = doc2;
    this.selection = selection;
    this.applying = null;
    this.status = config.statusTemplate.slice();
    if (tr && tr.startState.config == config) {
      this.values = tr.startState.values.slice();
    } else {
      this.values = config.dynamicSlots.map((_4) => null);
      if (tr)
        for (let id in config.address) {
          let cur = config.address[id], prev = tr.startState.config.address[id];
          if (prev != null && (cur & 1) == 0)
            this.values[cur >> 1] = getAddr(tr.startState, prev);
        }
    }
    this.applying = tr;
    if (tr)
      tr._state = this;
    for (let i = 0; i < this.config.dynamicSlots.length; i++)
      ensureAddr(this, i << 1);
    this.applying = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  applyTransaction(tr) {
    let conf = this.config, { base: base2, compartments } = conf;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base2 = asArray(base2).concat(effect.value);
      }
    }
    new EditorState(conf || Configuration.resolve(base2, compartments, this), tr.newDoc, tr.newSelection, tr);
  }
  replaceSelection(text) {
    if (typeof text == "string")
      text = this.toText(text);
    return this.changeByRange((range) => ({
      changes: { from: range.from, to: range.to, insert: text },
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f(sel.ranges[i]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j = 0; j < i; j++)
        ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
  }
  toText(string2) {
    return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
  }
  sliceDoc(from = 0, to = this.doc.length) {
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  static fromJSON(json, config = {}, fields) {
    if (!json || typeof json.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        let field = fields[prop], value = json[prop];
        fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
      }
    return EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
    });
  }
  static create(config = {}) {
    let configuration = Configuration.resolve(config.extensions || [], new Map());
    let doc2 = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
    let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
    checkSelection(selection, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection = selection.asSingle();
    return new EditorState(configuration, doc2, selection);
  }
  get tabSize() {
    return this.facet(EditorState.tabSize);
  }
  get lineBreak() {
    return this.facet(EditorState.lineSeparator) || "\n";
  }
  phrase(phrase) {
    for (let map of this.facet(EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map, phrase))
        return map[phrase];
    return phrase;
  }
  languageDataAt(name2, pos) {
    let values = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values.push(result[name2]);
      }
    }
    return values;
  }
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  wordAt(pos) {
    let { text, from, length } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start2 = pos - from, end = pos - from;
    while (start2 > 0) {
      let prev = findClusterBreak(text, start2, false);
      if (cat(text.slice(prev, start2)) != CharCategory.Word)
        break;
      start2 = prev;
    }
    while (end < length) {
      let next = findClusterBreak(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word)
        break;
      end = next;
    }
    return start2 == end ? EditorSelection.range(start2 + from, end + from) : null;
  }
};
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values) => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.phrases = /* @__PURE__ */ Facet.define();
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
function combineConfig(configs, defaults2, combine = {}) {
  let result = {};
  for (let config of configs)
    for (let key of Object.keys(config)) {
      let value = config[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0)
        ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults2)
    if (result[key] === void 0)
      result[key] = defaults2[key];
  return result;
}

// node_modules/style-mod/src/style-mod.js
var C = "\u037C";
var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
var StyleModule = class {
  constructor(spec, options) {
    this.rules = [];
    let { finish } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec2, target, isKeyframes) {
      let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null)
        return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render(prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);
        } else if (value && typeof value == "object") {
          if (!isAt)
            throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec)
      render(splitSelector(prop), spec[prop], this.rules);
  }
  getRules() {
    return this.rules.join("\n");
  }
  static newName() {
    let id = top[COUNT] || 1;
    top[COUNT] = id + 1;
    return C + id.toString(36);
  }
  static mount(root, modules) {
    (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
  }
};
var adoptedSet = null;
var StyleSet = class {
  constructor(root) {
    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
      if (adoptedSet) {
        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
        return root[SET] = adoptedSet;
      }
      this.sheet = new CSSStyleSheet();
      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
      adoptedSet = this;
    } else {
      this.styleTag = (root.ownerDocument || root).createElement("style");
      let target = root.head || root;
      target.insertBefore(this.styleTag, target.firstChild);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules) {
    let sheet = this.sheet;
    let pos = 0, j = 0;
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i], index = this.modules.indexOf(mod);
      if (index < j && index > -1) {
        this.modules.splice(index, 1);
        j--;
        index = -1;
      }
      if (index == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet)
          for (let k = 0; k < mod.rules.length; k++)
            sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index)
          pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (!sheet) {
      let text = "";
      for (let i = 0; i < this.modules.length; i++)
        text += this.modules[i].getRules() + "\n";
      this.styleTag.textContent = text;
    }
  }
};

// node_modules/@codemirror/rangeset/dist/index.js
var RangeValue = class {
  eq(other) {
    return this == other;
  }
  range(from, to = from) {
    return new Range(from, to, this);
  }
};
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
var Range = class {
  constructor(from, to, value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }
};
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}
var Chunk = class {
  constructor(from, to, value, maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(pos, side, end, startAt = 0) {
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset, from, to, f) {
    for (let i = this.findIndex(from, -1e9, true), e = this.findIndex(to, 1e9, false, i); i < e; i++)
      if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
  }
};
var RangeSet = class {
  constructor(chunkPos, chunk, nextLayer = RangeSet.empty, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  chunkEnd(index) {
    return this.chunkPos[index] + this.chunk[index].length;
  }
  update(updateSpec) {
    let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter = updateSpec.filter;
    if (add.length == 0 && !filter)
      return this;
    if (sort)
      add.slice().sort(cmpRange);
    if (this.isEmpty)
      return add.length ? RangeSet.of(add) : this;
    let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur.value || i < add.length) {
      if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
        let range = add[i++];
        if (!builder.addInner(range.from, range.to, range.value))
          spill.push(range);
      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
        cur.nextChunk();
      } else {
        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
          if (!builder.addInner(cur.from, cur.to, cur.value))
            spill.push(new Range(cur.from, cur.to, cur.value));
        }
        cur.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
  }
  map(changes) {
    if (changes.length == 0 || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i = 0; i < this.chunk.length; i++) {
      let start2 = this.chunkPos[i], chunk = this.chunk[i];
      let touch = changes.touchesRange(start2, start2 + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start2));
      } else if (touch === true) {
        let { mapped, pos } = chunk.map(start2, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);
  }
  between(from, to, f) {
    if (this.isEmpty)
      return;
    for (let i = 0; i < this.chunk.length; i++) {
      let start2 = this.chunkPos[i], chunk = this.chunk[i];
      if (to >= start2 && from <= start2 + chunk.length && chunk.between(start2, from - start2, to - start2, f) === false)
        return;
    }
    this.nextLayer.between(from, to, f);
  }
  iter(from = 0) {
    return HeapCursor.from([this]).goto(from);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(sets, from = 0) {
    return HeapCursor.from(sets).goto(from);
  }
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a = oldSets.filter((set) => set.maxPoint >= 500 || !set.isEmpty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);
    let b = newSets.filter((set) => set.maxPoint >= 500 || !set.isEmpty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  static eq(oldSets, newSets, from = 0, to) {
    if (to == null)
      to = 1e9;
    let a = oldSets.filter((set) => !set.isEmpty && newSets.indexOf(set) < 0);
    let b = newSets.filter((set) => !set.isEmpty && oldSets.indexOf(set) < 0);
    if (a.length != b.length)
      return false;
    if (!a.length)
      return true;
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to >= to)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  static spans(sets, from, to, iterator, minPointSize = -1) {
    let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
    let open = cursor.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor.to, to);
      if (cursor.point) {
        iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);
        open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor.active, open);
        open = cursor.openEnd(curTo);
      }
      if (cursor.to > to)
        break;
      pos = cursor.to;
      cursor.next();
    }
    return open;
  }
  static of(ranges, sort = false) {
    let build = new RangeSetBuilder();
    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
      build.add(range.from, range.to, range.value);
    return build.finish();
  }
};
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1)
    for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
      let cur = ranges[i];
      if (cmpRange(prev, cur) > 0)
        return ranges.slice().sort(cmpRange);
      prev = cur;
    }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
var RangeSetBuilder = class {
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  add(from, to, value) {
    if (!this.addInner(from, to, value))
      (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
  }
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  finishInner(next) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next;
    let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
};
function findSharedChunks(a, b) {
  let inA = new Map();
  for (let set of a)
    for (let i = 0; i < set.chunk.length; i++)
      if (set.chunk[i].maxPoint < 500)
        inA.set(set.chunk[i], set.chunkPos[i]);
  let shared = new Set();
  for (let set of b)
    for (let i = 0; i < set.chunk.length; i++)
      if (inA.get(set.chunk[i]) == set.chunkPos[i])
        shared.add(set.chunk[i]);
  return shared;
}
var LayerCursor = class {
  constructor(layer, skip, minPoint, rank = 0) {
    this.layer = layer;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0 : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
    if (!forward || this.rangeIndex < rangeIndex)
      this.rangeIndex = rangeIndex;
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        if (++this.rangeIndex == chunk.value.length) {
          this.chunkIndex++;
          if (this.skip) {
            while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
              this.chunkIndex++;
          }
          this.rangeIndex = 0;
        }
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;
  }
};
var HeapCursor = class {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i = 0; i < sets.length; i++) {
      for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
        if (cur.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur, skip, minPoint, i));
      }
    }
    return heap.length == 1 ? heap[0] : new HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur of this.heap)
      cur.goto(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur of this.heap)
      cur.forward(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
};
function heapBubble(heap, index) {
  for (let cur = heap[index]; ; ) {
    let childIndex = (index << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur.compare(child) < 0)
      break;
    heap[childIndex] = cur;
    heap[index] = child;
    index = childIndex;
  }
}
var SpanCursor = class {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index) {
    remove(this.active, index);
    remove(this.activeTo, index);
    remove(this.activeRank, index);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i = 0, { value, to, rank } = this.cursor;
    while (i < this.activeRank.length && this.activeRank[i] <= rank)
      i++;
    insert(this.active, i, value);
    insert(this.activeTo, i, to);
    insert(this.activeRank, i, rank);
    if (trackOpen)
      insert(trackOpen, i, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  next() {
    let from = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
    for (; ; ) {
      let a = this.minActive;
      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a] > from) {
          this.to = this.activeTo[a];
          this.endSide = this.active[a].endSide;
          break;
        }
        this.removeActive(a);
        if (trackOpen)
          remove(trackOpen, a);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to && nextVal.endSide == this.endSide) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          if (this.cursor.from < from)
            trackExtra = 1;
          this.cursor.next();
          if (this.to > from)
            this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      let openStart = 0;
      while (openStart < trackOpen.length && trackOpen[openStart] < from)
        openStart++;
      this.openStart = openStart + trackExtra;
    }
  }
  activeForPoint(to) {
    if (!this.active.length)
      return this.active;
    let active = [];
    for (let i = this.active.length - 1; i >= 0; i--) {
      if (this.activeRank[i] < this.pointRank)
        break;
      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide)
        active.push(this.active[i]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
      open++;
    return open;
  }
};
function compare(a, startA, b, startB, length, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let diff = a.to + dPos - b.to || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
    if (a.point || b.point) {
      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))
        comparator.comparePoint(pos, clipEnd, a.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a.active, b.active))
        comparator.compareRange(pos, clipEnd, a.active, b.active);
    }
    if (end > endB)
      break;
    pos = end;
    if (diff <= 0)
      a.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (a[i] != b[i] && !a[i].eq(b[i]))
      return false;
  return true;
}
function remove(array, index) {
  for (let i = index, e = array.length - 1; i < e; i++)
    array[i] = array[i + 1];
  array.pop();
}
function insert(array, index, value) {
  for (let i = array.length - 1; i >= index; i--)
    array[i + 1] = array[i];
  array[index] = value;
}
function findMinIndex(value, array) {
  let found = -1, foundPos = 1e9;
  for (let i = 0; i < array.length; i++)
    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
      found = i;
      foundPos = array[i];
    }
  return found;
}

// node_modules/w3c-keyname/index.es.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"',
  229: "Q"
};
var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac;
for (var i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];

// node_modules/@codemirror/view/dist/index.js
function getSelection(root) {
  return root.getSelection ? root.getSelection() : document.getSelection();
}
function contains(dom, node) {
  return node ? dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function deepActiveElement() {
  let elt = document.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function hasSelection(dom, selection) {
  if (!selection.anchorNode)
    return false;
  try {
    return contains(dom, selection.anchorNode);
  } catch (_4) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV")
        return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
var Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
function flattenRect(rect, left) {
  let x = left ? rect.left : rect.right;
  return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
var ScrollSpace = 5;
function scrollRectIntoView(dom, rect) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView;
  for (let cur = dom.parentNode; cur; ) {
    if (cur.nodeType == 1) {
      let bounding, top2 = cur == document.body;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
          cur = cur.parentNode;
          continue;
        }
        let rect2 = cur.getBoundingClientRect();
        bounding = {
          left: rect2.left,
          right: rect2.left + cur.clientWidth,
          top: rect2.top,
          bottom: rect2.top + cur.clientHeight
        };
      }
      let moveX = 0, moveY = 0;
      if (rect.top < bounding.top)
        moveY = -(bounding.top - rect.top + ScrollSpace);
      else if (rect.bottom > bounding.bottom)
        moveY = rect.bottom - bounding.bottom + ScrollSpace;
      if (rect.left < bounding.left)
        moveX = -(bounding.left - rect.left + ScrollSpace);
      else if (rect.right > bounding.right)
        moveX = rect.right - bounding.right + ScrollSpace;
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          if (moveY) {
            let start2 = cur.scrollTop;
            cur.scrollTop += moveY;
            moveY = cur.scrollTop - start2;
          }
          if (moveX) {
            let start2 = cur.scrollLeft;
            cur.scrollLeft += moveX;
            moveX = cur.scrollLeft - start2;
          }
          rect = {
            left: rect.left - moveX,
            top: rect.top - moveY,
            right: rect.right - moveX,
            bottom: rect.bottom - moveY
          };
        }
      }
      if (top2)
        break;
      cur = cur.assignedSlot || cur.parentNode;
    } else if (cur.nodeType == 11) {
      cur = cur.host;
    } else {
      break;
    }
  }
}
var DOMSelection = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  set(domSel) {
    this.anchorNode = domSel.anchorNode;
    this.anchorOffset = domSel.anchorOffset;
    this.focusNode = domSel.focusNode;
    this.focusOffset = domSel.focusOffset;
  }
};
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur = dom; cur; cur = cur.parentNode) {
    stack.push(cur, cur.scrollTop, cur.scrollLeft);
    if (cur == cur.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i = 0; i < stack.length; ) {
      let elt = stack[i++], top2 = stack[i++], left = stack[i++];
      if (elt.scrollTop != top2)
        elt.scrollTop = top2;
      if (elt.scrollLeft != left)
        elt.scrollLeft = left;
    }
  }
}
var scratchRange;
function textRange(node, from, to = from) {
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node, to);
  range.setStart(node, from);
  return range;
}
function dispatchKey(elt, name2, code) {
  let options = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options);
  up.synthetic = true;
  elt.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
var _plainTextSupported = null;
function contentEditablePlainTextSupported() {
  if (_plainTextSupported == null) {
    _plainTextSupported = false;
    let dummy = document.createElement("div");
    try {
      dummy.contentEditable = "plaintext-only";
      _plainTextSupported = dummy.contentEditable == "plaintext-only";
    } catch (_4) {
    }
  }
  return _plainTextSupported;
}
var DOMPos = class {
  constructor(node, offset, precise = true) {
    this.node = node;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
};
var none$3 = [];
var ContentView = class {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.dirty = 2;
  }
  get editorView() {
    if (!this.parent)
      throw new Error("Accessing view in orphan content view");
    return this.parent.editorView;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  coordsAt(_pos, _side) {
    return null;
  }
  sync(track) {
    var _a;
    if (this.dirty & 2) {
      let parent = this.dom, pos = null;
      for (let child of this.children) {
        if (child.dirty) {
          let next2 = pos ? pos.nextSibling : parent.firstChild;
          if (!child.dom && next2 && !((_a = ContentView.get(next2)) === null || _a === void 0 ? void 0 : _a.parent))
            child.reuseDOM(next2);
          child.sync(track);
          child.dirty = 0;
        }
        if (track && track.node == parent && pos != child.dom)
          track.written = true;
        syncNodeInto(parent, pos, child.dom);
        pos = child.dom;
      }
      let next = pos ? pos.nextSibling : parent.firstChild;
      if (next && track && track.node == parent)
        track.written = true;
      while (next)
        next = rm(next);
    } else if (this.dirty & 1) {
      for (let child of this.children)
        if (child.dirty) {
          child.sync(track);
          child.dirty = 0;
        }
    }
  }
  reuseDOM(_dom) {
    return false;
  }
  localPosFromDOM(node, offset) {
    let after;
    if (node == this.dom) {
      after = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
      for (; ; ) {
        let parent = node.parentNode;
        if (parent == this.dom)
          break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node == parent.firstChild)
            bias = -1;
          else
            bias = 1;
        }
        node = parent;
      }
      if (bias < 0)
        after = node;
      else
        after = node.nextSibling;
    }
    if (after == this.dom.firstChild)
      return 0;
    while (after && !ContentView.get(after))
      after = after.nextSibling;
    if (!after)
      return this.length;
    for (let i = 0, pos = 0; ; i++) {
      let child = this.children[i];
      if (child.dom == after)
        return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from, to, offset = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (pos < from && end > to)
        return child.domBoundsAround(from, to, pos);
      if (end >= from && fromI == -1) {
        fromI = i;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == this.dom) {
        toI = i;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent = false) {
    if (this.dirty & 2)
      return;
    this.dirty |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList)
        parent.dirty |= 2;
      if (parent.dirty & 1)
        return;
      parent.dirty |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.dirty)
        this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v = this; ; ) {
      let parent = v.parent;
      if (!parent)
        return v;
      v = parent;
    }
  }
  replaceChildren(from, to, children = none$3) {
    this.markDirty();
    for (let i = from; i < to; i++) {
      let child = this.children[i];
      if (child.parent == this)
        child.parent = null;
    }
    this.children.splice(from, to - from, ...children);
    for (let i = 0; i < children.length; i++)
      children[i].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name2 = this.constructor.name.replace("View", "");
    return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node) {
    return node.cmView;
  }
};
ContentView.prototype.breakAfter = 0;
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
function syncNodeInto(parent, after, dom) {
  let next = after ? after.nextSibling : parent.firstChild;
  if (dom.parentNode == parent)
    while (next != dom)
      next = rm(next);
  else
    parent.insertBefore(dom, next);
}
var ChildCursor = class {
  constructor(children, pos, i) {
    this.children = children;
    this.pos = pos;
    this.i = i;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }
};
var [nav, doc] = typeof navigator != "undefined" ? [navigator, document] : [{ userAgent: "", vendor: "", platform: "" }, { documentElement: { style: {} } }];
var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
var gecko2 = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
var chrome2 = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
var webkit = "webkitFontSmoothing" in doc.documentElement.style;
var safari2 = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
var browser = {
  mac: /* @__PURE__ */ /Mac/.test(nav.platform),
  ie: ie2,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko: gecko2,
  gecko_version: gecko2 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome2,
  chrome_version: chrome2 ? +chrome2[1] : 0,
  ios: safari2 && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2),
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  webkit,
  safari: safari2,
  webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
var none$2 = [];
var InlineView = class extends ContentView {
  become(_other) {
    return false;
  }
  getSide() {
    return 0;
  }
};
InlineView.prototype.children = none$2;
var MaxJoinLen = 256;
var TextView = class extends InlineView {
  constructor(text) {
    super();
    this.text = text;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(track) {
    if (!this.dom)
      this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType != 3)
      return false;
    this.createDOM(dom);
    return true;
  }
  merge(from, to, source) {
    if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen))
      return false;
    this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
    this.markDirty();
    return true;
  }
  slice(from) {
    return new TextView(this.text.slice(from));
  }
  localPosFromDOM(node, offset) {
    return node == this.dom ? offset : offset ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset) {
    return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
};
var MarkView = class extends InlineView {
  constructor(mark, children = [], length = 0) {
    super();
    this.mark = mark;
    this.children = children;
    this.length = length;
    for (let ch of children)
      ch.setParent(this);
  }
  createDOM() {
    let dom = document.createElement(this.mark.tagName);
    if (this.mark.class)
      dom.className = this.mark.class;
    if (this.mark.attrs)
      for (let name2 in this.mark.attrs)
        dom.setAttribute(name2, this.mark.attrs[name2]);
    this.setDOM(dom);
  }
  sync(track) {
    if (!this.dom)
      this.createDOM();
    super.sync(track);
  }
  merge(from, to, source, openStart, openEnd) {
    if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    mergeInlineChildren(this, from, to, source ? source.children : none$2, openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  slice(from) {
    return new MarkView(this.mark, sliceInlineChildren(this.children, from), this.length - from);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this.dom, this.children, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
};
function textCoords(text, pos, side) {
  let length = text.nodeValue.length;
  if (pos > length)
    pos = length;
  let from = pos, to = pos, flatten2 = 0;
  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from--;
        flatten2 = 1;
      } else {
        to++;
        flatten2 = -1;
      }
    }
  } else {
    if (side < 0)
      from--;
    else
      to++;
  }
  let rects = textRange(text, from, to).getClientRects();
  if (!rects.length)
    return Rect0;
  let rect = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten2 && rect.width == 0)
    rect = Array.prototype.find.call(rects, (r2) => r2.width) || rect;
  return flatten2 ? flattenRect(rect, flatten2 < 0) : rect;
}
var WidgetView = class extends InlineView {
  constructor(widget, length, side) {
    super();
    this.widget = widget;
    this.length = length;
    this.side = side;
  }
  static create(widget, length, side) {
    return new (widget.customView || WidgetView)(widget, length, side);
  }
  slice(from) {
    return WidgetView.create(this.widget, this.length - from, this.side);
  }
  sync() {
    if (!this.dom || !this.widget.updateDOM(this.dom)) {
      this.setDOM(this.widget.toDOM(this.editorView));
      this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from, to, source, openStart, openEnd) {
    if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  become(other) {
    if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
      if (this.widget.constructor == other.widget.constructor) {
        if (!this.widget.eq(other.widget))
          this.markDirty(true);
        this.widget = other.widget;
        return true;
      }
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Text.empty;
    let top2 = this;
    while (top2.parent)
      top2 = top2.parent;
    let view = top2.editorView, text = view && view.state.doc, start2 = this.posAtStart;
    return text ? text.slice(start2, start2 + this.length) : Text.empty;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let rects = this.dom.getClientRects(), rect = null;
    if (!rects.length)
      return Rect0;
    for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
      rect = rects[i];
      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
        break;
    }
    return pos == 0 && side > 0 || pos == this.length && side <= 0 ? rect : flattenRect(rect, pos == 0);
  }
};
var CompositionView = class extends WidgetView {
  domAtPos(pos) {
    return new DOMPos(this.widget.text, pos);
  }
  sync() {
    if (!this.dom)
      this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(node, offset) {
    return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;
  }
  ignoreMutation() {
    return false;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(pos, side) {
    return textCoords(this.widget.text, pos, side);
  }
};
function mergeInlineChildren(parent, from, to, elts, openStart, openEnd) {
  let cur = parent.childCursor();
  let { i: toI, off: toOff } = cur.findPos(to, 1);
  let { i: fromI, off: fromOff } = cur.findPos(from, -1);
  let dLen = from - to;
  for (let view of elts)
    dLen += view.length;
  parent.length += dLen;
  let { children } = parent;
  if (fromI == toI && fromOff) {
    let start2 = children[fromI];
    if (elts.length == 1 && start2.merge(fromOff, toOff, elts[0], openStart, openEnd))
      return;
    if (elts.length == 0) {
      start2.merge(fromOff, toOff, null, openStart, openEnd);
      return;
    }
    let after = start2.slice(toOff);
    if (after.merge(0, 0, elts[elts.length - 1], 0, openEnd))
      elts[elts.length - 1] = after;
    else
      elts.push(after);
    toI++;
    openEnd = toOff = 0;
  }
  if (toOff) {
    let end = children[toI];
    if (elts.length && end.merge(0, toOff, elts[elts.length - 1], 0, openEnd)) {
      elts.pop();
      openEnd = elts.length ? 0 : openStart;
    } else {
      end.merge(0, toOff, null, 0, 0);
    }
  } else if (toI < children.length && elts.length && children[toI].merge(0, 0, elts[elts.length - 1], 0, openEnd)) {
    elts.pop();
    openEnd = elts.length ? 0 : openStart;
  }
  if (fromOff) {
    let start2 = children[fromI];
    if (elts.length && start2.merge(fromOff, start2.length, elts[0], openStart, 0)) {
      elts.shift();
      openStart = elts.length ? 0 : openEnd;
    } else {
      start2.merge(fromOff, start2.length, null, 0, 0);
    }
    fromI++;
  } else if (fromI && elts.length) {
    let end = children[fromI - 1];
    if (end.merge(end.length, end.length, elts[0], openStart, 0)) {
      elts.shift();
      openStart = elts.length ? 0 : openEnd;
    }
  }
  while (fromI < toI && elts.length && children[toI - 1].become(elts[elts.length - 1])) {
    elts.pop();
    toI--;
    openEnd = elts.length ? 0 : openStart;
  }
  while (fromI < toI && elts.length && children[fromI].become(elts[0])) {
    elts.shift();
    fromI++;
    openStart = elts.length ? 0 : openEnd;
  }
  if (!elts.length && fromI && toI < children.length && openStart && openEnd && children[toI].merge(0, 0, children[fromI - 1], openStart, openEnd))
    fromI--;
  if (elts.length || fromI != toI)
    parent.replaceChildren(fromI, toI, elts);
}
function sliceInlineChildren(children, from) {
  let result = [], off = 0;
  for (let elt of children) {
    let end = off + elt.length;
    if (end > from)
      result.push(off < from ? elt.slice(from - off) : elt);
    off = end;
  }
  return result;
}
function inlineDOMAtPos(dom, children, pos) {
  let i = 0;
  for (let off = 0; i < children.length; i++) {
    let child = children[i], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (pos > off && pos < end && child.dom.parentNode == dom)
      return child.domAtPos(pos - off);
    if (pos <= off)
      break;
    off = end;
  }
  for (; i > 0; i--) {
    let before = children[i - 1].dom;
    if (before.parentNode == dom)
      return DOMPos.after(before);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last, { children } = parent;
  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
    joinInlineInto(last, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  for (let off = 0, i = 0; i < view.children.length; i++) {
    let child = view.children[i], end = off + child.length;
    if (end == off && child.getSide() <= 0)
      continue;
    if (side <= 0 || end == view.length ? end >= pos : end > pos)
      return child.coordsAt(pos - off, side);
    off = end;
  }
  let last = view.dom.lastChild;
  if (!last)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1];
}
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class)
      target.class += " " + source.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name2] = source[name2];
  }
  return target;
}
function attrsEq(a, b) {
  if (a == b)
    return true;
  if (!a || !b)
    return false;
  let keysA = Object.keys(a), keysB = Object.keys(b);
  if (keysA.length != keysB.length)
    return false;
  for (let key of keysA) {
    if (keysB.indexOf(key) == -1 || a[key] !== b[key])
      return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  if (prev) {
    for (let name2 in prev)
      if (!(attrs && name2 in attrs))
        dom.removeAttribute(name2);
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev && prev[name2] == attrs[name2]))
        dom.setAttribute(name2, attrs[name2]);
  }
}
var WidgetType = class {
  eq(_widget) {
    return false;
  }
  updateDOM(_dom) {
    return false;
  }
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent(_event) {
    return true;
  }
  get customView() {
    return null;
  }
};
var BlockType = /* @__PURE__ */ function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
var Decoration = class extends RangeValue {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  get heightRelevant() {
    return false;
  }
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  static widget(spec) {
    let side = spec.side || 0;
    if (spec.block)
      side += (2e8 + 1) * (side > 0 ? 1 : -1);
    return new PointDecoration(spec, side, side, !!spec.block, spec.widget || null, false);
  }
  static replace(spec) {
    let block = !!spec.block;
    let { start: start2, end } = getInclusive(spec);
    let startSide = block ? -2e8 * (start2 ? 2 : 1) : 1e8 * (start2 ? -1 : 1);
    let endSide = block ? 2e8 * (end ? 2 : 1) : 1e8 * (end ? 1 : -1);
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  static line(spec) {
    return new LineDecoration(spec);
  }
  static set(of, sort = false) {
    return RangeSet.of(of, sort);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
};
Decoration.none = RangeSet.empty;
var MarkDecoration = class extends Decoration {
  constructor(spec) {
    let { start: start2, end } = getInclusive(spec);
    super(1e8 * (start2 ? -1 : 1), 1e8 * (end ? 1 : -1), null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
  }
  range(from, to = from) {
    if (from >= to)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to);
  }
};
MarkDecoration.prototype.point = false;
var LineDecoration = class extends Decoration {
  constructor(spec) {
    super(-1e8, -1e8, null, spec);
  }
  eq(other) {
    return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to = from) {
    if (to != from)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to);
  }
};
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
var PointDecoration = class extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide < 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  get type() {
    return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide < 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
  }
  eq(other) {
    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to = from) {
    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide < 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to);
  }
};
PointDecoration.prototype.point = true;
function getInclusive(spec) {
  let { inclusiveStart: start2, inclusiveEnd: end } = spec;
  if (start2 == null)
    start2 = spec.inclusive;
  if (end == null)
    end = spec.inclusive;
  return { start: start2 || false, end: end || false };
}
function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin > from)
    ranges[last] = Math.max(ranges[last], to);
  else
    ranges.push(from, to);
}
var LineView = class extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  merge(from, to, source, takeDeco, openStart, openEnd) {
    if (source) {
      if (!(source instanceof LineView))
        return false;
      if (!this.dom)
        source.transferDOM(this);
    }
    if (takeDeco)
      this.setDeco(source ? source.attrs : null);
    mergeInlineChildren(this, from, to, source ? source.children : none$1, openStart, openEnd);
    return true;
  }
  split(at) {
    let end = new LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0)
      return end;
    let { i, off } = this.childPos(at);
    if (off) {
      end.append(this.children[i].slice(off), 0);
      this.children[i].merge(off, this.children[i].length, null, 0, 0);
      i++;
    }
    for (let j = i; j < this.children.length; j++)
      end.append(this.children[j], 0);
    while (i > 0 && this.children[i - 1].length == 0) {
      this.children[i - 1].parent = null;
      i--;
    }
    this.children.length = i;
    this.markDirty();
    this.length = at;
    return end;
  }
  transferDOM(other) {
    if (!this.dom)
      return;
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  addLineDeco(deco) {
    let attrs = deco.spec.attributes;
    if (attrs)
      this.attrs = combineAttrs(attrs, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this.dom, this.children, pos);
  }
  sync(track) {
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(track);
    let last = this.dom.lastChild;
    if (!last || last.nodeName != "BR" && ContentView.get(last) instanceof WidgetView && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let totalWidth = 0;
    for (let child of this.children) {
      if (!(child instanceof TextView))
        return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1)
        return null;
      totalWidth += rects[0].width;
    }
    return {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length
    };
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
  match(_other) {
    return false;
  }
  get type() {
    return BlockType.Text;
  }
  static find(docView, pos) {
    for (let i = 0, off = 0; ; i++) {
      let block = docView.children[i], end = off + block.length;
      if (end >= pos) {
        if (block instanceof LineView)
          return block;
        if (block.length)
          return null;
      }
      off = end + block.breakAfter;
    }
  }
};
var none$1 = [];
var BlockWidgetView = class extends ContentView {
  constructor(widget, length, type) {
    super();
    this.widget = widget;
    this.length = length;
    this.type = type;
    this.breakAfter = 0;
  }
  merge(from, to, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
      return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at) {
    let len = this.length - at;
    this.length = at;
    return new BlockWidgetView(this.widget, len, this.type);
  }
  get children() {
    return none$1;
  }
  sync() {
    if (!this.dom || !this.widget.updateDOM(this.dom)) {
      this.setDOM(this.widget.toDOM(this.editorView));
      this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  match(other) {
    if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.eq(this.widget))
        this.markDirty(true);
      this.widget = other.widget;
      this.length = other.length;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
};
var ContentBuilder = class {
  constructor(doc2, pos, end) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last = this.content[this.content.length - 1];
    return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
  }
  getLine() {
    if (!this.curLine)
      this.content.push(this.curLine = new LineView());
    return this.curLine;
  }
  addWidget(view) {
    this.curLine = null;
    this.content.push(view);
  }
  finish() {
    if (!this.posCovered())
      this.getLine();
  }
  wrapMarks(view, active) {
    for (let mark of active)
      view = new MarkView(mark, [view], view.length);
    return view;
  }
  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let { value, lineBreak, done } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done)
          throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered())
            this.getLine();
          if (this.content.length)
            this.content[this.content.length - 1].breakAfter = 1;
          else
            this.breakAtStart = 1;
          this.curLine = null;
          length--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(this.text.length - this.textOff, length, 512);
      this.getLine().append(this.wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.textOff += take;
      length -= take;
      openStart = 0;
    }
  }
  span(from, to, active, openStart) {
    this.buildText(to - from, active, openStart);
    this.pos = to;
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  point(from, to, deco, active, openStart) {
    let len = to - from;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        let { type } = deco;
        if (type == BlockType.WidgetAfter && !this.posCovered())
          this.getLine();
        this.addWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
      } else {
        let widget = this.wrapMarks(WidgetView.create(deco.widget || new NullWidget("span"), len, deco.startSide), active);
        this.getLine().append(widget, openStart);
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to;
    }
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  static build(text, from, to, decorations2) {
    let builder = new ContentBuilder(text, from, to);
    builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
    if (builder.openStart < 0)
      builder.openStart = builder.openEnd;
    builder.finish();
    return builder;
  }
};
var NullWidget = class extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
};
var none2 = [];
var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
var exceptionSink = /* @__PURE__ */ Facet.define();
var updateListener = /* @__PURE__ */ Facet.define();
var inputHandler = /* @__PURE__ */ Facet.define();
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror)
    window.onerror(String(exception), context, void 0, void 0, exception);
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
var editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
var PluginFieldProvider = class {
  constructor(field, get) {
    this.field = field;
    this.get = get;
  }
};
var PluginField = class {
  from(get) {
    return new PluginFieldProvider(this, get);
  }
  static define() {
    return new PluginField();
  }
};
PluginField.decorations = /* @__PURE__ */ PluginField.define();
PluginField.atomicRanges = /* @__PURE__ */ PluginField.define();
PluginField.scrollMargins = /* @__PURE__ */ PluginField.define();
var nextPluginID = 0;
var viewPlugin = /* @__PURE__ */ Facet.define();
var ViewPlugin = class {
  constructor(id, create, fields) {
    this.id = id;
    this.create = create;
    this.fields = fields;
    this.extension = viewPlugin.of(this);
  }
  static define(create, spec) {
    let { eventHandlers, provide, decorations: decorations2 } = spec || {};
    let fields = [];
    if (provide)
      for (let provider of Array.isArray(provide) ? provide : [provide])
        fields.push(provider);
    if (eventHandlers)
      fields.push(domEventHandlers.from((value) => ({ plugin: value, handlers: eventHandlers })));
    if (decorations2)
      fields.push(PluginField.decorations.from(decorations2));
    return new ViewPlugin(nextPluginID++, create, fields);
  }
  static fromClass(cls, spec) {
    return ViewPlugin.define((view) => new cls(view), spec);
  }
};
var domEventHandlers = /* @__PURE__ */ PluginField.define();
var PluginInstance = class {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  takeField(type, target) {
    for (let { field, get } of this.spec.fields)
      if (field == type)
        target.push(get(this.value));
  }
  update(view) {
    if (!this.value) {
      try {
        this.value = this.spec.create(view);
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
        return PluginInstance.dummy;
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (!this.value.update)
        return this;
      try {
        this.value.update(update);
      } catch (e) {
        logException(update.state, e, "CodeMirror plugin crashed");
        if (this.value.destroy)
          try {
            this.value.destroy();
          } catch (_4) {
          }
        return PluginInstance.dummy;
      }
    }
    return this;
  }
  destroy(view) {
    var _a;
    if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
      try {
        this.value.destroy();
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
      }
    }
  }
};
PluginInstance.dummy = /* @__PURE__ */ new PluginInstance(/* @__PURE__ */ ViewPlugin.define(() => ({})));
var editorAttributes = /* @__PURE__ */ Facet.define({
  combine: (values) => values.reduce((a, b) => combineAttrs(b, a), {})
});
var contentAttributes = /* @__PURE__ */ Facet.define({
  combine: (values) => values.reduce((a, b) => combineAttrs(b, a), {})
});
var decorations = /* @__PURE__ */ Facet.define();
var styleModule = /* @__PURE__ */ Facet.define();
var ChangedRange = class {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set) {
    let i = set.length, me = this;
    for (; i > 0; i--) {
      let range = set[i - 1];
      if (range.fromA > me.toA)
        continue;
      if (range.toA < me.fromA)
        break;
      me = me.join(range);
      set.splice(i - 1, 1);
    }
    set.splice(i, 0, me);
    return set;
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next = dI == diff.length ? null : diff[dI], off = posA - posB;
      let end = next ? next.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI], to = ranges[rI + 1];
        let fromB = Math.max(posB, from), toB = Math.min(end, to);
        if (fromB <= toB)
          new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
        if (to > end)
          break;
        else
          rI += 2;
      }
      if (!next)
        return result;
      new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
      posA = next.toA;
      posB = next.toB;
    }
  }
};
var ViewUpdate = class {
  constructor(view, state, transactions = none2) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr of transactions)
      this.changes = this.changes.compose(tr.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      view.inputState.notifiedFocused = focus;
      this.flags |= 1;
    }
    if (this.docChanged)
      this.flags |= 2;
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & (16 | 2)) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return this.transactions.some((tr) => tr.docChanged);
  }
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
};
var DocView = class extends ContentView {
  constructor(view) {
    super();
    this.view = view;
    this.compositionDeco = Decoration.none;
    this.decorations = [];
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], this.updateDeco(), 0);
  }
  get root() {
    return this.view.root;
  }
  get editorView() {
    return this.view;
  }
  get length() {
    return this.view.state.doc.length;
  }
  update(update) {
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    if (this.view.inputState.composing < 0)
      this.compositionDeco = Decoration.none;
    else if (update.transactions.length)
      this.compositionDeco = computeCompositionDeco(this.view, update.changes);
    let forceSelection = (browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    let pointerSel = update.transactions.some((tr) => tr.annotation(Transaction.userEvent) == "pointerselection");
    if (this.dirty == 0 && changedRanges.length == 0 && !(update.flags & (4 | 8)) && update.state.selection.main.from >= this.view.viewport.from && update.state.selection.main.to <= this.view.viewport.to) {
      this.updateSelection(forceSelection, pointerSel);
      return false;
    } else {
      this.updateInner(changedRanges, deco, update.startState.doc.length, forceSelection, pointerSel);
      return true;
    }
  }
  updateInner(changes, deco, oldLength, forceSelection = false, pointerSel = false) {
    this.updateChildren(changes, deco, oldLength);
    let { observer } = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.domHeight + "px";
      this.dom.style.minWidth = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.sync(track);
      this.dirty = 0;
      if (track && (track.written || observer.selectionRange.focusNode != track.node))
        forceSelection = true;
      this.updateSelection(forceSelection, pointerSel);
      this.dom.style.height = "";
    });
  }
  updateChildren(changes, deco, oldLength) {
    let cursor = this.childCursor(oldLength);
    for (let i = changes.length - 1; ; i--) {
      let next = i >= 0 ? changes[i] : null;
      if (!next)
        break;
      let { fromA, toA, fromB, toB } = next;
      let { content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, deco);
      let { i: toI, off: toOff } = cursor.findPos(toA, 1);
      let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
      this.replaceRange(fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
    }
  }
  replaceRange(fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd) {
    let before = this.children[fromI], last = content2.length ? content2[content2.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    if (fromI == toI && !breakAtStart && !breakAtEnd && content2.length < 2 && before.merge(fromOff, toOff, content2.length ? last : null, fromOff == 0, openStart, openEnd))
      return;
    let after = this.children[toI];
    if (toOff < after.length || after.children.length && after.children[after.children.length - 1].length == 0) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
        content2[content2.length - 1] = after;
      } else {
        if (toOff || after.children.length && after.children[0].length == 0)
          after.merge(0, toOff, null, false, 0, openEnd);
        content2.push(after);
      }
    } else if (after.breakAfter) {
      if (last)
        last.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && content2.length && before.merge(fromOff, before.length, content2[0], false, openStart, 0)) {
        before.breakAfter = content2.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
    while (fromI < toI && content2.length) {
      if (this.children[toI - 1].match(content2[content2.length - 1]))
        toI--, content2.pop();
      else if (this.children[fromI].match(content2[0]))
        fromI++, content2.shift();
      else
        break;
    }
    if (fromI < toI || content2.length)
      this.replaceChildren(fromI, toI, content2);
  }
  updateSelection(force = false, fromPointer = false) {
    if (!(fromPointer || this.mayControlSelection()) || browser.ios && this.view.inputState.rapidCompositionStart)
      return;
    let main = this.view.state.selection.main;
    let anchor = this.domAtPos(main.anchor);
    let head = main.empty ? anchor : this.domAtPos(main.head);
    if (browser.gecko && main.empty && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
      this.view.observer.ignore(() => {
        let rawSel = getSelection(this.root);
        if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
              if (text)
                anchor = new DOMPos(text, nextTo == 1 ? 0 : text.nodeValue.length);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
            domSel.cursorBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          rawSel.extend(head.node, head.offset);
        } else {
          let range = document.createRange();
          if (main.anchor > main.head)
            [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.view.composing)
      return;
    let cursor = this.view.state.selection.main;
    let sel = getSelection(this.root);
    if (!cursor.empty || !cursor.assoc || !sel.modify)
      return;
    let line = LineView.find(this, cursor.head);
    if (!line)
      return;
    let lineStart = line.posAtStart;
    if (cursor.head == lineStart || cursor.head == lineStart + line.length)
      return;
    let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor.head + cursor.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
  }
  mayControlSelection() {
    return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, this.view.observer.selectionRange);
  }
  nearest(dom) {
    for (let cur = dom; cur; ) {
      let domView = ContentView.get(cur);
      if (domView && domView.rootView == this)
        return domView;
      cur = cur.parentNode;
    }
    return null;
  }
  posFromDOM(node, offset) {
    let view = this.nearest(node);
    if (!view)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node, offset) + view.posAtStart;
  }
  domAtPos(pos) {
    let { i, off } = this.childCursor().findPos(pos, -1);
    for (; i < this.children.length - 1; ) {
      let child = this.children[i];
      if (off < child.length || child instanceof LineView)
        break;
      i++;
      off = 0;
    }
    return this.children[i].domAtPos(off);
  }
  coordsAt(pos, side) {
    for (let off = this.length, i = this.children.length - 1; ; i--) {
      let child = this.children[i], start2 = off - child.breakAfter - child.length;
      if (pos > start2 || pos == start2 && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2))
        return child.coordsAt(pos - start2, side);
      off = start2;
    }
  }
  measureVisibleLineHeights() {
    let result = [], { from, to } = this.view.viewState.viewport;
    let minWidth = Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    for (let pos = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = pos + child.length;
      if (end > to)
        break;
      if (pos >= from) {
        result.push(child.dom.getBoundingClientRect().height);
        let width = child.dom.scrollWidth;
        if (width > minWidth) {
          this.minWidth = minWidth = width;
          this.minWidthFrom = pos;
          this.minWidthTo = end;
        }
      }
      pos = end + child.breakAfter;
    }
    return result;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure)
          return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth;
    dummy.className = "cm-line";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      dummy.remove();
    });
    return { lineHeight, charWidth };
  }
  childCursor(pos = this.length) {
    let i = this.children.length;
    if (i)
      pos -= this.children[--i].length;
    return new ChildCursor(this.children, pos, i);
  }
  computeBlockGapDeco() {
    let deco = [], vs = this.view.viewState;
    for (let pos = 0, i = 0; ; i++) {
      let next = i == vs.viewports.length ? null : vs.viewports[i];
      let end = next ? next.from - 1 : this.length;
      if (end > pos) {
        let height = vs.lineAt(end, 0).bottom - vs.lineAt(pos, 0).top;
        deco.push(Decoration.replace({ widget: new BlockGapWidget(height), block: true, inclusive: true }).range(pos, end));
      }
      if (!next)
        break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    return this.decorations = [
      ...this.view.pluginField(PluginField.decorations),
      ...this.view.state.facet(decorations),
      this.compositionDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollPosIntoView(pos, side) {
    let rect = this.coordsAt(pos, side);
    if (!rect)
      return;
    let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
    for (let margins of this.view.pluginField(PluginField.scrollMargins))
      if (margins) {
        let { left, right, top: top2, bottom } = margins;
        if (left != null)
          mLeft = Math.max(mLeft, left);
        if (right != null)
          mRight = Math.max(mRight, right);
        if (top2 != null)
          mTop = Math.max(mTop, top2);
        if (bottom != null)
          mBottom = Math.max(mBottom, bottom);
      }
    scrollRectIntoView(this.dom, {
      left: rect.left - mLeft,
      top: rect.top - mTop,
      right: rect.right + mRight,
      bottom: rect.bottom + mBottom
    });
  }
};
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
var BlockGapWidget = class extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
};
function computeCompositionDeco(view, changes) {
  let sel = view.observer.selectionRange;
  let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
  if (!textNode)
    return Decoration.none;
  let cView = view.docView.nearest(textNode);
  let from, to, topNode = textNode;
  if (cView instanceof InlineView) {
    while (cView.parent instanceof InlineView)
      cView = cView.parent;
    from = cView.posAtStart;
    to = from + cView.length;
    topNode = cView.dom;
  } else if (cView instanceof LineView) {
    while (topNode.parentNode != cView.dom)
      topNode = topNode.parentNode;
    let prev = topNode.previousSibling;
    while (prev && !ContentView.get(prev))
      prev = prev.previousSibling;
    from = to = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
  } else {
    return Decoration.none;
  }
  let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
  let text = textNode.nodeValue, { state } = view;
  if (newTo - newFrom < text.length) {
    if (state.sliceDoc(newFrom, Math.min(state.doc.length, newFrom + text.length)) == text)
      newTo = newFrom + text.length;
    else if (state.sliceDoc(Math.max(0, newTo - text.length), newTo) == text)
      newFrom = newTo - text.length;
    else
      return Decoration.none;
  } else if (state.sliceDoc(newFrom, newTo) != text) {
    return Decoration.none;
  }
  return Decoration.set(Decoration.replace({ widget: new CompositionWidget(topNode, textNode) }).range(newFrom, newTo));
}
var CompositionWidget = class extends WidgetType {
  constructor(top2, text) {
    super();
    this.top = top2;
    this.text = text;
  }
  eq(other) {
    return this.top == other.top && this.text == other.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return false;
  }
  get customView() {
    return CompositionView;
  }
};
function nearbyTextNode(node, offset, side) {
  for (; ; ) {
    if (node.nodeType == 3)
      return node;
    if (node.nodeType == 1 && offset > 0 && side <= 0) {
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null;
    }
  }
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1)
    return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
var DecorationComparator$1 = class {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint(from, to) {
    addRange(from, to, this.changes);
  }
};
function findChangedDeco(a, b, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a, b, diff, comp);
  return comp.changes;
}
var Direction = /* @__PURE__ */ function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
var LTR = Direction.LTR;
var RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i = 0; i < str.length; i++)
    result.push(1 << +str[i]);
  return result;
}
var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
var Brackets = /* @__PURE__ */ Object.create(null);
var BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
  let l = /* @__PURE__ */ p.charCodeAt(0), r2 = /* @__PURE__ */ p.charCodeAt(1);
  Brackets[l] = r2;
  Brackets[r2] = -l;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : ch == 8204 ? 256 : 1;
}
var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
var BidiSpan = class {
  constructor(from, to, level) {
    this.from = from;
    this.to = to;
    this.level = level;
  }
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  static find(order, index, level, assoc) {
    let maybe = -1;
    for (let i = 0; i < order.length; i++) {
      let span = order[i];
      if (span.from <= index && span.to >= index) {
        if (span.level == level)
          return i;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
          maybe = i;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
};
var types = [];
function computeOrder(line, direction) {
  let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
  if (!line || outerType == 1 && !BidiRE.test(line))
    return trivialOrder(len);
  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
    let type = charType(line.charCodeAt(i));
    if (type == 512)
      type = prev;
    else if (type == 8 && prevStrong == 4)
      type = 16;
    types[i] = type == 4 ? 2 : type;
    if (type & 7)
      prevStrong = type;
    prev = type;
  }
  for (let i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {
    let type = types[i];
    if (type == 128) {
      if (i < len - 1 && prev == types[i + 1] && prev & 24)
        type = types[i] = prev;
      else
        types[i] = 256;
    } else if (type == 64) {
      let end = i + 1;
      while (end < len && types[end] == 64)
        end++;
      let replace = i && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
      for (let j = i; j < end; j++)
        types[j] = replace;
      i = end - 1;
    } else if (type == 8 && prevStrong == 1) {
      types[i] = 1;
    }
    prev = type;
    if (type & 7)
      prevStrong = type;
  }
  for (let i = 0, sI = 0, context = 0, ch, br, type; i < len; i++) {
    if (br = Brackets[ch = line.charCodeAt(i)]) {
      if (br < 0) {
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          if (BracketStack[sJ + 1] == -br) {
            let flags = BracketStack[sJ + 2];
            let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
            if (type2)
              types[i] = types[BracketStack[sJ]] = type2;
            sI = sJ;
            break;
          }
        }
      } else if (BracketStack.length == 189) {
        break;
      } else {
        BracketStack[sI++] = i;
        BracketStack[sI++] = ch;
        BracketStack[sI++] = context;
      }
    } else if ((type = types[i]) == 2 || type == 1) {
      let embed = type == outerType;
      context = embed ? 0 : 1;
      for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
        let cur = BracketStack[sJ + 2];
        if (cur & 2)
          break;
        if (embed) {
          BracketStack[sJ + 2] |= 2;
        } else {
          if (cur & 4)
            break;
          BracketStack[sJ + 2] |= 4;
        }
      }
    }
  }
  for (let i = 0; i < len; i++) {
    if (types[i] == 256) {
      let end = i + 1;
      while (end < len && types[end] == 256)
        end++;
      let beforeL = (i ? types[i - 1] : outerType) == 1;
      let afterL = (end < len ? types[end] : outerType) == 1;
      let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
      for (let j = i; j < end; j++)
        types[j] = replace;
      i = end - 1;
    }
  }
  let order = [];
  if (outerType == 1) {
    for (let i = 0; i < len; ) {
      let start2 = i, rtl = types[i++] != 1;
      while (i < len && rtl == (types[i] != 1))
        i++;
      if (rtl) {
        for (let j = i; j > start2; ) {
          let end = j, l = types[--j] != 2;
          while (j > start2 && l == (types[j - 1] != 2))
            j--;
          order.push(new BidiSpan(j, end, l ? 2 : 1));
        }
      } else {
        order.push(new BidiSpan(start2, i, 0));
      }
    }
  } else {
    for (let i = 0; i < len; ) {
      let start2 = i, rtl = types[i++] == 2;
      while (i < len && rtl == (types[i] == 2))
        i++;
      order.push(new BidiSpan(start2, i, rtl ? 1 : 2));
    }
  }
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
var movedOver = "";
function moveVisually(line, order, dir, start2, forward) {
  var _a;
  let startIndex = start2.head - line.from, spanI = -1;
  if (startIndex == 0) {
    if (!forward || !line.length)
      return null;
    if (order[0].level != dir) {
      startIndex = order[0].side(false, dir);
      spanI = 0;
    }
  } else if (startIndex == line.length) {
    if (forward)
      return null;
    let last = order[order.length - 1];
    if (last.level != dir) {
      startIndex = last.side(true, dir);
      spanI = order.length - 1;
    }
  }
  if (spanI < 0)
    spanI = BidiSpan.find(order, startIndex, (_a = start2.bidiLevel) !== null && _a !== void 0 ? _a : -1, start2.assoc);
  let span = order[spanI];
  if (startIndex == span.side(forward, dir)) {
    span = order[spanI += forward ? 1 : -1];
    startIndex = span.side(!forward, dir);
  }
  let indexForward = forward == (span.dir == dir);
  let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  if (nextIndex != span.side(forward, dir))
    return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (!nextSpan && span.level != dir)
    return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
  if (nextSpan && nextSpan.level < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos), linePos = pos - line.from;
  if (line.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line.length)
    bias = -1;
  let from = linePos, to = linePos;
  if (bias < 0)
    from = findClusterBreak(line.text, linePos, false);
  else
    to = findClusterBreak(line.text, linePos);
  let cat = categorize(line.text.slice(from, to));
  while (from > 0) {
    let prev = findClusterBreak(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat)
      break;
    from = prev;
  }
  while (to < line.length) {
    let next = findClusterBreak(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat)
      break;
    to = next;
  }
  return EditorSelection.range(from + line.from, to + line.from);
}
function getdx(x, rect) {
  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
  return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top2) {
  return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
  let closest, closestRect, closestX, closestY;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (closestRect && yOverlap(closestRect, rect))
        rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx = getdx(x, rect), dy = getdy(y, rect);
      if (dx == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect;
        closestX = dx;
        closestY = dy;
      }
      if (dx == 0) {
        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return { node: parent, offset: 0 };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y);
  if (!closestX && closest.contentEditable == "true")
    return domPosAtCoords(closest, clipX, y);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return { node: parent, offset };
}
function domPosInText(node, x, y) {
  let len = node.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i = 0; i < len; i++) {
    let rects = textRange(node, i, i + 1).getClientRects();
    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j];
      if (rect.top == rect.bottom)
        continue;
      if (!generalSide)
        generalSide = x - rect.left;
      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
        let right = x >= (rect.left + rect.right) / 2, after = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node, i).getBoundingClientRect();
          if (rectBefore.left == rect.right)
            after = !right;
        }
        if (dy <= 0)
          return { node, offset: i + (after ? 1 : 0) };
        closestOffset = i + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, { x, y }, precise, bias = -1) {
  let content2 = view.contentDOM.getBoundingClientRect(), block;
  let halfLine = view.defaultLineHeight / 2;
  for (let bounced = false; ; ) {
    block = view.blockAtHeight(y, content2.top);
    if (block.top > y || block.bottom < y) {
      bias = block.top > y ? -1 : 1;
      y = Math.min(block.bottom - halfLine, Math.max(block.top + halfLine, y));
      if (bounced)
        return precise ? null : 0;
      else
        bounced = true;
    }
    if (block.type == BlockType.Text)
      break;
    y = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
  }
  let lineStart = block.from;
  x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : posAtCoordsImprecise(view, content2, block, x, y);
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : posAtCoordsImprecise(view, content2, block, x, y);
  let root = view.root, element = root.elementFromPoint(x, y);
  let node, offset = -1;
  if (element && view.contentDOM.contains(element) && !(view.docView.nearest(element) instanceof WidgetView)) {
    if (root.caretPositionFromPoint) {
      let pos = root.caretPositionFromPoint(x, y);
      if (pos)
        ({ offsetNode: node, offset } = pos);
    } else if (root.caretRangeFromPoint) {
      let range = root.caretRangeFromPoint(x, y);
      if (range) {
        ({ startContainer: node, startOffset: offset } = range);
        if (browser.safari && isSuspiciousCaretResult(node, offset, x))
          node = void 0;
      }
    }
  }
  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart);
    ({ node, offset } = domPosAtCoords(line.dom, x, y));
  }
  return view.docView.posFromDOM(node, offset);
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let line = Math.floor((y - block.top) / view.defaultLineHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function isSuspiciousCaretResult(node, offset, x) {
  let len;
  if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
    return false;
  for (let next = node.nextSibling; next; next = next.nextSibling)
    if (next.nodeType != 1 || next.nodeName != "BR")
      return false;
  return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
function moveToLineBoundary(view, start2, forward, includeWrap) {
  let line = view.state.doc.lineAt(start2.head);
  let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start2.assoc < 0 && start2.head > line.from ? start2.head - 1 : start2.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let pos = view.posAtCoords({
      x: forward == (view.textDirection == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  let lineView = LineView.find(view.docView, start2.head);
  let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
  return EditorSelection.cursor(end, forward ? -1 : 1);
}
function moveByChar(view, start2, forward, by) {
  let line = view.state.doc.lineAt(start2.head), spans = view.bidiSpans(line);
  for (let cur = start2, check = null; ; ) {
    let next = moveVisually(line, spans, view.textDirection, cur, forward), char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1))
        return cur;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = EditorSelection.cursor(forward ? line.from : line.to);
    }
    if (!check) {
      if (!by)
        return next;
      check = by(char);
    } else if (!check(char)) {
      return cur;
    }
    cur = next;
  }
}
function byGroup(view, pos, start2) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start2);
  return (next) => {
    let nextCat = categorize(next);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start2, forward, distance) {
  let startPos = start2.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos);
  let goal = start2.goalColumn, startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos);
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineAt(startPos, view.dom.getBoundingClientRect().top);
    if (goal == null)
      goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = dir < 0 ? line.top : line.bottom;
  }
  let resolvedGoal = rect.left + goal;
  let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
      return EditorSelection.cursor(pos, void 0, void 0, goal);
  }
}
function skipAtoms(view, oldPos, pos) {
  let atoms = view.pluginField(PluginField.atomicRanges);
  for (; ; ) {
    let moved = false;
    for (let set of atoms) {
      set.between(pos.from - 1, pos.from + 1, (from, to, value) => {
        if (pos.from > from && pos.from < to) {
          pos = oldPos.from > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to, -1);
          moved = true;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
var InputState = class {
  constructor(view) {
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.pendingIOSKey = null;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastEscPress = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.registeredEvents = [];
    this.customHandlers = [];
    this.composing = -1;
    this.compositionEndedAt = 0;
    this.rapidCompositionStart = false;
    this.mouseSelection = null;
    for (let type in handlers) {
      let handler = handlers[type];
      view.contentDOM.addEventListener(type, (event) => {
        if (type == "keydown" && this.keydown(view, event))
          return;
        if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))
          return;
        if (this.mustFlushObserver(event))
          view.observer.forceFlush();
        if (this.runCustomHandlers(type, view, event))
          event.preventDefault();
        else
          handler(view, event);
      });
      this.registeredEvents.push(type);
    }
    this.notifiedFocused = view.hasFocus;
    this.ensureHandlers(view);
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  ensureHandlers(view) {
    let handlers2 = this.customHandlers = view.pluginField(domEventHandlers);
    for (let set of handlers2) {
      for (let type in set.handlers)
        if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
          this.registeredEvents.push(type);
          view.contentDOM.addEventListener(type, (event) => {
            if (!eventBelongsToEditor(view, event))
              return;
            if (this.runCustomHandlers(type, view, event))
              event.preventDefault();
          });
        }
    }
  }
  runCustomHandlers(type, view, event) {
    for (let set of this.customHandlers) {
      let handler = set.handlers[type], handled = false;
      if (handler) {
        try {
          handled = handler.call(set.plugin, event, view);
        } catch (e) {
          logException(view.state, e);
        }
        if (handled || event.defaultPrevented) {
          if (browser.android && type == "keydown" && event.keyCode == 13)
            view.observer.flushSoon();
          return true;
        }
      }
    }
    return false;
  }
  runScrollHandlers(view, event) {
    for (let set of this.customHandlers) {
      let handler = set.handlers.scroll;
      if (handler) {
        try {
          handler.call(set.plugin, event, view);
        } catch (e) {
          logException(view.state, e);
        }
      }
    }
  }
  keydown(view, event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (this.screenKeyEvent(view, event))
      return true;
    if (browser.ios && (event.keyCode == 13 || event.keyCode == 8) && !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {
      this.pendingIOSKey = event.keyCode == 13 ? "enter" : "backspace";
      setTimeout(() => this.flushIOSKey(view), 250);
      return true;
    }
    return false;
  }
  flushIOSKey(view) {
    if (!this.pendingIOSKey)
      return false;
    let dom = view.contentDOM, key = this.pendingIOSKey;
    this.pendingIOSKey = null;
    return key == "enter" ? dispatchKey(dom, "Enter", 13) : dispatchKey(dom, "Backspace", 8);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type))
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && Date.now() - this.compositionEndedAt < 500) {
      this.compositionEndedAt = 0;
      return true;
    }
    return false;
  }
  screenKeyEvent(view, event) {
    let protectedTab = event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3;
    if (event.keyCode == 27)
      this.lastEscPress = Date.now();
    else if (modifierCodes.indexOf(event.keyCode) < 0)
      this.lastEscPress = 0;
    return protectedTab;
  }
  mustFlushObserver(event) {
    return event.type == "keydown" && event.keyCode != 229 || event.type == "compositionend" && !browser.ios;
  }
  startMouseSelection(view, event, style) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = new MouseSelection(this, view, event, style);
  }
  update(update) {
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
};
var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
var MouseSelection = class {
  constructor(inputState, view, startEvent, style) {
    this.inputState = inputState;
    this.view = view;
    this.style = style;
    this.lastEvent = startEvent;
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragMove = dragMovesSelection(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) ? null : false;
    if (this.dragging === false) {
      startEvent.preventDefault();
      this.select(startEvent);
    }
  }
  move(event) {
    if (event.buttons == 0)
      return this.destroy();
    if (this.dragging !== false)
      return;
    this.select(this.lastEvent = event);
  }
  up(event) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event.preventDefault();
    this.destroy();
  }
  destroy() {
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.inputState.mouseSelection = null;
  }
  select(event) {
    let selection = this.style.get(event, this.extend, this.multiple);
    if (!selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
      this.view.dispatch({
        selection,
        annotations: Transaction.userEvent.of("pointerselection"),
        scrollIntoView: true
      });
  }
  update(update) {
    if (update.docChanged && this.dragging)
      this.dragging = this.dragging.map(update.changes);
    if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
};
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let { main } = view.state.selection;
  if (main.empty)
    return false;
  let sel = getSelection(view.root);
  if (sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
    if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
      return false;
  return true;
}
var handlers = /* @__PURE__ */ Object.create(null);
var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function doPaste(view, input) {
  let { state } = view, changes, i = 1, text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy && state.selection.ranges.every((r2) => r2.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range) => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine)
        return { range };
      lastLine = line.from;
      let insert2 = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
      return {
        changes: { from: line.from, insert: insert2 },
        range: EditorSelection.cursor(range.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range) => {
      let line = text.line(i++);
      return {
        changes: { from: range.from, to: range.to, insert: line.text },
        range: EditorSelection.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    annotations: Transaction.userEvent.of("paste"),
    scrollIntoView: true
  });
}
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("keyboardselection");
};
var lastTouch = 0;
handlers.touchstart = (view, e) => {
  lastTouch = Date.now();
  view.inputState.setSelectionOrigin("pointerselection");
};
handlers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("pointerselection");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (lastTouch > Date.now() - 2e3)
    return;
  let style = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style = makeStyle(view, event);
    if (style)
      break;
  }
  if (!style && event.button == 0)
    style = basicMouseSelection(view, event);
  if (style) {
    if (view.root.activeElement != view.contentDOM)
      view.observer.ignore(() => focusPreventScroll(view.contentDOM));
    view.inputState.startMouseSelection(view, event, style);
  }
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to)
      to++;
    return EditorSelection.range(from, to);
  }
}
var insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
var inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
function findPositionSide(view, pos, x, y) {
  let line = LineView.find(view.docView, pos);
  if (!line)
    return 1;
  let off = pos - line.posAtStart;
  if (off == 0)
    return 1;
  if (off == line.length)
    return -1;
  let before = line.coordsAt(off, -1);
  if (before && inside(x, y, before))
    return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x, y, after))
    return 1;
  return before && insideY(y, before) ? -1 : 1;
}
function queryPos(view, event) {
  let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
  return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
var BadMouseDetail = browser.ie && browser.ie_version <= 11;
var lastMouseDown = null;
var lastMouseDownCount = 0;
var lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail)
    return event.detail;
  let last = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start2 = queryPos(view, event), type = getClickType(event);
  let startSel = view.state.selection;
  let last = start2, lastEvent = event;
  return {
    update(update) {
      if (update.changes) {
        if (start2)
          start2.pos = update.changes.mapPos(start2.pos);
        startSel = startSel.map(update.changes);
        lastEvent = null;
      }
    },
    get(event2, extend2, multiple) {
      let cur;
      if (lastEvent && event2.clientX == lastEvent.clientX && event2.clientY == lastEvent.clientY)
        cur = last;
      else {
        cur = last = queryPos(view, event2);
        lastEvent = event2;
      }
      if (!cur || !start2)
        return startSel;
      let range = rangeForClick(view, cur.pos, cur.bias, type);
      if (start2.pos != cur.pos && !extend2) {
        let startRange = rangeForClick(view, start2.pos, start2.bias, type);
        let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
        range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
      }
      if (extend2)
        return startSel.replaceRange(startSel.main.extend(range.from, range.to));
      else if (multiple)
        return startSel.addRange(range);
      else
        return EditorSelection.create([range]);
    }
  };
}
handlers.dragstart = (view, event) => {
  let { selection: { main } } = view.state;
  let { mouseSelection } = view.inputState;
  if (mouseSelection)
    mouseSelection.dragging = main;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
    event.dataTransfer.effectAllowed = "copyMove";
  }
};
function dropText(view, event, text, direct) {
  let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY });
  if (dropPos == null || !text)
    return;
  event.preventDefault();
  let { mouseSelection } = view.inputState;
  let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
  let ins = { from: dropPos, insert: text };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    annotations: Transaction.userEvent.of("drop")
  });
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer || !view.state.facet(editable))
    return;
  let files = event.dataTransfer.files;
  if (files && files.length) {
    event.preventDefault();
    let text = Array(files.length), read = 0;
    let finishFile = () => {
      if (++read == files.length)
        dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
    };
    for (let i = 0; i < files.length; i++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text[i] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i]);
    }
  } else {
    dropText(view, event, event.dataTransfer.getData("Text"), true);
  }
};
handlers.paste = (view, event) => {
  if (!view.state.facet(editable))
    return;
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let text = data && data.getData("text/plain");
  if (text) {
    doPaste(view, text);
    event.preventDefault();
  } else {
    capturePaste(view);
  }
};
function captureCopy(view, text) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges = [], linewise = false;
  for (let range of state.selection.ranges)
    if (!range.empty) {
      content2.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from } of state.selection.ranges) {
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content2.push(line.text);
        ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return { text: content2.join(state.lineBreak), ranges, linewise };
}
var lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let { text, ranges, linewise } = copiedRange(view.state);
  if (!text)
    return;
  lastLinewiseCopy = linewise ? text : null;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/plain", text);
  } else {
    captureCopy(view, text);
  }
  if (event.type == "cut" && view.state.facet(editable))
    view.dispatch({
      changes: ranges,
      scrollIntoView: true,
      annotations: Transaction.userEvent.of("cut")
    });
};
handlers.focus = handlers.blur = (view) => {
  setTimeout(() => {
    if (view.hasFocus != view.inputState.notifiedFocused)
      view.update([]);
  }, 10);
};
handlers.beforeprint = (view) => {
  view.viewState.printing = true;
  view.requestMeasure();
  setTimeout(() => {
    view.viewState.printing = false;
    view.requestMeasure();
  }, 2e3);
};
function forceClearComposition(view, rapid) {
  if (view.docView.compositionDeco.size) {
    view.inputState.rapidCompositionStart = rapid;
    try {
      view.update([]);
    } finally {
      view.inputState.rapidCompositionStart = false;
    }
  }
}
handlers.compositionstart = handlers.compositionupdate = (view) => {
  if (view.inputState.composing < 0) {
    if (view.docView.compositionDeco.size) {
      view.observer.flush();
      forceClearComposition(view, true);
    }
    view.inputState.composing = 0;
  }
};
handlers.compositionend = (view) => {
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  setTimeout(() => {
    if (view.inputState.composing < 0)
      forceClearComposition(view, false);
  }, 50);
};
handlers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line"];
var HeightOracle = class {
  constructor() {
    this.doc = Text.empty;
    this.lineWrapping = false;
    this.direction = Direction.LTR;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.lineLength = 30;
    this.heightChanged = false;
  }
  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping)
      lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefresh(lineHeights, whiteSpace, direction) {
    let newHeight = false;
    for (let i = 0; i < lineHeights.length; i++) {
      let h = lineHeights[i];
      if (h < 0) {
        i++;
      } else if (!this.heightSamples[Math.floor(h * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return newHeight || wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping || this.direction != direction;
  }
  refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping || this.direction != direction;
    this.lineWrapping = lineWrapping;
    this.direction = direction;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i = 0; i < knownHeights.length; i++) {
        let h = knownHeights[i];
        if (h < 0)
          i++;
        else
          this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return changed;
  }
};
var MeasuredHeights = class {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
};
var BlockInfo = class {
  constructor(from, length, top2, height, type) {
    this.from = from;
    this.length = length;
    this.top = top2;
    this.height = height;
    this.type = type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  join(other) {
    let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
  }
};
var QueryType = /* @__PURE__ */ function(QueryType2) {
  QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
  QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
  QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType2;
}(QueryType || (QueryType = {}));
var Epsilon = 1e-4;
var HeightMap = class {
  constructor(length, height, flags = 2) {
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(oracle, height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon)
        oracle.heightChanged = true;
      this.height = height;
    }
  }
  replace(_from, _to, nodes) {
    return HeightMap.of(nodes);
  }
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this;
    for (let i = changes.length - 1; i >= 0; i--) {
      let { fromA, toA, fromB, toB } = changes[i];
      let start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      let end = start2.to >= toA ? start2 : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i > 0 && start2.from <= changes[i - 1].toA) {
        fromA = changes[i - 1].fromA;
        fromB = changes[i - 1].fromB;
        i--;
        if (fromA < start2.from)
          start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      }
      fromB += start2.from - fromA;
      fromA = start2.from;
      let nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
      me = me.replace(fromA, toA, nodes);
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i = 0, j = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i == j) {
        if (before > after * 2) {
          let split = nodes[i - 1];
          if (split.break)
            nodes.splice(--i, 1, split.left, null, split.right);
          else
            nodes.splice(--i, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break)
            nodes.splice(j, 1, split.left, null, split.right);
          else
            nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i++];
        if (next)
          before += next.size;
      } else {
        let next = nodes[--j];
        if (next)
          after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i - 1] == null) {
      brk = 1;
      i--;
    } else if (nodes[i] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
  }
};
HeightMap.prototype.size = 1;
var HeightMapBlock = class extends HeightMap {
  constructor(length, height, type) {
    super(length, height);
    this.type = type;
  }
  blockAt(_height, _doc, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.type);
  }
  lineAt(_value, _type, doc2, top2, offset) {
    return this.blockAt(0, doc2, top2, offset);
  }
  forEachLine(_from, _to, doc2, top2, offset, f) {
    f(this.blockAt(0, doc2, top2, offset));
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
};
var HeightMapText = class extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, BlockType.Text);
    this.collapsed = 0;
    this.widgetHeight = 0;
  }
  replace(_from, _to, nodes) {
    let node = nodes[0];
    if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap)
        node = new HeightMapText(node.length, this.height);
      else
        node.height = this.height;
      if (!this.outdated)
        node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    else if (force || this.outdated)
      this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
};
var HeightMapGap = class extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  lines(doc2, offset) {
    let firstLine = doc2.lineAt(offset).number, lastLine = doc2.lineAt(offset + this.length).number;
    return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };
  }
  blockAt(height, doc2, top2, offset) {
    let { firstLine, lastLine, lineHeight } = this.lines(doc2, offset);
    let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / lineHeight)));
    let { from, length } = doc2.line(firstLine + line);
    return new BlockInfo(from, length, top2 + lineHeight * line, lineHeight, BlockType.Text);
  }
  lineAt(value, type, doc2, top2, offset) {
    if (type == QueryType.ByHeight)
      return this.blockAt(value, doc2, top2, offset);
    if (type == QueryType.ByPosNoHeight) {
      let { from: from2, to } = doc2.lineAt(value);
      return new BlockInfo(from2, to - from2, 0, 0, BlockType.Text);
    }
    let { firstLine, lineHeight } = this.lines(doc2, offset);
    let { from, length, number: number2 } = doc2.lineAt(value);
    return new BlockInfo(from, length, top2 + lineHeight * (number2 - firstLine), lineHeight, BlockType.Text);
  }
  forEachLine(from, to, doc2, top2, offset, f) {
    let { firstLine, lineHeight } = this.lines(doc2, offset);
    for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end; ) {
      let line = doc2.lineAt(pos);
      if (pos == from)
        top2 += lineHeight * (line.number - firstLine);
      f(new BlockInfo(line.from, line.length, top2, lineHeight, BlockType.Text));
      top2 += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof HeightMapGap)
        nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
      else
        nodes.push(null, new HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof HeightMapGap)
        nodes[0] = new HeightMapGap(from + first.length);
      else
        nodes.unshift(new HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result) {
    result.push(new HeightMapGap(to - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from);
      if (measured.from > offset)
        nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let line = new HeightMapText(len, measured.heights[measured.index++]);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end)
        nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
      oracle.heightChanged = true;
      return HeightMap.of(nodes);
    } else if (force || this.outdated) {
      this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
};
var HeightMapBranch = class extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, doc2, top2, offset) {
    let mid = top2 + this.left.height;
    return height < mid || this.right.height == 0 ? this.left.blockAt(height, doc2, top2, offset) : this.right.blockAt(height, doc2, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type, doc2, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop || this.right.height == 0 : value < rightOffset;
    let base2 = left ? this.left.lineAt(value, type, doc2, top2, offset) : this.right.lineAt(value, type, doc2, rightTop, rightOffset);
    if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left)
      return base2.join(this.right.lineAt(rightOffset, subQuery, doc2, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, doc2, top2, offset).join(base2);
  }
  forEachLine(from, to, doc2, top2, offset, f) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset)
        this.left.forEachLine(from, to, doc2, top2, offset, f);
      if (to >= rightOffset)
        this.right.forEachLine(from, to, doc2, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, doc2, top2, offset);
      if (from < mid.from)
        this.left.forEachLine(from, mid.from - 1, doc2, top2, offset, f);
      if (mid.to >= from && mid.from <= to)
        f(mid);
      if (to > mid.to)
        this.right.forEachLine(mid.to + 1, to, doc2, rightTop, rightOffset, f);
    }
  }
  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart)
      return this.balanced(this.left.replace(from, to, nodes), this.right);
    if (from > this.left.length)
      return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
    let result = [];
    if (from > 0)
      this.decomposeLeft(from, result);
    let left = result.length;
    for (let node of nodes)
      result.push(node);
    if (from > 0)
      mergeGaps(result, left - 1);
    if (to < this.length) {
      let right = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to, result) {
    let left = this.left.length;
    if (to <= left)
      return this.left.decomposeLeft(to, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to >= left)
        result.push(null);
    }
    if (to > left)
      this.right.decomposeLeft(to - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length, right = left + this.break;
    if (from >= right)
      return this.right.decomposeRight(from - right, result);
    if (from < left)
      this.left.decomposeRight(from, result);
    if (this.break && from < right)
      result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size)
      return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = left;
    this.right = right;
    this.height = left.height + right.height;
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more)
      rebalance = left = left.updateHeight(oracle, offset, force, measured);
    else
      left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more)
      rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
    else
      right.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
var relevantWidgetHeight = 5;
var NodeBuilder = class {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText)
        last.length += end - this.pos;
      else if (end > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;
      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? Math.max(0, deco.widget.estimatedHeight) : 0;
      let len = to - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco.type));
      } else if (len || height >= relevantWidgetHeight) {
        this.addLineDeco(height, len);
      }
    } else if (to > from) {
      this.span(from, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from, to } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from)
      this.nodes.push(new HeightMapText(this.pos - from, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from, to) {
    let gap = new HeightMapGap(to - from);
    if (this.oracle.doc.lineAt(from).to == to)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText)
      return last;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    if (block.type == BlockType.WidgetAfter && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (block.type != BlockType.WidgetBefore)
      this.covering = block;
  }
  addLineDeco(height, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (let node of this.nodes) {
      if (node instanceof HeightMapText)
        node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }
    return this.nodes;
  }
  static build(oracle, decorations2, from, to) {
    let builder = new NodeBuilder(from, oracle);
    RangeSet.spans(decorations2, from, to, builder, 0);
    return builder.finish(from);
  }
};
function heightRelevantDecoChanges(a, b, diff) {
  let comp = new DecorationComparator();
  RangeSet.compare(a, b, diff, comp, 0);
  return comp.changes;
}
var DecorationComparator = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from, to, a, b) {
    if (from < to || a && a.heightRelevant || b && b.heightRelevant)
      addRange(from, to, this.changes, 5);
  }
};
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);
  let top2 = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent; ) {
    if (parent.nodeType == 1) {
      let style = window.getComputedStyle(parent);
      if ((parent.scrollHeight > parent.clientHeight || parent.scrollWidth > parent.clientWidth) && style.overflow != "visible") {
        let parentRect = parent.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom = Math.min(bottom, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? parent.offsetParent : parent.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: right - rect.left,
    top: top2 - (rect.top + paddingTop),
    bottom: bottom - (rect.top + paddingTop)
  };
}
var LineGap = class {
  constructor(from, to, size) {
    this.from = from;
    this.to = to;
    this.size = size;
  }
  static same(a, b) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      let gA = a[i], gB = b[i];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(wrapping) {
    return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
  }
};
var LineGapWidget = class extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
};
var ViewState = class {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentWidth = 0;
    this.heightOracle = new HeightOracle();
    this.scaler = IdScaler;
    this.scrollTo = null;
    this.printing = false;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    this.heightMap = HeightMap.empty().applyChanges(state.facet(decorations), Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    this.viewport = this.getViewport(0, null);
    this.updateForViewport();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let pos = i ? main.head : main.anchor;
      if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
        let { from, to } = this.lineAt(pos, 0);
        viewports.push(new Viewport(from, to));
      }
    }
    this.viewports = viewports.sort((a, b) => a.from - b.from);
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
  }
  update(update, scrollTo = null) {
    let prev = this.state;
    this.state = update.state;
    let newDeco = this.state.facet(decorations);
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(update.startState.facet(decorations), newDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight)
      update.flags |= 2;
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTo && (scrollTo.head < viewport.from || scrollTo.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTo);
    if (!viewport.eq(this.viewport)) {
      this.viewport = viewport;
      update.flags |= 4;
    }
    this.updateForViewport();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15e3)
      update.flags |= this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    this.computeVisibleRanges();
    if (scrollTo)
      this.scrollTo = scrollTo;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc)
      this.mustEnforceCursorAssoc = true;
  }
  measure(docView, repeated) {
    let dom = docView.dom, whiteSpace = "", direction = Direction.LTR;
    if (!repeated) {
      let style = window.getComputedStyle(dom);
      whiteSpace = style.whiteSpace, direction = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      this.paddingTop = parseInt(style.paddingTop) || 0;
      this.paddingBottom = parseInt(style.paddingBottom) || 0;
    }
    let pixelViewport = this.printing ? { top: -1e8, bottom: 1e8, left: -1e8, right: 1e8 } : visiblePixelRange(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    this.inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (!this.inView)
      return 0;
    let lineHeights = docView.measureVisibleLineHeights();
    let refresh = false, bias = 0, result = 0, oracle = this.heightOracle;
    if (!repeated) {
      let contentWidth = docView.dom.clientWidth;
      if (oracle.mustRefresh(lineHeights, whiteSpace, direction) || oracle.lineWrapping && Math.abs(contentWidth - this.contentWidth) > oracle.charWidth) {
        let { lineHeight, charWidth } = docView.measureTextSize();
        refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
        if (refresh) {
          docView.minWidth = 0;
          result |= 16;
        }
      }
      if (this.contentWidth != contentWidth) {
        this.contentWidth = contentWidth;
        result |= 16;
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
    }
    oracle.heightChanged = false;
    this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));
    if (oracle.heightChanged)
      result |= 2;
    if (!this.viewportIsAppropriate(this.viewport, bias) || this.scrollTo && (this.scrollTo.head < this.viewport.from || this.scrollTo.head > this.viewport.to)) {
      let newVP = this.getViewport(bias, this.scrollTo);
      if (newVP.from != this.viewport.from || newVP.to != this.viewport.to) {
        this.viewport = newVP;
        result |= 4;
      }
    }
    this.updateForViewport();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 15e3)
      result |= this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));
    this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top, 0);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom, 0);
  }
  getViewport(bias, scrollTo) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map = this.heightMap, doc2 = this.state.doc, { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, doc2, 0, 0).to);
    if (scrollTo) {
      if (scrollTo.head < viewport.from) {
        let { top: newTop } = map.lineAt(scrollTo.head, QueryType.ByPos, doc2, 0, 0);
        viewport = new Viewport(map.lineAt(newTop - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(newTop + (visibleBottom - visibleTop) + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
      } else if (scrollTo.head > viewport.to) {
        let { bottom: newBottom } = map.lineAt(scrollTo.head, QueryType.ByPos, doc2, 0, 0);
        viewport = new Viewport(map.lineAt(newBottom - (visibleBottom - visibleTop) - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(newBottom + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
  }
  viewportIsAppropriate({ from, to }, bias = 0) {
    let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
    let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
    return mapped;
  }
  ensureLineGaps(current) {
    let gaps = [];
    if (this.heightOracle.direction != Direction.LTR)
      return gaps;
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (line) => {
      if (line.length < 1e4)
        return;
      let structure = lineStructure(line.from, line.to, this.state);
      if (structure.total < 1e4)
        return;
      let viewFrom, viewTo;
      if (this.heightOracle.lineWrapping) {
        if (line.from != this.viewport.from)
          viewFrom = line.from;
        else
          viewFrom = findPosition(structure, (this.visibleTop - line.top) / line.height);
        if (line.to != this.viewport.to)
          viewTo = line.to;
        else
          viewTo = findPosition(structure, (this.visibleBottom - line.top) / line.height);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        viewFrom = findPosition(structure, this.pixelViewport.left / totalWidth);
        viewTo = findPosition(structure, this.pixelViewport.right / totalWidth);
      }
      let sel = this.state.selection.main;
      if (sel.from <= viewFrom && sel.to >= line.from)
        viewFrom = sel.from;
      if (sel.from <= line.to && sel.to >= viewTo)
        viewTo = sel.to;
      let gapTo = viewFrom - 1e4, gapFrom = viewTo + 1e4;
      if (gapTo > line.from + 5e3)
        gaps.push(find(current, (gap) => gap.from == line.from && gap.to > gapTo - 5e3 && gap.to < gapTo + 5e3) || new LineGap(line.from, gapTo, this.gapSize(line, gapTo, true, structure)));
      if (gapFrom < line.to - 5e3)
        gaps.push(find(current, (gap) => gap.to == line.to && gap.from > gapFrom - 5e3 && gap.from < gapFrom + 5e3) || new LineGap(gapFrom, line.to, this.gapSize(line, gapFrom, false, structure)));
    });
    return gaps;
  }
  gapSize(line, pos, start2, structure) {
    if (this.heightOracle.lineWrapping) {
      let height = line.height * findFraction(structure, pos);
      return start2 ? height : line.height - height;
    } else {
      let ratio = findFraction(structure, pos);
      return structure.total * this.heightOracle.charWidth * (start2 ? ratio : 1 - ratio);
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
      return 8;
    }
    return 0;
  }
  computeVisibleRanges() {
    let deco = this.state.facet(decorations);
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to) {
        ranges.push({ from, to });
      },
      point() {
      }
    }, 20);
    this.visibleRanges = ranges;
  }
  lineAt(pos, editorTop) {
    editorTop += this.paddingTop;
    return scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, editorTop, 0), this.scaler, editorTop);
  }
  lineAtHeight(height, editorTop) {
    editorTop += this.paddingTop;
    return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height, editorTop), QueryType.ByHeight, this.state.doc, editorTop, 0), this.scaler, editorTop);
  }
  blockAtHeight(height, editorTop) {
    editorTop += this.paddingTop;
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height, editorTop), this.state.doc, editorTop, 0), this.scaler, editorTop);
  }
  forEachLine(from, to, f, editorTop) {
    editorTop += this.paddingTop;
    return this.heightMap.forEachLine(from, to, this.state.doc, editorTop, 0, this.scaler.scale == 1 ? f : (b) => f(scaleBlock(b, this.scaler, editorTop)));
  }
  get contentHeight() {
    return this.domHeight + this.paddingTop + this.paddingBottom;
  }
  get domHeight() {
    return this.scaler.toDOM(this.heightMap.height, this.paddingTop);
  }
};
var Viewport = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
  eq(b) {
    return this.from == b.from && this.to == b.to;
  }
};
function lineStructure(from, to, state) {
  let ranges = [], pos = from, total = 0;
  RangeSet.spans(state.facet(decorations), from, to, {
    span() {
    },
    point(from2, to2) {
      if (from2 > pos) {
        ranges.push({ from: pos, to: from2 });
        total += from2 - pos;
      }
      pos = to2;
    }
  }, 20);
  if (pos < to) {
    ranges.push({ from: pos, to });
    total += to - pos;
  }
  return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
  if (ratio <= 0)
    return ranges[0].from;
  if (ratio >= 1)
    return ranges[ranges.length - 1].to;
  let dist = Math.floor(total * ratio);
  for (let i = 0; ; i++) {
    let { from, to } = ranges[i], size = to - from;
    if (dist <= size)
      return from + dist;
    dist -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from, to } of structure.ranges) {
    if (pos <= to) {
      counted += pos - from;
      break;
    }
    counted += to - from;
  }
  return counted / structure.total;
}
function find(array, f) {
  for (let val of array)
    if (f(val))
      return val;
  return void 0;
}
var IdScaler = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1
};
var BigScaler = class {
  constructor(doc2, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from, to }) => {
      let top2 = heightMap.lineAt(from, QueryType.ByPos, doc2, 0, 0).top;
      let bottom = heightMap.lineAt(to, QueryType.ByPos, doc2, 0, 0).bottom;
      vpHeight += bottom - top2;
      return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n, top2) {
    n -= top2;
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.top)
        return domBase + (n - base2) * this.scale + top2;
      if (n <= vp.bottom)
        return vp.domTop + (n - vp.top) + top2;
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n, top2) {
    n -= top2;
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.domTop)
        return base2 + (n - domBase) / this.scale + top2;
      if (n <= vp.domBottom)
        return vp.top + (n - vp.domTop) + top2;
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
};
function scaleBlock(block, scaler, top2) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top, top2), bBottom = scaler.toDOM(block.bottom, top2);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler, top2)) : block.type);
}
var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
var baseThemeID = /* @__PURE__ */ StyleModule.newName();
var baseLightID = /* @__PURE__ */ StyleModule.newName();
var baseDarkID = /* @__PURE__ */ StyleModule.newName();
var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
        if (m == "&")
          return main;
        if (!scopes || !scopes[m])
          throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main + " " + sel;
    }
  });
}
var baseTheme = /* @__PURE__ */ buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    minHeight: "100%",
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none"
  },
  ".cm-lineWrapping": {
    whiteSpace: "pre-wrap",
    wordBreak: "break-word",
    overflowWrap: "anywhere"
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 4px"
  },
  ".cm-selectionLayer": {
    zIndex: -1,
    contain: "size style"
  },
  ".cm-selectionBackground": {
    position: "absolute"
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    zIndex: 100,
    contain: "size style",
    pointerEvents: "none"
  },
  "&.cm-focused .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  "@keyframes cm-blink": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
  ".cm-cursor": {
    position: "absolute",
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none",
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  "&.cm-focused .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#f3f9ff" },
  "&dark .cm-activeLine": { backgroundColor: "#223039" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "3px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
var observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  characterDataOldValue: true
};
var useCharData = browser.ie && browser.ie_version <= 11;
var DOMObserver = class {
  constructor(view, onChange, onScrollChanged) {
    this.view = view;
    this.onChange = onChange;
    this.onScrollChanged = onScrollChanged;
    this.active = false;
    this.ignoreSelection = new DOMSelection();
    this.delayedFlush = -1;
    this.queue = [];
    this.lastFlush = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.intersecting = false;
    this._selectionRange = null;
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      this._selectionRange = null;
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData)
      this.onCharData = (event) => {
        this.queue.push({
          target: event.target,
          type: "characterData",
          oldValue: event.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.start();
    this.onScroll = this.onScroll.bind(this);
    window.addEventListener("scroll", this.onScroll);
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, {});
      this.intersection.observe(this.dom);
    }
    this.listenForScroll();
  }
  onScroll(e) {
    if (this.intersecting)
      this.flush();
    this.onScrollChanged(e);
  }
  onSelectionChange(event) {
    if (this.lastFlush < Date.now() - 50)
      this._selectionRange = null;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event))
      return;
    if (browser.ie && browser.ie_version <= 11 && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush();
  }
  get selectionRange() {
    if (!this._selectionRange) {
      let { root } = this.view, sel = getSelection(root);
      if (browser.safari && root.nodeType == 11 && deepActiveElement() == this.view.contentDOM)
        sel = safariSelectionRangeHack(this.view) || sel;
      this._selectionRange = sel;
    }
    return this._selectionRange;
  }
  setSelectionRange(anchor, head) {
    var _a;
    if (!((_a = this._selectionRange) === null || _a === void 0 ? void 0 : _a.type))
      this._selectionRange = {
        anchorNode: anchor.node,
        anchorOffset: anchor.offset,
        focusNode: head.node,
        focusOffset: head.offset
      };
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
          i++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f) {
    if (!this.active)
      return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    this.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    this.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  clearSelection() {
    this.ignoreSelection.set(this.selectionRange);
  }
  clear() {
    this.observer.takeRecords();
    this.queue.length = 0;
    this.clearSelection();
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = window.setTimeout(() => {
        this.delayedFlush = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      window.clearTimeout(this.delayedFlush);
      this.delayedFlush = -1;
      this.flush();
    }
  }
  flush() {
    if (this.delayedFlush >= 0)
      return;
    this.lastFlush = Date.now();
    let records = this.queue;
    for (let mut of this.observer.takeRecords())
      records.push(mut);
    if (records.length)
      this.queue = [];
    let selection = this.selectionRange;
    let newSel = !this.ignoreSelection.eq(selection) && hasSelection(this.dom, selection);
    if (records.length == 0 && !newSel)
      return;
    let from = -1, to = -1, typeOver = false;
    for (let record of records) {
      let range = this.readMutation(record);
      if (!range)
        continue;
      if (range.typeOver)
        typeOver = true;
      if (from == -1) {
        ({ from, to } = range);
      } else {
        from = Math.min(range.from, from);
        to = Math.max(range.to, to);
      }
    }
    let startState = this.view.state;
    if (from > -1 || newSel)
      this.onChange(from, to, typeOver);
    if (this.view.state == startState) {
      if (this.view.docView.dirty) {
        this.ignore(() => this.view.docView.sync());
        this.view.docView.dirty = 0;
      }
      if (newSel)
        this.view.docView.updateSelection();
    }
    this.clearSelection();
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec))
      return null;
    cView.markDirty();
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else {
      return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    }
  }
  destroy() {
    this.stop();
    if (this.intersection)
      this.intersection.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    window.removeEventListener("scroll", this.onScroll);
    clearTimeout(this.parentCheck);
  }
};
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function safariSelectionRangeHack(view) {
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  if (!found)
    return null;
  let anchorNode = found.startContainer, anchorOffset = found.startOffset;
  let focusNode = found.endContainer, focusOffset = found.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function applyDOMChange(view, start2, end, typeOver) {
  let change, newSel;
  let sel = view.state.selection.main, bounds;
  if (start2 > -1 && (bounds = view.docView.domBoundsAround(start2, end, 0))) {
    let { from, to } = bounds;
    let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);
    let reader = new DOMReader(selPoints, view);
    reader.readRange(bounds.startDOM, bounds.endDOM);
    newSel = selectionFromPoints(selPoints, from);
    let preferredPos = sel.from, preferredSide = null;
    if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && reader.text.length < to - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.sliceDoc(from, to), reader.text, preferredPos - from, preferredSide);
    if (diff)
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: view.state.toText(reader.text.slice(diff.from, diff.toB))
      };
  } else if (view.hasFocus || !view.state.facet(editable)) {
    let domSel = view.observer.selectionRange;
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
    let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (head != sel.head || anchor != sel.anchor)
      newSel = EditorSelection.single(anchor, head);
  }
  if (!change && !newSel)
    return;
  if (!change && typeOver && !sel.empty && newSel && newSel.main.empty)
    change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4)
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  if (change) {
    let startState = view.state;
    if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)) || browser.ios && view.inputState.flushIOSKey(view))
      return;
    let text = change.insert.toString();
    if (view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text)))
      return;
    if (view.inputState.composing >= 0)
      view.inputState.composing++;
    let tr;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length)) {
      let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
      let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
      tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
    } else {
      let changes = startState.changes(change);
      tr = {
        changes,
        selection: newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? startState.selection.replaceRange(newSel.main) : void 0
      };
    }
    view.dispatch(tr, { scrollIntoView: true, annotations: Transaction.userEvent.of("input") });
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView = false, annotations;
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "keyboardselection")
        scrollIntoView = true;
      else
        annotations = Transaction.userEvent.of(view.inputState.lastSelectionOrigin);
    }
    view.dispatch({ selection: newSel, scrollIntoView, annotations });
  }
}
function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length);
  let from = 0;
  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
    from++;
  if (from == minLen && a.length == b.length)
    return null;
  let toA = a.length, toB = b.length;
  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a.length < b.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }
  return { from, toA, toB };
}
var DOMReader = class {
  constructor(points, view) {
    this.points = points;
    this.view = view;
    this.text = "";
    this.lineBreak = view.state.lineBreak;
  }
  readRange(start2, end) {
    if (!start2)
      return;
    let parent = start2.parentNode;
    for (let cur = start2; ; ) {
      this.findPointBefore(parent, cur);
      this.readNode(cur);
      let next = cur.nextSibling;
      if (next == end)
        break;
      let view = ContentView.get(cur), nextView = ContentView.get(next);
      if ((view ? view.breakAfter : isBlockElement(cur)) || (nextView ? nextView.breakAfter : isBlockElement(next)) && !(cur.nodeName == "BR" && !cur.cmIgnore))
        this.text += this.lineBreak;
      cur = next;
    }
    this.findPointBefore(parent, end);
  }
  readNode(node) {
    if (node.cmIgnore)
      return;
    let view = ContentView.get(node);
    let fromView = view && view.overrideDOMText;
    let text;
    if (fromView != null)
      text = fromView.sliceString(0, void 0, this.lineBreak);
    else if (node.nodeType == 3)
      text = node.nodeValue;
    else if (node.nodeName == "BR")
      text = node.nextSibling ? this.lineBreak : "";
    else if (node.nodeType == 1)
      this.readRange(node.firstChild, null);
    if (text != null) {
      this.findPointIn(node, text.length);
      this.text += text;
      if (browser.chrome && this.view.inputState.lastKeyCode == 13 && !node.nextSibling && /\n\n$/.test(this.text))
        this.text = this.text.slice(0, -1);
    }
  }
  findPointBefore(node, next) {
    for (let point of this.points)
      if (point.node == node && node.childNodes[point.offset] == next)
        point.pos = this.text.length;
  }
  findPointIn(node, maxLen) {
    for (let point of this.points)
      if (point.node == node)
        point.pos = this.text.length + Math.min(point.offset, maxLen);
  }
};
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
var DOMPoint = class {
  constructor(node, offset) {
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  }
};
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
}
var EditorView = class {
  constructor(config = {}) {
    this.plugins = [];
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.style.cssText = "position: absolute; top: -10000px";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    this._dispatch = config.dispatch || ((tr) => this.update([tr]));
    this.dispatch = this.dispatch.bind(this);
    this.root = config.root || document;
    this.viewState = new ViewState(config.state || EditorState.create());
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec).update(this));
    this.observer = new DOMObserver(this, (from, to, typeOver) => {
      applyDOMChange(this, from, to, typeOver);
    }, (event) => {
      this.inputState.runScrollHandlers(this, event);
      if (this.observer.intersecting)
        this.measure();
    });
    this.inputState = new InputState(this);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    ensureGlobalHandler();
    this.requestMeasure();
    if (config.parent)
      config.parent.appendChild(this.dom);
  }
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  dispatch(...input) {
    this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
  }
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, update;
    let state = this.state;
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = new ViewUpdate(this, state, transactions);
    let scrollTo;
    try {
      this.updateState = 2;
      scrollTo = transactions.some((tr) => tr.scrollIntoView) ? state.selection.main : null;
      this.viewState.update(update, scrollTo);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      this.updateAttrs();
      this.showAnnouncements(transactions);
    } finally {
      this.updateState = 0;
    }
    if (redrawn || scrollTo || this.viewState.mustEnforceCursorAssoc)
      this.requestMeasure();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener))
        listener(update);
  }
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    this.updateState = 2;
    try {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec).update(this));
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin = this.plugins[found];
          plugin.mustUpdate = update;
          newPlugins.push(plugin);
        }
      }
      for (let plugin of this.plugins)
        if (plugin.mustUpdate != update)
          plugin.destroy(this);
      this.plugins = newPlugins;
      this.inputState.ensureHandlers(this);
    } else {
      for (let p of this.plugins)
        p.mustUpdate = update;
    }
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i] = this.plugins[i].update(this);
  }
  measure(flush = true) {
    if (this.measureScheduled > -1)
      cancelAnimationFrame(this.measureScheduled);
    this.measureScheduled = -1;
    if (flush)
      this.observer.flush();
    let updated = null;
    try {
      for (let i = 0; ; i++) {
        this.updateState = 1;
        let changed = this.viewState.measure(this.docView, i > 0);
        let measuring = this.measureRequests;
        if (!changed && !measuring.length && this.viewState.scrollTo == null)
          break;
        this.measureRequests = [];
        if (i > 5) {
          console.warn("Viewport failed to stabilize");
          break;
        }
        let measured = measuring.map((m) => {
          try {
            return m.read(this);
          } catch (e) {
            logException(this.state, e);
            return BadMeasure;
          }
        });
        let update = new ViewUpdate(this, this.state);
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
        }
        this.updateAttrs();
        if (changed)
          this.docView.update(update);
        for (let i2 = 0; i2 < measuring.length; i2++)
          if (measured[i2] != BadMeasure) {
            try {
              measuring[i2].write(measured[i2], this);
            } catch (e) {
              logException(this.state, e);
            }
          }
        if (this.viewState.scrollTo) {
          this.docView.scrollPosIntoView(this.viewState.scrollTo.head, this.viewState.scrollTo.assoc);
          this.viewState.scrollTo = null;
        }
        if (!(changed & 4) && this.measureRequests.length == 0)
          break;
      }
    } finally {
      this.updateState = 0;
    }
    this.measureScheduled = -1;
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = combineAttrs(this.state.facet(editorAttributes), {
      class: "cm-editor cm-wrap" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    updateAttrs(this.dom, this.editorAttrs, editorAttrs);
    this.editorAttrs = editorAttrs;
    let contentAttrs = combineAttrs(this.state.facet(contentAttributes), {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      contenteditable: !this.state.facet(editable) ? "false" : contentEditablePlainTextSupported() ? "plaintext-only" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    });
    updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
    this.contentAttrs = contentAttrs;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = requestAnimationFrame(() => this.measure());
    if (request) {
      if (request.key != null)
        for (let i = 0; i < this.measureRequests.length; i++) {
          if (this.measureRequests[i].key === request.key) {
            this.measureRequests[i] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  pluginField(field) {
    let result = [];
    for (let plugin of this.plugins)
      plugin.update(this).takeField(field, result);
    return result;
  }
  plugin(plugin) {
    for (let inst of this.plugins)
      if (inst.spec == plugin)
        return inst.update(this).value;
    return null;
  }
  blockAtHeight(height, docTop) {
    this.readMeasured();
    return this.viewState.blockAtHeight(height, ensureTop(docTop, this.contentDOM));
  }
  visualLineAtHeight(height, docTop) {
    this.readMeasured();
    return this.viewState.lineAtHeight(height, ensureTop(docTop, this.contentDOM));
  }
  viewportLines(f, docTop) {
    let { from, to } = this.viewport;
    this.viewState.forEachLine(from, to, f, ensureTop(docTop, this.contentDOM));
  }
  visualLineAt(pos, docTop = 0) {
    return this.viewState.lineAt(pos, docTop);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(start2, forward, by) {
    return skipAtoms(this, start2, moveByChar(this, start2, forward, by));
  }
  moveByGroup(start2, forward) {
    return skipAtoms(this, start2, moveByChar(this, start2, forward, (initial) => byGroup(this, start2.head, initial)));
  }
  moveToLineBoundary(start2, forward, includeWrap = true) {
    return moveToLineBoundary(this, start2, forward, includeWrap);
  }
  moveVertically(start2, forward, distance) {
    return skipAtoms(this, start2, moveVertically(this, start2, forward, distance));
  }
  scrollPosIntoView(pos) {
    this.viewState.scrollTo = EditorSelection.cursor(pos);
    this.requestMeasure();
  }
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  posAtDOM(node, offset = 0) {
    return this.docView.posFromDOM(node, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right)
      return rect;
    let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.heightOracle.direction;
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(line) {
    if (line.length > MaxBidiLine)
      return trivialOrder(line.length);
    let dir = this.textDirection;
    for (let entry of this.bidiCache)
      if (entry.from == line.from && entry.dir == dir)
        return entry.order;
    let order = computeOrder(line.text, this.textDirection);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
    return order;
  }
  get hasFocus() {
    var _a;
    return (document.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  destroy() {
    for (let plugin of this.plugins)
      plugin.destroy(this);
    this.inputState.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      cancelAnimationFrame(this.measureScheduled);
  }
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  static theme(spec, options) {
    let prefix = StyleModule.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  static baseTheme(spec) {
    return Prec.fallback(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
};
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = /* @__PURE__ */ StateEffect.define();
var MaxBidiLine = 4096;
function ensureTop(given, dom) {
  return given == null ? dom.getBoundingClientRect().top : given;
}
var resizeDebounce = -1;
function ensureGlobalHandler() {
  window.addEventListener("resize", () => {
    if (resizeDebounce == -1)
      resizeDebounce = setTimeout(handleResize, 50);
  });
}
function handleResize() {
  resizeDebounce = -1;
  let found = document.querySelectorAll(".cm-content");
  for (let i = 0; i < found.length; i++) {
    let docView = ContentView.get(found[i]);
    if (docView)
      docView.editorView.requestMeasure();
  }
}
var BadMeasure = {};
var CachedOrder = class {
  constructor(from, to, dir, order) {
    this.from = from;
    this.to = to;
    this.dir = dir;
    this.order = order;
  }
  static update(cache, changes) {
    if (changes.empty)
      return cache;
    let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
      let entry = cache[i];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
    }
    return result;
  }
};
var currentPlatform = typeof navigator == "undefined" ? "key" : /* @__PURE__ */ /Mac/.test(navigator.platform) ? "mac" : /* @__PURE__ */ /Win/.test(navigator.platform) ? "win" : /* @__PURE__ */ /Linux|X11/.test(navigator.platform) ? "linux" : "key";
var CanHidePrimary = !browser.ios;
var themeSpec = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
if (CanHidePrimary)
  themeSpec[".cm-line"].caretColor = "transparent !important";
var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";

// node_modules/@codemirror/gutter/dist/index.js
var GutterMarker = class extends RangeValue {
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  eq(other) {
    return false;
  }
  at(pos) {
    return this.range(pos);
  }
};
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.point = true;
var gutterLineClass = /* @__PURE__ */ Facet.define();
var defaults = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => RangeSet.empty,
  lineMarker: () => null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
var activeGutters = /* @__PURE__ */ Facet.define();
function gutter(config) {
  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
}
var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-gutters": {
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#999",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    height: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  }
});
var unfixGutters = /* @__PURE__ */ Facet.define({
  combine: (values) => values.some((x) => x)
});
function gutters(config) {
  let result = [
    gutterView,
    baseTheme2
  ];
  if (config && config.fixed === false)
    result.push(unfixGutters.of(true));
  return result;
}
var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters";
    this.dom.setAttribute("aria-hidden", "true");
    this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
    for (let gutter2 of this.gutters)
      this.dom.appendChild(gutter2.dom);
    this.fixed = !view.state.facet(unfixGutters);
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    this.syncGutters();
  }
  update(update) {
    if (this.updateGutters(update))
      this.syncGutters();
  }
  syncGutters() {
    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport));
    this.view.viewportLines((line) => {
      let text;
      if (Array.isArray(line.type)) {
        for (let b of line.type)
          if (b.type == BlockType.Text) {
            text = b;
            break;
          }
      } else {
        text = line.type == BlockType.Text ? line : void 0;
      }
      if (!text)
        return;
      if (classSet.length)
        classSet = [];
      advanceCursor(lineClasses, classSet, line.from);
      for (let cx of contexts)
        cx.line(this.view, text, classSet);
    }, 0);
    for (let cx of contexts)
      cx.finish();
    this.dom.style.minHeight = this.view.contentHeight + "px";
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
    }
  }
  updateGutters(update) {
    let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
    if (prev == cur) {
      for (let gutter2 of this.gutters)
        if (gutter2.update(update))
          change = true;
    } else {
      change = true;
      let gutters2 = [];
      for (let conf of cur) {
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters2.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters2.push(this.gutters[known]);
        }
      }
      for (let g of this.gutters)
        g.dom.remove();
      for (let g of gutters2)
        this.dom.appendChild(g.dom);
      this.gutters = gutters2;
    }
    return change;
  }
  destroy() {
    this.dom.remove();
  }
}, {
  provide: /* @__PURE__ */ PluginField.scrollMargins.from((value) => {
    if (value.gutters.length == 0 || !value.fixed)
      return null;
    return value.view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };
  })
});
function asArray2(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor, collect, pos) {
  while (cursor.value && cursor.from <= pos) {
    if (cursor.from == pos)
      collect.push(cursor.value);
    cursor.next();
  }
}
var UpdateContext = class {
  constructor(gutter2, viewport) {
    this.gutter = gutter2;
    this.localMarkers = [];
    this.i = 0;
    this.height = 0;
    this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
  }
  line(view, line, extraMarkers) {
    if (this.localMarkers.length)
      this.localMarkers = [];
    advanceCursor(this.cursor, this.localMarkers, line.from);
    let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine)
      localMarkers.unshift(forLine);
    let gutter2 = this.gutter;
    if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
      return;
    let above = line.top - this.height;
    if (this.i == gutter2.elements.length) {
      let newElt = new GutterElement(view, line.height, above, localMarkers);
      gutter2.elements.push(newElt);
      gutter2.dom.appendChild(newElt.dom);
    } else {
      let elt = gutter2.elements[this.i];
      if (sameMarkers(localMarkers, elt.markers))
        localMarkers = elt.markers;
      elt.update(view, line.height, above, localMarkers);
    }
    this.height = line.bottom;
    this.i++;
  }
  finish() {
    let gutter2 = this.gutter;
    while (gutter2.elements.length > this.i)
      gutter2.dom.removeChild(gutter2.elements.pop().dom);
  }
};
var SingleGutterView = class {
  constructor(view, config) {
    this.view = view;
    this.config = config;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config.domEventHandlers) {
      this.dom.addEventListener(prop, (event) => {
        let line = view.visualLineAtHeight(event.clientY, view.contentDOM.getBoundingClientRect().top);
        if (config.domEventHandlers[prop](view, line, event))
          event.preventDefault();
      });
    }
    this.markers = asArray2(config.markers(view));
    if (config.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray2(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0])
        this.spacer.update(update.view, 0, 0, [updated]);
    }
    let vp = update.view.viewport;
    return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to);
  }
};
var GutterElement = class {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.dom = document.createElement("div");
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height)
      this.dom.style.height = (this.height = height) + "px";
    if (this.above != above)
      this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (this.markers != markers) {
      this.markers = markers;
      for (let ch; ch = this.dom.lastChild; )
        ch.remove();
      let cls = "cm-gutterElement";
      for (let m of markers) {
        if (m.toDOM)
          this.dom.appendChild(m.toDOM(view));
        let c = m.elementClass;
        if (c)
          cls += " " + c;
      }
      this.dom.className = cls;
    }
  }
};
function sameMarkers(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].compare(b[i]))
      return false;
  return true;
}
var lineNumberMarkers = /* @__PURE__ */ Facet.define();
var lineNumberConfig = /* @__PURE__ */ Facet.define({
  combine(values) {
    return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(a, b) {
        let result = Object.assign({}, a);
        for (let event in b) {
          let exists = result[event], add = b[event];
          result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add(view, line, event2) : add;
        }
        return result;
      }
    });
  }
});
var NumberMarker = class extends GutterMarker {
  constructor(number2) {
    super();
    this.number = number2;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM(_view) {
    return document.createTextNode(this.number);
  }
};
function formatNumber(view, number2) {
  return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
}
var lineNumberGutter = /* @__PURE__ */ gutter({
  class: "cm-lineNumbers",
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some((m) => m.toDOM))
      return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  }
});
function lineNumbers(config = {}) {
  return [
    lineNumberConfig.of(config),
    lineNumberGutter
  ];
}
function maxLineNumber(lines) {
  let last = 9;
  while (last < lines)
    last = last * 10 + 9;
  return last;
}

// node_modules/lezer-tree/dist/tree.es.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var CachedNode = new WeakMap();
var NodeProp = class {
  constructor({ deserialize } = {}) {
    this.id = nextPropID++;
    this.deserialize = deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  static string() {
    return new NodeProp({ deserialize: (str) => str });
  }
  static number() {
    return new NodeProp({ deserialize: Number });
  }
  static flag() {
    return new NodeProp({ deserialize: () => true });
  }
  set(propObj, value) {
    propObj[this.id] = value;
    return propObj;
  }
  add(match) {
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
var noProps = Object.create(null);
var NodeType = class {
  constructor(name2, props, id, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id;
    this.flags = flags;
  }
  static define(spec) {
    let props = spec.props && spec.props.length ? Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src)
          src[0].set(props, src[1]);
      }
    return type;
  }
  prop(prop) {
    return this.props[prop.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  static match(map) {
    let direct = Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType("", Object.create(null), 0, 8);
var NodeSet = class {
  constructor(types2) {
    this.types = types2;
    for (let i = 0; i < types2.length; i++)
      if (types2[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add = source(type);
        if (add) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          add[0].set(newProps, add[1]);
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new NodeSet(newTypes);
  }
};
var Tree = class {
  constructor(type, children, positions, length) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
  }
  toString() {
    let children = this.children.map((c) => c.toString()).join();
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  cursor(pos, side = 0) {
    let scope = pos != null && CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    if (pos != null) {
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
    }
    return cursor;
  }
  fullCursor() {
    return new TreeCursor(this.topNode, true);
  }
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  resolve(pos, side = 0) {
    return this.cursor(pos, side).node;
  }
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    for (let c = this.cursor(); ; ) {
      let mustLeave = false;
      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {
        if (c.firstChild())
          continue;
        if (!c.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(c.type, c.from, c.to);
        mustLeave = c.type.isAnonymous;
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        mustLeave = true;
      }
    }
  }
  balance(maxBufferLength = DefaultBufferLength) {
    return this.children.length <= BalanceBranchFactor ? this : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length, 0);
  }
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
function withHash(tree, hash) {
  if (hash)
    tree.contextHash = hash;
  return tree;
}
var TreeBuffer = class {
  constructor(buffer, length, set, type = NodeType.none) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
    this.type = type;
  }
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length; ) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  childString(index) {
    let id = this.buffer[index], endIndex = this.buffer[index + 3];
    let type = this.set.types[id], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index += 4;
    if (endIndex == index)
      return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  findChild(startIndex, endIndex, dir, after) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (after != -1e8) {
        let start2 = buffer[i + 1], end = buffer[i + 2];
        if (dir > 0) {
          if (end > after)
            pick = i;
          if (end > after)
            break;
        } else {
          if (start2 < after)
            pick = i;
          if (end >= after)
            break;
        }
      } else {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
};
var TreeNode = class {
  constructor(node, from, index, _parent) {
    this.node = node;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this.node.type;
  }
  get name() {
    return this.node.type.name;
  }
  get to() {
    return this.from + this.node.length;
  }
  nextChild(i, dir, after, full = false) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start2 = positions[i] + parent.from;
        if (after != -1e8 && (dir < 0 ? start2 >= after : start2 + next.length <= after))
          continue;
        if (next instanceof TreeBuffer) {
          let index = next.findChild(0, next.buffer.length, dir, after == -1e8 ? -1e8 : after - start2);
          if (index > -1)
            return new BufferNode(new BufferContext(parent, next, i, start2), null, index);
        } else if (full || (!next.type.isAnonymous || hasChild(next))) {
          let inner = new TreeNode(next, start2, i, parent);
          return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);
        }
      }
      if (full || !parent.type.isAnonymous)
        return null;
      i = parent.index + dir;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, -1e8);
  }
  get lastChild() {
    return this.nextChild(this.node.children.length - 1, -1, -1e8);
  }
  childAfter(pos) {
    return this.nextChild(0, 1, pos);
  }
  childBefore(pos) {
    return this.nextChild(this.node.children.length - 1, -1, pos);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;
  }
  get prevSibling() {
    return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;
  }
  get cursor() {
    return new TreeCursor(this);
  }
  resolve(pos, side = 0) {
    return this.cursor.moveTo(pos, side).node;
  }
  getChild(type, before = null, after = null) {
    let r2 = getChildren(this, type, before, after);
    return r2.length ? r2[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  toString() {
    return this.node.toString();
  }
};
function getChildren(node, type, before, after) {
  let cur = node.cursor, result = [];
  if (!cur.firstChild())
    return result;
  if (before != null) {
    while (!cur.type.is(before))
      if (!cur.nextSibling())
        return result;
  }
  for (; ; ) {
    if (after != null && cur.type.is(after))
      return result;
    if (cur.type.is(type))
      result.push(cur.node);
    if (!cur.nextSibling())
      return after == null ? result : [];
  }
}
var BufferContext = class {
  constructor(parent, buffer, index, start2) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start2;
  }
};
var BufferNode = class {
  constructor(context, _parent, index) {
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  child(dir, after) {
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -1e8 ? -1e8 : after - this.context.start);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(1, -1e8);
  }
  get lastChild() {
    return this.child(-1, -1e8);
  }
  childAfter(pos) {
    return this.child(1, pos);
  }
  childBefore(pos) {
    return this.child(-1, pos);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -1e8));
  }
  get cursor() {
    return new TreeCursor(this);
  }
  resolve(pos, side = 0) {
    return this.cursor.moveTo(pos, side).node;
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(type, before = null, after = null) {
    let r2 = getChildren(this, type, before, after);
    return r2.length ? r2[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
};
var TreeCursor = class {
  constructor(node, full = false) {
    this.full = full;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  get name() {
    return this.type.name;
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index, type) {
    this.index = index;
    let { start: start2, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start2 + buffer.buffer[index + 1];
    this.to = start2 + buffer.buffer[index + 2];
    return true;
  }
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enter(dir, after) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));
    let { buffer } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -1e8 ? -1e8 : after - this.buffer.start);
    if (index < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  firstChild() {
    return this.enter(1, -1e8);
  }
  lastChild() {
    return this.enter(-1, -1e8);
  }
  childAfter(pos) {
    return this.enter(1, pos);
  }
  childBefore(pos) {
    return this.enter(-1, pos);
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -1e8, this.full));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -1e8));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -1e8, this.full)) : false;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index, parent } = buffer);
    } else {
      ({ index, _parent: parent } = this._tree);
    }
    for (; parent; { index, _parent: parent } = parent) {
      for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {
        let child = parent.node.children[i];
        if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child))
          return false;
      }
    }
    return true;
  }
  move(dir) {
    if (this.enter(dir, -1e8))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  next() {
    return this.move(1);
  }
  prev() {
    return this.move(-1);
  }
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    for (; ; ) {
      if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos))
        break;
      if (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) {
        this.parent();
        break;
      }
    }
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache = this.bufferNode, result = null, depth = 0;
    if (cache && cache.context == this.buffer) {
      scan:
        for (let index = this.index, d = this.stack.length; d >= 0; ) {
          for (let c = cache; c; c = c._parent)
            if (c.index == index) {
              if (index == this.index)
                return c;
              result = c;
              depth = d + 1;
              break scan;
            }
          index = this.stack[--d];
        }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree.node;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));
}
var FlatBufferCursor = class {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
};
var BalanceBranchFactor = 8;
function buildTree(data) {
  var _a;
  let { buffer, nodeSet, topID = 0, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types2 = nodeSet.types;
  let contextHash = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
    let { id, start: start2, end, size } = cursor;
    let startPos = start2 - parentStart;
    if (size < 0) {
      if (size == -1) {
        children2.push(reused[id]);
        positions2.push(startPos);
      } else {
        contextHash = id;
      }
      cursor.next();
      return;
    }
    let type = types2[id], node, buffer2;
    if (end - start2 <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index = data2.length;
      while (cursor.pos > endPos)
        index = copyToBuffer(buffer2.start, data2, index, inRepeat);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet, inRepeat < 0 ? NodeType.none : types2[inRepeat]);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id >= minRepeatType ? id : -1;
      while (cursor.pos > endPos) {
        if (cursor.id == localInRepeat)
          cursor.next();
        else
          takeNode(start2, endPos, localChildren, localPositions, localInRepeat);
      }
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)
        node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start2, contextHash);
      else
        node = withHash(new Tree(type, localChildren, localPositions, end - start2), contextHash);
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start2 = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan:
      for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        if (fork.id == inRepeat) {
          result.size = size;
          result.start = start2;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let nodeSize = fork.size, startPos = fork.pos - nodeSize;
        if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0)
            break scan;
          if (fork.id >= minRepeatType)
            localSkipped += 4;
          fork.next();
        }
        start2 = nodeStart;
        size += nodeSize;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start2;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index, inRepeat) {
    let { id, start: start2, end, size } = cursor;
    cursor.next();
    if (id == inRepeat)
      return index;
    let startIndex = index;
    if (size > 4) {
      let endPos = cursor.pos - (size - 4);
      while (cursor.pos > endPos)
        index = copyToBuffer(bufferStart, buffer2, index, inRepeat);
    }
    if (id < minRepeatType) {
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start2 - bufferStart;
      buffer2[--index] = id;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data.start || 0, 0, children, positions, -1);
  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types2[topID], children.reverse(), positions.reverse(), length);
}
function balanceRange(outerType, innerType, children, positions, from, to, start2, maxBufferLength, length, contextHash) {
  let localChildren = [], localPositions = [];
  if (length <= maxBufferLength) {
    for (let i = from; i < to; i++) {
      localChildren.push(children[i]);
      localPositions.push(positions[i] - start2);
    }
  } else {
    let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));
    for (let i = from; i < to; ) {
      let groupFrom = i, groupStart = positions[i];
      i++;
      for (; i < to; i++) {
        let nextEnd = positions[i] + children[i].length;
        if (nextEnd - groupStart > maxChild)
          break;
      }
      if (i == groupFrom + 1) {
        let only = children[groupFrom];
        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) {
          for (let j = 0; j < only.children.length; j++) {
            localChildren.push(only.children[j]);
            localPositions.push(only.positions[j] + groupStart - start2);
          }
          continue;
        }
        localChildren.push(only);
      } else if (i == groupFrom + 1) {
        localChildren.push(children[groupFrom]);
      } else {
        let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash);
        if (innerType != NodeType.none && !containsType(inner.children, innerType))
          inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash);
        localChildren.push(inner);
      }
      localPositions.push(groupStart - start2);
    }
  }
  return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash);
}
function containsType(nodes, type) {
  for (let elt of nodes)
    if (elt.type == type)
      return true;
  return false;
}
var TreeFragment = class {
  constructor(from, to, tree, offset, open) {
    this.from = from;
    this.to = to;
    this.tree = tree;
    this.offset = offset;
    this.open = open;
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    let cI = 0, pos = 0, off = 0;
    for (; ; ) {
      let nextC = cI < changes.length ? changes[cI++] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1 : 0) | (nextC ? 2 : 0));
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
  static addTree(tree, fragments = [], partial = false) {
    let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2 : 0)];
    for (let f of fragments)
      if (f.to > tree.length)
        result.push(f);
    return result;
  }
};
function stringInput(input) {
  return new StringInput(input);
}
var StringInput = class {
  constructor(string2, length = string2.length) {
    this.string = string2;
    this.length = length;
  }
  get(pos) {
    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);
  }
  lineAfter(pos) {
    if (pos < 0)
      return "";
    let end = this.string.indexOf("\n", pos);
    return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));
  }
  read(from, to) {
    return this.string.slice(from, Math.min(this.length, to));
  }
  clip(at) {
    return new StringInput(this.string, at);
  }
};

// node_modules/@codemirror/language/dist/index.js
var languageDataProp = /* @__PURE__ */ new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values) => values.concat(baseData) : void 0
  });
}
var Language = class {
  constructor(data, parser2, topNode, extraExtensions = []) {
    this.data = data;
    this.topNode = topNode;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser2;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos) => state.facet(languageDataFacetAt(state, pos)))
    ].concat(extraExtensions);
  }
  isActiveAt(state, pos) {
    return languageDataFacetAt(state, pos) == this.data;
  }
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang || !lang.allowsNesting)
      return [];
    let result = [];
    syntaxTree(state).iterate({
      enter: (type, from, to) => {
        if (type.isTop && type.prop(languageDataProp) == this.data) {
          result.push({ from, to });
          return false;
        }
        return void 0;
      }
    });
    return result;
  }
  get allowsNesting() {
    return true;
  }
  parseString(code) {
    let doc2 = Text.of(code.split("\n"));
    let parse = this.parser.startParse(new DocInput(doc2), 0, new EditorParseContext(this.parser, EditorState.create({ doc: doc2 }), [], Tree.empty, { from: 0, to: code.length }, [], null));
    let tree;
    while (!(tree = parse.advance())) {
    }
    return tree;
  }
};
Language.setState = /* @__PURE__ */ StateEffect.define();
function languageDataFacetAt(state, pos) {
  let topLang = state.facet(language);
  if (!topLang)
    return null;
  if (!topLang.allowsNesting)
    return topLang.data;
  let tree = syntaxTree(state);
  let target = tree.resolve(pos, -1);
  while (target) {
    let facet = target.type.prop(languageDataProp);
    if (facet)
      return facet;
    target = target.parent;
  }
  return topLang.data;
}
var LezerLanguage = class extends Language {
  constructor(data, parser2) {
    super(data, parser2, parser2.topNode);
    this.parser = parser2;
  }
  static define(spec) {
    let data = defineLanguageFacet(spec.languageData);
    return new LezerLanguage(data, spec.parser.configure({
      props: [languageDataProp.add((type) => type.isTop ? data : void 0)]
    }));
  }
  configure(options) {
    return new LezerLanguage(this.data, this.parser.configure(options));
  }
  get allowsNesting() {
    return this.parser.hasNested;
  }
};
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
var DocInput = class {
  constructor(doc2, length = doc2.length) {
    this.doc = doc2;
    this.length = length;
    this.cursorPos = 0;
    this.string = "";
    this.prevString = "";
    this.cursor = doc2.iter();
  }
  syncTo(pos) {
    if (pos < this.cursorPos) {
      this.cursor = this.doc.iter();
      this.cursorPos = 0;
    }
    this.prevString = pos == this.cursorPos ? this.string : "";
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  get(pos) {
    if (pos >= this.length)
      return -1;
    let stringStart = this.cursorPos - this.string.length;
    if (pos < stringStart || pos >= this.cursorPos) {
      if (pos < stringStart && pos >= stringStart - this.prevString.length)
        return this.prevString.charCodeAt(pos - (stringStart - this.prevString.length));
      stringStart = this.syncTo(pos);
    }
    return this.string.charCodeAt(pos - stringStart);
  }
  lineAfter(pos) {
    if (pos >= this.length || pos < 0)
      return "";
    let stringStart = this.cursorPos - this.string.length;
    if (pos < stringStart || pos >= this.cursorPos)
      stringStart = this.syncTo(pos);
    return this.cursor.lineBreak ? "" : this.string.slice(pos - stringStart, Math.min(this.length - stringStart, this.string.length));
  }
  read(from, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to >= this.cursorPos)
      return this.doc.sliceString(from, to);
    else
      return this.string.slice(from - stringStart, to - stringStart);
  }
  clip(at) {
    return new DocInput(this.doc, at);
  }
};
var EditorParseContext = class {
  constructor(parser2, state, fragments = [], tree, viewport, skipped, scheduleOn) {
    this.parser = parser2;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  work(time, upto) {
    if (this.tree != Tree.empty && (upto == null ? this.tree.length == this.state.doc.length : this.tree.length >= upto)) {
      this.takeTree();
      return true;
    }
    if (!this.parse)
      this.parse = this.parser.startParse(new DocInput(this.state.doc), 0, this);
    let endTime = Date.now() + time;
    for (; ; ) {
      let done = this.parse.advance();
      if (done) {
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done));
        this.parse = null;
        this.tree = done;
        return true;
      } else if (upto != null && this.parse.pos >= upto) {
        this.takeTree();
        return true;
      }
      if (Date.now() > endTime)
        return false;
    }
  }
  takeTree() {
    if (this.parse && this.parse.pos > this.tree.length) {
      this.tree = this.parse.forceFinish();
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
    }
  }
  withoutTempSkipped(fragments) {
    for (let r2; r2 = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r2.from, r2.to);
    return fragments;
  }
  changes(changes, newState) {
    let { fragments, tree, viewport, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges);
      tree = Tree.empty;
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r2 of this.skipped) {
          let from = changes.mapPos(r2.from, 1), to = changes.mapPos(r2.to, -1);
          if (from < to)
            skipped.push({ from, to });
        }
      }
    }
    return new EditorParseContext(this.parser, newState, fragments, tree, viewport, skipped, this.scheduleOn);
  }
  updateViewport(viewport) {
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from, to } = this.skipped[i];
      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to);
        this.skipped.splice(i--, 1);
      }
    }
    return this.skipped.length < startLen;
  }
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  skipUntilInView(from, to) {
    this.skipped.push({ from, to });
  }
  static getSkippingParser(until) {
    return {
      startParse(input, startPos, context) {
        return {
          pos: startPos,
          advance() {
            let ecx = context;
            ecx.tempSkipped.push({ from: startPos, to: input.length });
            if (until)
              ecx.scheduleOn = ecx.scheduleOn ? Promise.all([ecx.scheduleOn, until]) : until;
            this.pos = input.length;
            return new Tree(NodeType.none, [], [], input.length - startPos);
          },
          forceFinish() {
            return this.advance();
          }
        };
      }
    };
  }
  movedPast(pos) {
    return this.tree.length < pos && this.parse && this.parse.pos >= pos;
  }
};
EditorParseContext.skippingParser = /* @__PURE__ */ EditorParseContext.getSkippingParser();
function cutFragments(fragments, from, to) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
var LanguageState = class {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr) {
    if (!tr.docChanged)
      return this;
    let newCx = this.context.changes(tr.changes, tr.state);
    let upto = this.context.tree.length == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.tree.length), newCx.viewport.to);
    if (!newCx.work(25, upto))
      newCx.takeTree();
    return new LanguageState(newCx);
  }
  static init(state) {
    let parseState = new EditorParseContext(state.facet(language).parser, state, [], Tree.empty, { from: 0, to: state.doc.length }, [], null);
    if (!parseState.work(25))
      parseState.takeTree();
    return new LanguageState(parseState);
  }
};
Language.state = /* @__PURE__ */ StateField.define({
  create: LanguageState.init,
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(Language.setState))
        return e.value;
    if (tr.startState.facet(language) != tr.state.facet(language))
      return LanguageState.init(tr.state);
    return value.apply(tr);
  }
});
var requestIdle = typeof window != "undefined" && window.requestIdleCallback || ((callback, { timeout }) => setTimeout(callback, timeout));
var cancelIdle = typeof window != "undefined" && window.cancelIdleCallback || clearTimeout;
var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = -1;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (update.viewportChanged) {
      if (cx.updateViewport(update.view.viewport))
        cx.reset();
      if (this.view.viewport.to > cx.tree.length)
        this.scheduleWork();
    }
    if (update.docChanged) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working > -1)
      return;
    let { state } = this.view, field = state.field(Language.state), frags = field.context.fragments;
    if (field.tree.length >= state.doc.length && frags.length && frags[0].from == 0 && frags[0].to >= state.doc.length)
      return;
    this.working = requestIdle(this.work, { timeout: 500 });
  }
  work(deadline) {
    this.working = -1;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree.length >= vpTo + 1e6)
      return;
    let time = Math.min(this.chunkBudget, deadline ? Math.max(25, deadline.timeRemaining()) : 100);
    let done = field.context.work(time, vpTo + 1e6);
    this.chunkBudget -= Date.now() - now;
    if (done || this.chunkBudget <= 0 || field.context.movedPast(vpTo)) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (!done && this.chunkBudget > 0)
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      cx.scheduleOn.then(() => this.scheduleWork());
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working >= 0)
      cancelIdle(this.working);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
var language = /* @__PURE__ */ Facet.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: [Language.state, parseWorker]
});
var LanguageSupport = class {
  constructor(language2, support = []) {
    this.language = language2;
    this.support = support;
    this.extension = [language2, support];
  }
};
var indentNodeProp = /* @__PURE__ */ new NodeProp();
function continuedIndent({ except, units = 1 } = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
var foldNodeProp = /* @__PURE__ */ new NodeProp();
function foldInside(node) {
  let first = node.firstChild, last = node.lastChild;
  return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
}

// node_modules/@codemirror/highlight/dist/index.js
var nextTagID = 0;
var Tag = class {
  constructor(set, base2, modified) {
    this.set = set;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  static define(parent) {
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new Tag([], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  static defineModifier() {
    let mod = new Modifier();
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class {
  constructor() {
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(set, base2, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = permute(mods);
    for (let parent of base2.set)
      for (let config of configs)
        set.push(Modifier.get(parent, config));
    return tag;
  }
};
function sameArray2(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function permute(array) {
  let result = [array];
  for (let i = 0; i < array.length; i++) {
    for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))
      result.push(a);
  }
  return result;
}
function styleTags(spec) {
  let byName = Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? null : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = /* @__PURE__ */ new NodeProp();
var highlightStyle = /* @__PURE__ */ Facet.define({
  combine(stylings) {
    return stylings.length ? HighlightStyle.combinedMatch(stylings) : null;
  }
});
var fallbackHighlightStyle = /* @__PURE__ */ Facet.define({
  combine(values) {
    return values.length ? values[0].match : null;
  }
});
function getHighlightStyle(state) {
  return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle);
}
var Rule = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
var HighlightStyle = class {
  constructor(spec, options) {
    this.map = Object.create(null);
    let modSpec;
    function def(spec2) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = Object.create(null)))["." + cls] = spec2;
      return cls;
    }
    this.all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : null;
    for (let style of spec) {
      let cls = (style.class || def(Object.assign({}, style, { tag: null }))) + (this.all ? " " + this.all : "");
      let tags2 = style.tag;
      if (!Array.isArray(tags2))
        this.map[tags2.id] = cls;
      else
        for (let tag of tags2)
          this.map[tag.id] = cls;
    }
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.scope = options.scope || null;
    this.match = this.match.bind(this);
    let ext = [treeHighlighter];
    if (this.module)
      ext.push(EditorView.styleModule.of(this.module));
    this.extension = ext.concat(highlightStyle.of(this));
    this.fallback = ext.concat(fallbackHighlightStyle.of(this));
  }
  match(tag, scope) {
    if (this.scope && scope != this.scope)
      return null;
    for (let t2 of tag.set) {
      let match = this.map[t2.id];
      if (match !== void 0) {
        if (t2 != tag)
          this.map[tag.id] = match;
        return match;
      }
    }
    return this.map[tag.id] = this.all;
  }
  static combinedMatch(styles) {
    if (styles.length == 1)
      return styles[0].match;
    let cache = styles.some((s) => s.scope) ? void 0 : Object.create(null);
    return (tag, scope) => {
      let cached = cache && cache[tag.id];
      if (cached !== void 0)
        return cached;
      let result = null;
      for (let style of styles) {
        let value = style.match(tag, scope);
        if (value)
          result = result ? result + " " + value : value;
      }
      if (cache)
        cache[tag.id] = result;
      return result;
    };
  }
  static define(specs, options) {
    return new HighlightStyle(specs, options || {});
  }
  static get(state, tag, scope) {
    let style = getHighlightStyle(state);
    return style && style(tag, scope || NodeType.none);
  }
};
var TreeHighlighter = class {
  constructor(view) {
    this.markCache = Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlightStyle(view.state));
  }
  update(update) {
    let tree = syntaxTree(update.state), style = getHighlightStyle(update.state);
    let styleChange = style != update.startState.facet(highlightStyle);
    if (tree.length < update.view.viewport.to && !styleChange) {
      this.decorations = this.decorations.map(update.changes);
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, style);
    }
  }
  buildDeco(view, match) {
    if (!match || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let { from, to } of view.visibleRanges) {
      highlightTreeRange(this.tree, from, to, match, (from2, to2, style) => {
        builder.add(from2, to2, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
      });
    }
    return builder.finish();
  }
};
var treeHighlighter = /* @__PURE__ */ Prec.fallback(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v) => v.decorations
}));
var nodeStack = [""];
function highlightTreeRange(tree, from, to, style, span) {
  let spanStart = from, spanClass = "";
  let cursor = tree.topNode.cursor;
  function flush(at, newClass) {
    if (spanClass)
      span(spanStart, at, spanClass);
    spanStart = at;
    spanClass = newClass;
  }
  function node(inheritedClass, depth, scope) {
    let { type, from: start2, to: end } = cursor;
    if (start2 >= to || end <= from)
      return;
    nodeStack[depth] = type.name;
    if (type.isTop)
      scope = type;
    let cls = inheritedClass;
    let rule = type.prop(ruleNodeProp), opaque = false;
    while (rule) {
      if (!rule.context || matchContext(rule.context, nodeStack, depth)) {
        for (let tag of rule.tags) {
          let st = style(tag, scope);
          if (st) {
            if (cls)
              cls += " ";
            cls += st;
            if (rule.mode == 1)
              inheritedClass += (inheritedClass ? " " : "") + st;
            else if (rule.mode == 0)
              opaque = true;
          }
        }
        break;
      }
      rule = rule.next;
    }
    let upto = start2;
    if (!opaque && cursor.firstChild()) {
      do {
        if (cursor.from > upto && spanClass != cls)
          flush(upto, cls);
        upto = cursor.to;
        node(inheritedClass, depth + 1, scope);
      } while (cursor.nextSibling());
      cursor.parent();
    }
    if (end > upto && spanClass != cls)
      flush(upto, cls);
  }
  node("", 0, tree.type);
  flush(to, "");
}
function matchContext(context, stack, depth) {
  if (context.length > depth - 1)
    return false;
  for (let d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {
    let check = context[i];
    if (check && check != stack[d])
      return false;
  }
  return true;
}
var t = Tag.define;
var comment = /* @__PURE__ */ t();
var name = /* @__PURE__ */ t();
var typeName = /* @__PURE__ */ t(name);
var literal = /* @__PURE__ */ t();
var string = /* @__PURE__ */ t(literal);
var number = /* @__PURE__ */ t(literal);
var content = /* @__PURE__ */ t();
var heading = /* @__PURE__ */ t(content);
var keyword = /* @__PURE__ */ t();
var operator = /* @__PURE__ */ t();
var punctuation = /* @__PURE__ */ t();
var bracket = /* @__PURE__ */ t(punctuation);
var meta = /* @__PURE__ */ t();
var tags = {
  comment,
  lineComment: /* @__PURE__ */ t(comment),
  blockComment: /* @__PURE__ */ t(comment),
  docComment: /* @__PURE__ */ t(comment),
  name,
  variableName: /* @__PURE__ */ t(name),
  typeName,
  tagName: /* @__PURE__ */ t(typeName),
  propertyName: /* @__PURE__ */ t(name),
  className: /* @__PURE__ */ t(name),
  labelName: /* @__PURE__ */ t(name),
  namespace: /* @__PURE__ */ t(name),
  macroName: /* @__PURE__ */ t(name),
  literal,
  string,
  docString: /* @__PURE__ */ t(string),
  character: /* @__PURE__ */ t(string),
  number,
  integer: /* @__PURE__ */ t(number),
  float: /* @__PURE__ */ t(number),
  bool: /* @__PURE__ */ t(literal),
  regexp: /* @__PURE__ */ t(literal),
  escape: /* @__PURE__ */ t(literal),
  color: /* @__PURE__ */ t(literal),
  url: /* @__PURE__ */ t(literal),
  keyword,
  self: /* @__PURE__ */ t(keyword),
  null: /* @__PURE__ */ t(keyword),
  atom: /* @__PURE__ */ t(keyword),
  unit: /* @__PURE__ */ t(keyword),
  modifier: /* @__PURE__ */ t(keyword),
  operatorKeyword: /* @__PURE__ */ t(keyword),
  controlKeyword: /* @__PURE__ */ t(keyword),
  definitionKeyword: /* @__PURE__ */ t(keyword),
  operator,
  derefOperator: /* @__PURE__ */ t(operator),
  arithmeticOperator: /* @__PURE__ */ t(operator),
  logicOperator: /* @__PURE__ */ t(operator),
  bitwiseOperator: /* @__PURE__ */ t(operator),
  compareOperator: /* @__PURE__ */ t(operator),
  updateOperator: /* @__PURE__ */ t(operator),
  definitionOperator: /* @__PURE__ */ t(operator),
  typeOperator: /* @__PURE__ */ t(operator),
  controlOperator: /* @__PURE__ */ t(operator),
  punctuation,
  separator: /* @__PURE__ */ t(punctuation),
  bracket,
  angleBracket: /* @__PURE__ */ t(bracket),
  squareBracket: /* @__PURE__ */ t(bracket),
  paren: /* @__PURE__ */ t(bracket),
  brace: /* @__PURE__ */ t(bracket),
  content,
  heading,
  heading1: /* @__PURE__ */ t(heading),
  heading2: /* @__PURE__ */ t(heading),
  heading3: /* @__PURE__ */ t(heading),
  heading4: /* @__PURE__ */ t(heading),
  heading5: /* @__PURE__ */ t(heading),
  heading6: /* @__PURE__ */ t(heading),
  contentSeparator: /* @__PURE__ */ t(content),
  list: /* @__PURE__ */ t(content),
  quote: /* @__PURE__ */ t(content),
  emphasis: /* @__PURE__ */ t(content),
  strong: /* @__PURE__ */ t(content),
  link: /* @__PURE__ */ t(content),
  monospace: /* @__PURE__ */ t(content),
  strikethrough: /* @__PURE__ */ t(content),
  inserted: /* @__PURE__ */ t(),
  deleted: /* @__PURE__ */ t(),
  changed: /* @__PURE__ */ t(),
  invalid: /* @__PURE__ */ t(),
  meta,
  documentMeta: /* @__PURE__ */ t(meta),
  annotation: /* @__PURE__ */ t(meta),
  processingInstruction: /* @__PURE__ */ t(meta),
  definition: /* @__PURE__ */ Tag.defineModifier(),
  constant: /* @__PURE__ */ Tag.defineModifier(),
  function: /* @__PURE__ */ Tag.defineModifier(),
  standard: /* @__PURE__ */ Tag.defineModifier(),
  local: /* @__PURE__ */ Tag.defineModifier(),
  special: /* @__PURE__ */ Tag.defineModifier()
};
var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags.link,
    textDecoration: "underline"
  },
  {
    tag: tags.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags.strong,
    fontWeight: "bold"
  },
  {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags.keyword,
    color: "#708"
  },
  {
    tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
    color: "#219"
  },
  {
    tag: [tags.literal, tags.inserted],
    color: "#164"
  },
  {
    tag: [tags.string, tags.deleted],
    color: "#a11"
  },
  {
    tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ tags.local(tags.variableName),
    color: "#30a"
  },
  {
    tag: [tags.typeName, tags.namespace],
    color: "#085"
  },
  {
    tag: tags.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ tags.definition(tags.propertyName),
    color: "#00c"
  },
  {
    tag: tags.comment,
    color: "#940"
  },
  {
    tag: tags.meta,
    color: "#7a757a"
  },
  {
    tag: tags.invalid,
    color: "#f00"
  }
]);
var classHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
  { tag: tags.link, class: "cmt-link" },
  { tag: tags.heading, class: "cmt-heading" },
  { tag: tags.emphasis, class: "cmt-emphasis" },
  { tag: tags.strong, class: "cmt-strong" },
  { tag: tags.keyword, class: "cmt-keyword" },
  { tag: tags.atom, class: "cmt-atom" },
  { tag: tags.bool, class: "cmt-bool" },
  { tag: tags.url, class: "cmt-url" },
  { tag: tags.labelName, class: "cmt-labelName" },
  { tag: tags.inserted, class: "cmt-inserted" },
  { tag: tags.deleted, class: "cmt-deleted" },
  { tag: tags.literal, class: "cmt-literal" },
  { tag: tags.string, class: "cmt-string" },
  { tag: tags.number, class: "cmt-number" },
  { tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)], class: "cmt-string2" },
  { tag: tags.variableName, class: "cmt-variableName" },
  { tag: /* @__PURE__ */ tags.local(tags.variableName), class: "cmt-variableName cmt-local" },
  { tag: /* @__PURE__ */ tags.definition(tags.variableName), class: "cmt-variableName cmt-definition" },
  { tag: /* @__PURE__ */ tags.special(tags.variableName), class: "cmt-variableName2" },
  { tag: tags.typeName, class: "cmt-typeName" },
  { tag: tags.namespace, class: "cmt-namespace" },
  { tag: tags.macroName, class: "cmt-macroName" },
  { tag: tags.propertyName, class: "cmt-propertyName" },
  { tag: tags.operator, class: "cmt-operator" },
  { tag: tags.comment, class: "cmt-comment" },
  { tag: tags.meta, class: "cmt-meta" },
  { tag: tags.invalid, class: "cmt-invalid" },
  { tag: tags.punctuation, class: "cmt-punctuation" }
]);

// node_modules/reactex/dist/code.js
var import_lodash = __toModule(require_lodash());
var add_highlight = StateEffect.define();
var clear_highlights = StateEffect.define();
var highlight_field = StateField.define({
  create() {
    return Decoration.none;
  },
  update(highlights, tr) {
    highlights = highlights.map(tr.changes);
    for (let e of tr.effects) {
      if (e.is(add_highlight)) {
        let { to, from, color } = e.value;
        let mark = Decoration.mark({
          class: `cm-highlight bgcolor-${color}`
        });
        highlights = highlights.update({
          add: [mark.range(from, to)]
        });
      } else if (e.is(clear_highlights)) {
        return highlights.update({ filter: (_22) => false });
      }
    }
    return highlights;
  },
  provide: (f) => EditorView.decorations.from(f)
});
var theme2 = EditorView.theme({
  ".cm-scroller": {
    fontFamily: "Inconsolata, monospace"
  },
  ".cm-gutters": {
    background: "none",
    border: "none"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    fontSize: "10px",
    paddingTop: "3px",
    paddingRight: "7px",
    minWidth: "10px"
  },
  ".cm-highlight": {
    padding: "0 3px",
    margin: "-1px -3px",
    borderRadius: "2px"
  }
});
var linecol_to_pos = (editor, { line, col }) => {
  let line_obj = editor.state.doc.line(line);
  return line_obj.from + col;
};
var pos_to_linecol = (editor, pos) => {
  let line_obj = editor.state.doc.lineAt(pos);
  return {
    line: line_obj.number,
    col: pos - line_obj.from
  };
};
var ListingData = class {
};
var ListingContext = import_react2.default.createContext(new ListingData());
var ListingConfigure = ({
  language: language2
}) => {
  let ctx = (0, import_react2.useContext)(ListingContext);
  ctx.language = language2;
  return null;
};
var parse_with_delimiters = (code, delimiters) => {
  let [open, close] = import_lodash.default.unzip(delimiters);
  let make_check = (arr) => {
    let r2 = new RegExp(`^${arr.join("|")}`);
    return (s) => {
      let match = s.match(r2);
      return match ? match[0].length : null;
    };
  };
  let [open_check, close_check] = [make_check(open), make_check(close)];
  let index = 0;
  let in_seq = null;
  let ranges = [];
  let output_code = [];
  let i = 0;
  while (i < code.length) {
    if (in_seq === null) {
      let n = open_check(code.substring(i));
      if (n) {
        i += n;
        in_seq = index;
        continue;
      }
    } else {
      let n = close_check(code.substring(i));
      if (n) {
        i += n;
        ranges.push([in_seq, index]);
        in_seq = null;
        continue;
      }
    }
    index += 1;
    output_code.push(code[i]);
    i += 1;
  }
  return { output_code: output_code.join(""), ranges };
};
var Listing = (props) => {
  let [editor, set_editor] = (0, import_react2.useState)(null);
  let ctx = (0, import_react2.useContext)(ListingContext);
  let ref = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    let language2 = props.language || ctx.language;
    if (!language2) {
      throw "Language not specified";
    }
    let code = props.code;
    let parse_result = null;
    if (props.delimiters) {
      parse_result = parse_with_delimiters(code, props.delimiters.delimiters);
      if (parse_result.error) {
        throw parse_result.error;
      } else {
        code = parse_result.output_code;
      }
    }
    let editor2 = new EditorView({
      state: EditorState.create({
        doc: code,
        extensions: [
          lineNumbers(),
          defaultHighlightStyle,
          language2,
          theme2,
          EditorView.editable.of(props.editable || false),
          highlight_field
        ].concat(props.extensions || [])
      }),
      parent: ref.current
    });
    if (props.onLoad) {
      props.onLoad(editor2);
    }
    if (props.delimiters) {
      props.delimiters.onParse(parse_result.ranges);
    }
    set_editor(editor2);
  }, []);
  return /* @__PURE__ */ import_react2.default.createElement("div", {
    ref
  });
};

// node_modules/reactex/dist/document.js
var import_lodash2 = __toModule(require_lodash());
var SectionData = class {
  constructor() {
    this.subsections = 0;
  }
};
var DocumentData = class {
  constructor() {
    this.sections = 0;
    this.footnotes = [];
    this.labels = {};
    this.section_contexts = [];
  }
  add_label(key, value) {
    if (!this.labels[key]) {
      this.labels[key] = value;
    }
  }
};
var DocumentContext = import_react3.default.createContext(new DocumentData());
var SectionTitle = ({
  level,
  children
}) => {
  let Header;
  if (!level || level == 0) {
    Header = (props) => /* @__PURE__ */ import_react3.default.createElement("h2", {
      ...props
    });
  } else if (level == 1) {
    Header = (props) => /* @__PURE__ */ import_react3.default.createElement("h3", {
      ...props
    });
  } else {
    Header = (props) => /* @__PURE__ */ import_react3.default.createElement("h4", {
      ...props
    });
  }
  return /* @__PURE__ */ import_react3.default.createElement(Header, {
    className: "section-title"
  }, children);
};
var Section = ({
  label,
  title,
  children
}) => {
  let doc_ctx = (0, import_react3.useContext)(DocumentContext);
  if (doc_ctx.section_contexts.length == 0) {
    doc_ctx.sections += 1;
  } else {
    import_lodash2.default.last(doc_ctx.section_contexts).subsections += 1;
  }
  let level = doc_ctx.section_contexts.length;
  let sec_num = [
    doc_ctx.sections,
    ...doc_ctx.section_contexts.map((ctx) => ctx.subsections)
  ].join(".");
  if (label) {
    doc_ctx.add_label(label, `Section ${sec_num}`);
  }
  let sec_ctx = new SectionData();
  doc_ctx.section_contexts.push(sec_ctx);
  let Cleanup = (_22) => {
    doc_ctx.section_contexts.pop();
    return null;
  };
  return /* @__PURE__ */ import_react3.default.createElement("section", {
    id: label
  }, /* @__PURE__ */ import_react3.default.createElement(SectionTitle, {
    level
  }, /* @__PURE__ */ import_react3.default.createElement("span", {
    className: "section-number"
  }, sec_num), " ", title), children, /* @__PURE__ */ import_react3.default.createElement(Cleanup, null));
};
var Ref = ({ label }) => {
  let ctx = (0, import_react3.useContext)(DocumentContext);
  return /* @__PURE__ */ import_react3.default.createElement("a", {
    href: `#${label}`
  }, ctx.labels[label] || label);
};
var Footnote = ({ children }) => {
  let ctx = (0, import_react3.useContext)(DocumentContext);
  ctx.footnotes.push(children);
  let i = ctx.footnotes.length;
  return /* @__PURE__ */ import_react3.default.createElement("a", {
    href: `#footnote-${i}`,
    id: `footnote-ref-${i}`
  }, /* @__PURE__ */ import_react3.default.createElement("sup", null, i));
};
var Wrap = ({
  align,
  children
}) => {
  let margin = "1rem";
  let style;
  if (align == "left") {
    style = { marginRight: margin };
  } else if (align == "right") {
    style = { marginLeft: margin };
  } else {
    style = {};
  }
  return /* @__PURE__ */ import_react3.default.createElement("div", {
    style: { float: align, ...style }
  }, children);
};
var Document = ({ children, bibtex }) => {
  let [second_pass, set_second_pass] = (0, import_react3.useState)(false);
  (0, import_react3.useEffect)(() => {
    set_second_pass(true);
  });
  let [ctx, set_ctx] = (0, import_react3.useState)(new DocumentData());
  (0, import_react3.useEffect)(() => {
    if (second_pass) {
      let new_ctx = new DocumentData();
      new_ctx.labels = ctx.labels;
      set_ctx(new_ctx);
    }
  }, [second_pass]);
  let Footnotes = (_22) => /* @__PURE__ */ import_react3.default.createElement("div", {
    className: "footnotes"
  }, ctx.footnotes.map((footnote, i) => {
    let top2 = {};
    i += 1;
    return /* @__PURE__ */ import_react3.default.createElement("div", {
      className: "footnote",
      id: `footnote-${i}`,
      key: i
    }, /* @__PURE__ */ import_react3.default.createElement("a", {
      className: "backlink",
      href: `#footnote-ref-${i}`
    }, "\u2B05"), /* @__PURE__ */ import_react3.default.createElement("span", {
      className: "footnote-number"
    }, i), footnote);
  }));
  return /* @__PURE__ */ import_react3.default.createElement(DocumentContext.Provider, {
    value: ctx
  }, /* @__PURE__ */ import_react3.default.createElement(ReactTexContext.Provider, {
    value: new TexContext()
  }, /* @__PURE__ */ import_react3.default.createElement(ReactBibliographyContext.Provider, {
    value: new BibliographyContext(bibtex || "")
  }, /* @__PURE__ */ import_react3.default.createElement(ListingContext.Provider, {
    value: new ListingData()
  }, /* @__PURE__ */ import_react3.default.createElement("div", {
    className: "document-wrapper",
    key: second_pass.toString()
  }, /* @__PURE__ */ import_react3.default.createElement("div", {
    className: "document"
  }, children), /* @__PURE__ */ import_react3.default.createElement(References, null), /* @__PURE__ */ import_react3.default.createElement(Footnotes, null))))));
};

// node_modules/reactex/dist/bibliography.js
function isString(x) {
  return typeof x === "string";
}
var BibliographyEntry = class {
  constructor(entry) {
    this.key = entry.citationKey;
    let tags2 = entry.entryTags;
    if (isString(tags2.author)) {
      this.authors = tags2.author.split(" and ").map((author) => author.split(", "));
    }
    if (isString(tags2.year)) {
      this.year = parseInt(tags2.year);
    }
    if (isString(tags2.title)) {
      this.title = tags2.title;
    }
    this.tags = tags2;
  }
  display_author() {
    if (this.authors) {
      if (this.authors.length > 2) {
        return `${this.authors[0][0]} et al.`;
      } else if (this.authors.length > 1) {
        return `${this.authors[0][0]} and ${this.authors[1][0]}`;
      } else if (this.authors.length > 0) {
        return this.authors[0][0];
      } else {
        throw "Empty author list";
      }
    } else {
      return "??";
    }
  }
  bib_cite() {
    let names = this.authors?.map((author) => [...author.slice(1), author[0]].join(" "));
    return /* @__PURE__ */ import_react4.default.createElement("div", {
      className: "reference"
    }, /* @__PURE__ */ import_react4.default.createElement("a", {
      id: `ref-${this.key}`
    }), names ? (names.length > 1 ? names.slice(0, -1).join(", ") + ", and " + names[names.length - 1] : names[0]) + ". " : null, this.year ? this.year + ". " : null, this.title ? this.title + ". " : null, /* @__PURE__ */ import_react4.default.createElement("i", null, this.tags.journal || this.tags.booktitle, "."));
  }
};
function intersperse(arr, sep) {
  if (arr.length === 0) {
    return [];
  }
  return arr.slice(1).reduce(function(xs, x, i) {
    return xs.concat([sep, x]);
  }, [arr[0]]);
}
var BibliographyContext = class {
  constructor(bibtex) {
    let entries = import_bibtex_parse_js.default.toJSON(bibtex);
    this.citations = import_lodash3.default.chain(entries).map((entry) => [entry.citationKey, new BibliographyEntry(entry)]).fromPairs().value();
    this.used_citations = {};
  }
  cite(key, full, yearonly) {
    let keys = typeof key === "string" ? [key] : key;
    keys.forEach((key2) => {
      this.used_citations[key2] = true;
    });
    return full ? /* @__PURE__ */ import_react4.default.createElement("a", {
      href: `#ref-${key}`
    }, intersperse(keys.map((key2) => {
      let entry = this.citations[key2];
      let author = entry.display_author();
      return `${author} [${entry.year}]`;
    }), "; ")) : /* @__PURE__ */ import_react4.default.createElement("span", null, "[", intersperse(keys.map((key2) => {
      let entry = this.citations[key2];
      if (yearonly) {
        return entry.year;
      } else {
        let author = entry.display_author();
        return /* @__PURE__ */ import_react4.default.createElement("a", {
          key: key2,
          href: `#ref-${key2}`
        }, `${author} ${entry.year}`);
      }
    }), ", "), "]");
  }
};
var ReactBibliographyContext = import_react4.default.createContext(null);
var References = (_22) => {
  let ctx = (0, import_react4.useContext)(ReactBibliographyContext);
  return /* @__PURE__ */ import_react4.default.createElement("div", {
    className: "references"
  }, /* @__PURE__ */ import_react4.default.createElement(SectionTitle, null, "References"), Object.keys(ctx.used_citations).map((key) => /* @__PURE__ */ import_react4.default.createElement("div", {
    key
  }, ctx.citations[key].bib_cite())));
};
var Cite = ({ v, f, y }) => {
  let ctx = (0, import_react4.useContext)(ReactBibliographyContext);
  return ctx.cite(v, f || false, y || false);
};

// node_modules/reactex/dist/header.js
var import_react5 = __toModule(require_react());
var import_react6 = __toModule(require_react());
var AffiliationContext = (0, import_react6.createContext)({});
var InlineError = ({ children }) => /* @__PURE__ */ import_react5.default.createElement("span", {
  className: "inline-error"
}, children);
var AuthorContext = (0, import_react6.createContext)({});
var Institution = ({ value }) => {
  let ctx = (0, import_react6.useContext)(AffiliationContext);
  ctx.institution = value;
  return /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null);
};
var Affiliation = ({ children }) => {
  let auth_ctx = (0, import_react6.useContext)(AuthorContext);
  let aff_ctx = {};
  let Inner = () => {
    if (!auth_ctx.affiliations) {
      auth_ctx.affiliations = [];
    }
    auth_ctx.affiliations.push(aff_ctx);
    return /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null);
  };
  return /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null, /* @__PURE__ */ import_react5.default.createElement(AffiliationContext.Provider, {
    value: aff_ctx
  }, children), /* @__PURE__ */ import_react5.default.createElement(Inner, null));
};
var Name = ({ value }) => {
  let ctx = (0, import_react6.useContext)(AuthorContext);
  ctx.name = value;
  return /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null);
};
var Author = ({ children }) => {
  let ctx = {};
  let Inner = () => /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "author"
  }, ctx.name ? /* @__PURE__ */ import_react5.default.createElement("span", {
    className: "author-name"
  }, ctx.name) : /* @__PURE__ */ import_react5.default.createElement(InlineError, null, "No author name!"), ctx.affiliations ? /* @__PURE__ */ import_react5.default.createElement("span", {
    className: "author-affiliation"
  }, ",", " ", ctx.affiliations.map((affiliation, i) => /* @__PURE__ */ import_react5.default.createElement("span", {
    key: i
  }, affiliation.institution ? affiliation.institution : null, affiliation.country ? /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null, ", ", affiliation.country) : null))) : null);
  return /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null, /* @__PURE__ */ import_react5.default.createElement(AuthorContext.Provider, {
    value: ctx
  }, children), /* @__PURE__ */ import_react5.default.createElement(Inner, null));
};
var Authors = ({ children }) => {
  return /* @__PURE__ */ import_react5.default.createElement("div", {
    className: "authors"
  }, children);
};
var Title = ({ children }) => /* @__PURE__ */ import_react5.default.createElement("h1", {
  className: "document-title"
}, children);
var Abstract = ({ children }) => /* @__PURE__ */ import_react5.default.createElement("div", {
  className: "abstract"
}, children);

// node_modules/lezer/dist/index.es.js
var Stack = class {
  constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.parent = parent;
  }
  toString() {
    return `[${this.stack.filter((_4, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(state, start2) {
    this.stack.push(this.state, start2, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  reduce(action) {
    let depth = action >> 19, type = action & 65535;
    let { parser: parser2 } = this.p;
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, 4, true);
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      this.reduceContext(type);
      return;
    }
    let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start2 = this.stack[base2 - 2];
    let bufferBase = this.stack[base2 - 1], count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(type, start2, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base2];
    } else {
      let baseStateID = this.stack[base2 - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base2)
      this.stack.pop();
    this.reduceContext(type);
  }
  storeNode(term, start2, end, size = 4, isReduce = false) {
    if (term == 0) {
      let cur = this, top2 = this.buffer.length;
      if (top2 == 0 && cur.parent) {
        top2 = cur.bufferBase - cur.parent.bufferBase;
        cur = cur.parent;
      }
      if (top2 > 0 && cur.buffer[top2 - 4] == 0 && cur.buffer[top2 - 1] > -1) {
        if (start2 == end)
          return;
        if (cur.buffer[top2 - 2] >= start2) {
          cur.buffer[top2 - 2] = end;
          return;
        }
      }
    }
    if (!isReduce || this.pos == end) {
      this.buffer.push(term, start2, end, size);
    } else {
      let index = this.buffer.length;
      if (index > 0 && this.buffer[index - 4] != 0)
        while (index > 0 && this.buffer[index - 2] > end) {
          this.buffer[index] = this.buffer[index - 4];
          this.buffer[index + 1] = this.buffer[index - 3];
          this.buffer[index + 2] = this.buffer[index - 2];
          this.buffer[index + 3] = this.buffer[index - 1];
          index -= 4;
          if (size > 4)
            size -= 4;
        }
      this.buffer[index] = term;
      this.buffer[index + 1] = start2;
      this.buffer[index + 2] = end;
      this.buffer[index + 3] = size;
    }
  }
  shift(action, next, nextEnd) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let start2 = this.pos, nextState = action, { parser: parser2 } = this.p;
      if (nextEnd > this.pos || next <= parser2.maxNode) {
        this.pos = nextEnd;
        if (!parser2.stateFlag(nextState, 1))
          this.reducePos = nextEnd;
      }
      this.pushState(nextState, start2);
      if (next <= parser2.maxNode)
        this.buffer.push(next, start2, nextEnd, 4);
      this.shiftContext(next);
    } else {
      if (next <= this.p.parser.maxNode)
        this.buffer.push(next, this.pos, nextEnd, 4);
      this.pos = nextEnd;
    }
  }
  apply(action, next, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextEnd);
  }
  useNode(value, next) {
    let index = this.p.reused.length - 1;
    if (index < 0 || this.p.reused[index] != value) {
      this.p.reused.push(value);
      index++;
    }
    let start2 = this.pos;
    this.reducePos = this.pos = start2 + value.length;
    this.pushState(next, start2);
    this.buffer.push(index, start2, this.reducePos, -1);
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this.p.input, this));
  }
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base2 = parent.bufferBase + off;
    while (parent && base2 == parent.bufferBase)
      parent = parent.parent;
    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base2, this.curContext, parent);
  }
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 200;
  }
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(sim.top, 4) || this.p.parser.hasAction(sim.top, term);
      if ((action & 65536) == 0)
        return true;
      if (action == 0)
        return false;
      sim.reduce(action);
    }
  }
  get ruleStart() {
    for (let state = this.state, base2 = this.stack.length; ; ) {
      let force = this.p.parser.stateSlot(state, 5);
      if (!(force & 65536))
        return 0;
      base2 -= 3 * (force >> 19);
      if ((force & 65535) < this.p.parser.minRepeatTerm)
        return this.stack[base2 + 1];
      state = this.stack[base2];
    }
  }
  startOf(types2, before) {
    let state = this.state, frame = this.stack.length, { parser: parser2 } = this.p;
    for (; ; ) {
      let force = parser2.stateSlot(state, 5);
      let depth = force >> 19, term = force & 65535;
      if (types2.indexOf(term) > -1) {
        let base2 = frame - 3 * (force >> 19), pos = this.stack[base2 + 1];
        if (before == null || before > pos)
          return pos;
      }
      if (frame == 0)
        return null;
      if (depth == 0) {
        frame -= 3;
        state = this.stack[frame];
      } else {
        frame -= 3 * (depth - 1);
        state = parser2.getGoto(this.stack[frame - 3], term, true);
      }
    }
  }
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
          best.push(nextStates[i], s);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s))
            best.push(nextStates[i], s);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state)
        continue;
      let stack = this.split();
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.pushState(s, this.pos);
      stack.shiftContext(nextStates[i]);
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  forceReduce() {
    let reduce = this.p.parser.stateSlot(this.state, 5);
    if ((reduce & 65536) == 0)
      return false;
    if (!this.p.parser.validAction(this.state, reduce)) {
      this.storeNode(0, this.reducePos, this.reducePos, 4, true);
      this.score -= 100;
    }
    this.reduce(reduce);
    return true;
  }
  forceAll() {
    while (!this.p.parser.stateFlag(this.state, 2) && this.forceReduce()) {
    }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
  }
  restart() {
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this.p.input, this));
  }
  reduceContext(term) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this.p.input, this));
  }
  emitContext() {
    let cx = this.curContext;
    if (!cx.tracker.strict)
      return;
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -2)
      this.buffer.push(cx.hash, this.reducePos, this.reducePos, -2);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.hash(context);
  }
};
var Recover;
(function(Recover2) {
  Recover2[Recover2["Token"] = 200] = "Token";
  Recover2[Recover2["Reduce"] = 100] = "Reduce";
  Recover2[Recover2["MaxNext"] = 4] = "MaxNext";
  Recover2[Recover2["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
  Recover2[Recover2["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
var SimulatedStack = class {
  constructor(stack) {
    this.stack = stack;
    this.top = stack.state;
    this.rest = stack.stack;
    this.offset = this.rest.length;
  }
  reduce(action) {
    let term = action & 65535, depth = action >> 19;
    if (depth == 0) {
      if (this.rest == this.stack.stack)
        this.rest = this.rest.slice();
      this.rest.push(this.top, 0, 0);
      this.offset += 3;
    } else {
      this.offset -= (depth - 1) * 3;
    }
    let goto = this.stack.p.parser.getGoto(this.rest[this.offset - 3], term, true);
    this.top = goto;
  }
};
var StackBufferCursor = class {
  constructor(stack, pos, index) {
    this.stack = stack;
    this.pos = pos;
    this.index = index;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack) {
    return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
};
var Token = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
  }
  accept(value, end) {
    this.value = value;
    this.end = end;
  }
};
var TokenGroup = class {
  constructor(data, id) {
    this.data = data;
    this.id = id;
  }
  token(input, token, stack) {
    readToken(this.data, input, token, stack, this.id);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var ExternalTokenizer = class {
  constructor(token, options = {}) {
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
};
function readToken(data, input, token, stack, group) {
  let state = 0, groupMask = 1 << group, dialect = stack.p.parser.dialect;
  scan:
    for (let pos = token.start; ; ) {
      if ((groupMask & data[state]) == 0)
        break;
      let accEnd = data[state + 1];
      for (let i = state + 3; i < accEnd; i += 2)
        if ((data[i + 1] & groupMask) > 0) {
          let term = data[i];
          if (dialect.allows(term) && (token.value == -1 || token.value == term || stack.p.parser.overrides(term, token.value))) {
            token.accept(term, pos);
            break;
          }
        }
      let next = input.get(pos++);
      for (let low = 0, high = data[state + 2]; low < high; ) {
        let mid = low + high >> 1;
        let index = accEnd + mid + (mid << 1);
        let from = data[index], to = data[index + 1];
        if (next < from)
          high = mid;
        else if (next >= to)
          low = mid + 1;
        else {
          state = data[index + 2];
          continue scan;
        }
      }
      break;
    }
}
function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type(value);
  }
  return array;
}
var verbose = typeof process != "undefined" && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor = tree.cursor(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
          return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 5)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 5));
        if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
          break;
        if (!cursor.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor = class {
  constructor(fragments) {
    this.fragments = fragments;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top2 = this.trees[last], index = this.index[last];
      if (index == top2.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top2.children[index];
      let start2 = this.start[last] + top2.positions[index];
      if (start2 > pos) {
        this.nextStart = start2;
        return null;
      } else if (start2 == pos && start2 + next.length <= this.safeTo) {
        return start2 == pos && start2 >= this.safeFrom ? next : null;
      }
      if (next instanceof TreeBuffer) {
        this.index[last]++;
        this.nextStart = start2 + next.length;
      } else {
        this.index[last]++;
        if (start2 + next.length >= pos) {
          this.trees.push(next);
          this.start.push(start2);
          this.index.push(0);
        }
      }
    }
  }
};
var CachedToken = class extends Token {
  constructor() {
    super(...arguments);
    this.extended = -1;
    this.mask = 0;
    this.context = 0;
  }
  clear(start2) {
    this.start = start2;
    this.value = this.extended = -1;
  }
};
var dummyToken = new Token();
var TokenCache = class {
  constructor(parser2) {
    this.tokens = [];
    this.mainToken = dummyToken;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_4) => new CachedToken());
  }
  getActions(stack, input) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser2 } = stack.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(stack.state, 3);
    let context = stack.curContext ? stack.curContext.hash : 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token = this.tokens[i];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack, input);
        token.mask = mask;
        token.context = context;
      }
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (!main) {
      main = dummyToken;
      main.start = stack.pos;
      if (stack.pos == input.length)
        main.accept(stack.p.parser.eofTerm, stack.pos);
      else
        main.accept(0, stack.pos + 1);
    }
    this.mainToken = main;
    return this.actions;
  }
  updateCachedToken(token, tokenizer, stack, input) {
    token.clear(stack.pos);
    tokenizer.token(input, token, stack);
    if (token.value > -1) {
      let { parser: parser2 } = stack.p;
      for (let i = 0; i < parser2.specialized.length; i++)
        if (parser2.specialized[i] == token.value) {
          let result = parser2.specializers[i](input.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else if (stack.pos == input.length) {
      token.accept(stack.p.parser.eofTerm, stack.pos);
    } else {
      token.accept(0, stack.pos + 1);
    }
  }
  putAction(action, token, end, index) {
    for (let i = 0; i < index; i += 3)
      if (this.actions[i] == action)
        return index;
    this.actions[index++] = action;
    this.actions[index++] = token;
    this.actions[index++] = end;
    return index;
  }
  addActions(stack, token, end, index) {
    let { state } = stack, { parser: parser2 } = stack.p, { data } = parser2;
    for (let set = 0; set < 2; set++) {
      for (let i = parser2.stateSlot(state, set ? 2 : 1); ; i += 3) {
        if (data[i] == 65535) {
          if (data[i + 1] == 1) {
            i = pair(data, i + 2);
          } else {
            if (index == 0 && data[i + 1] == 2)
              index = this.putAction(pair(data, i + 1), token, end, index);
            break;
          }
        }
        if (data[i] == token)
          index = this.putAction(pair(data, i + 1), token, end, index);
      }
    }
    return index;
  }
};
var Rec;
(function(Rec2) {
  Rec2[Rec2["Distance"] = 5] = "Distance";
  Rec2[Rec2["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
  Rec2[Rec2["MinBufferLengthPrune"] = 200] = "MinBufferLengthPrune";
  Rec2[Rec2["ForceReduceLimit"] = 10] = "ForceReduceLimit";
})(Rec || (Rec = {}));
var Parse = class {
  constructor(parser2, input, startPos, context) {
    this.parser = parser2;
    this.input = input;
    this.startPos = startPos;
    this.context = context;
    this.pos = 0;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.nested = null;
    this.nestEnd = 0;
    this.nestWrap = null;
    this.reused = [];
    this.tokens = new TokenCache(parser2);
    this.topTerm = parser2.top[1];
    this.stacks = [Stack.start(this, parser2.top[0], this.startPos)];
    let fragments = context === null || context === void 0 ? void 0 : context.fragments;
    this.fragments = fragments && fragments.length ? new FragmentCursor(fragments) : null;
  }
  advance() {
    if (this.nested) {
      let result = this.nested.advance();
      this.pos = this.nested.pos;
      if (result) {
        this.finishNested(this.stacks[0], result);
        this.nested = null;
      }
      return null;
    }
    let stacks = this.stacks, pos = this.pos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    let maybeNest;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], nest;
      for (; ; ) {
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (nest = this.checkNest(stack)) {
          if (!maybeNest || maybeNest.stack.score < stack.score)
            maybeNest = nest;
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.mainToken;
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (maybeNest) {
      this.startNested(maybeNest);
      return null;
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished)
        return this.stackToTree(finished);
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + this.parser.getName(this.tokens.mainToken.value));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished)
        return this.stackToTree(finished.forceAll());
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s) => s.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer:
        for (let i = 0; i < newStacks.length - 1; i++) {
          let stack = newStacks[i];
          for (let j = i + 1; j < newStacks.length; j++) {
            let other = newStacks[j];
            if (stack.sameState(other) || stack.buffer.length > 200 && other.buffer.length > 200) {
              if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j--, 1);
              } else {
                newStacks.splice(i--, 1);
                continue outer;
              }
            }
          }
        }
    }
    this.pos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.pos)
        this.pos = newStacks[i].pos;
    return null;
  }
  advanceStack(stack, stacks, split) {
    let start2 = stack.pos, { input, parser: parser2 } = this;
    let base2 = verbose ? this.stackID(stack) + " -> " : "";
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start2); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.contextHash || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose)
            console.log(base2 + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(stack.state, 4);
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base2 + this.stackID(stack) + ` (via always-reduce ${parser2.getName(defaultReduce & 65535)})`);
      return true;
    }
    let actions = this.tokens.getActions(stack, input);
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++], term = actions[i++], end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      localStack.apply(action, term, end);
      if (verbose)
        console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(action & 65535)}`} for ${parser2.getName(term)} @ ${start2}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start2)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      let nest = this.checkNest(stack);
      if (nest)
        return nest;
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    let maybeNest;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
      let base2 = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base2 + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done) {
          if (done !== true)
            maybeNest = done;
          continue;
        }
      }
      let force = stack.split(), forceBase = base2;
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done) {
          if (done !== true)
            maybeNest = done;
          break;
        }
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert2 of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
        this.advanceFully(insert2, newStacks);
      }
      if (this.input.length > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base2 + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    if (finished)
      return finished;
    if (maybeNest) {
      for (let s of this.stacks)
        if (s.score > maybeNest.stack.score) {
          maybeNest = void 0;
          break;
        }
    }
    if (maybeNest)
      this.startNested(maybeNest);
    return null;
  }
  forceFinish() {
    let stack = this.stacks[0].split();
    if (this.nested)
      this.finishNested(stack, this.nested.forceFinish());
    return this.stackToTree(stack.forceAll());
  }
  stackToTree(stack, pos = stack.pos) {
    if (this.parser.context)
      stack.emitContext();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.startPos,
      length: pos - this.startPos,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  checkNest(stack) {
    let info = this.parser.findNested(stack.state);
    if (!info)
      return null;
    let spec = info.value;
    if (typeof spec == "function")
      spec = spec(this.input, stack);
    return spec ? { stack, info, spec } : null;
  }
  startNested(nest) {
    let { stack, info, spec } = nest;
    this.stacks = [stack];
    this.nestEnd = this.scanForNestEnd(stack, info.end, spec.filterEnd);
    this.nestWrap = typeof spec.wrapType == "number" ? this.parser.nodeSet.types[spec.wrapType] : spec.wrapType || null;
    if (spec.startParse) {
      this.nested = spec.startParse(this.input.clip(this.nestEnd), stack.pos, this.context);
    } else {
      this.finishNested(stack);
    }
  }
  scanForNestEnd(stack, endToken, filter) {
    for (let pos = stack.pos; pos < this.input.length; pos++) {
      dummyToken.start = pos;
      dummyToken.value = -1;
      endToken.token(this.input, dummyToken, stack);
      if (dummyToken.value > -1 && (!filter || filter(this.input.read(pos, dummyToken.end))))
        return pos;
    }
    return this.input.length;
  }
  finishNested(stack, tree) {
    if (this.nestWrap)
      tree = new Tree(this.nestWrap, tree ? [tree] : [], tree ? [0] : [], this.nestEnd - stack.pos);
    else if (!tree)
      tree = new Tree(NodeType.none, [], [], this.nestEnd - stack.pos);
    let info = this.parser.findNested(stack.state);
    stack.useNode(tree, this.parser.getGoto(stack.state, info.placeholder, true));
    if (verbose)
      console.log(this.stackID(stack) + ` (via unnest)`);
  }
  stackID(stack) {
    let id = (stackIDs || (stackIDs = new WeakMap())).get(stack);
    if (!id)
      stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
    return id + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var Parser = class {
  constructor(spec) {
    this.bufferLength = DefaultBufferLength;
    this.strict = false;
    this.cachedDialect = null;
    if (spec.version != 13)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13})`);
    let tokenArray = decodeArray(spec.tokenData);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    this.context = spec.context;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
    this.specializers = [];
    if (spec.specialized)
      for (let i = 0; i < spec.specialized.length; i++) {
        this.specialized[i] = spec.specialized[i].term;
        this.specializers[i] = spec.specialized[i].get;
      }
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    let topTerms = Object.keys(spec.topRules).map((r2) => spec.topRules[r2][1]);
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.nested = (spec.nested || []).map(([name2, value, endToken, placeholder]) => {
      return { name: name2, value, end: new TokenGroup(decodeArray(endToken), 0), placeholder };
    });
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  parse(input, startPos = 0, context = {}) {
    if (typeof input == "string")
      input = stringInput(input);
    let cx = new Parse(this, input, startPos, context);
    for (; ; ) {
      let done = cx.advance();
      if (done)
        return done;
    }
  }
  startParse(input, startPos = 0, context = {}) {
    if (typeof input == "string")
      input = stringInput(input);
    return new Parse(this, input, startPos, context);
  }
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  hasAction(state, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(state, set ? 2 : 1), next; ; i += 3) {
        if ((next = data[i]) == 65535) {
          if (data[i + 1] == 1)
            next = data[i = pair(data, i + 2)];
          else if (data[i + 1] == 2)
            return pair(data, i + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data, i + 1);
      }
    }
    return 0;
  }
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  stateFlag(state, flag) {
    return (this.stateSlot(state, 0) & flag) > 0;
  }
  findNested(state) {
    let flags = this.stateSlot(state, 0);
    return flags & 4 ? this.nested[flags >> 10] : null;
  }
  validAction(state, action) {
    if (action == this.stateSlot(state, 4))
      return true;
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          return false;
      }
      if (action == pair(this.data, i + 1))
        return true;
    }
  }
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  overrides(token, prev) {
    let iPrev = findOffset(this.data, this.tokenPrecTable, prev);
    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;
  }
  configure(config) {
    let copy = Object.assign(Object.create(Parser.prototype), this);
    if (config.props)
      copy.nodeSet = this.nodeSet.extend(...config.props);
    if (config.top) {
      let info = this.topRules[config.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config.top}`);
      copy.top = info;
    }
    if (config.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config.tokenizers.find((r2) => r2.from == t2);
        return found ? found.to : t2;
      });
    if (config.dialect)
      copy.dialect = this.parseDialect(config.dialect);
    if (config.nested)
      copy.nested = this.nested.map((obj) => {
        if (!Object.prototype.hasOwnProperty.call(config.nested, obj.name))
          return obj;
        return { name: obj.name, value: config.nested[obj.name], end: obj.end, placeholder: obj.placeholder };
      });
    if (config.strict != null)
      copy.strict = config.strict;
    if (config.bufferLength != null)
      copy.bufferLength = config.bufferLength;
    return copy;
  }
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get hasNested() {
    return this.nested.length > 0;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences;
    return prec2 == null ? 0 : prec2[term] || 0;
  }
  parseDialect(dialect) {
    if (this.cachedDialect && this.cachedDialect.source == dialect)
      return this.cachedDialect;
    let values = Object.keys(this.dialects), flags = values.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id = values.indexOf(part);
        if (id >= 0)
          flags[id] = true;
      }
    let disabled = null;
    for (let i = 0; i < values.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
      }
    return this.cachedDialect = new Dialect(dialect, flags, disabled);
  }
  static deserialize(spec) {
    return new Parser(spec);
  }
};
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findOffset(data, start2, term) {
  for (let i = start2, next; (next = data[i]) != 65535; i++)
    if (next == term)
      return i - start2;
  return -1;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    if (stack.pos == stack.p.input.length && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}

// node_modules/lezer-rust/dist/index.es.js
var closureParamDelim = 1;
var tpOpen = 2;
var tpClose = 3;
var RawString = 4;
var Float = 5;
var _b = 98;
var _e = 101;
var _f = 102;
var _r = 114;
var _E = 69;
var Dot = 46;
var Plus = 43;
var Minus = 45;
var Hash = 35;
var Quote = 34;
var Pipe = 124;
var LessThan = 60;
var GreaterThan = 62;
function isNum(ch) {
  return ch >= 48 && ch <= 57;
}
function isNum_(ch) {
  return isNum(ch) || ch == 95;
}
var literalTokens = new ExternalTokenizer((input, token, stack) => {
  let pos = token.start, next = input.get(pos);
  if (isNum(next)) {
    let isFloat = false;
    do {
      next = input.get(++pos);
    } while (isNum_(next));
    if (next == Dot) {
      isFloat = true;
      next = input.get(++pos);
      if (isNum(next)) {
        do {
          next = input.get(++pos);
        } while (isNum_(next));
      } else if (next == Dot || next > 127 || /\w/.test(String.fromCharCode(next))) {
        return;
      }
    }
    if (next == _e || next == _E) {
      isFloat = true;
      next = input.get(++pos);
      if (next == Plus || next == Minus)
        next = input.get(++pos);
      let startNum = pos;
      while (isNum_(next))
        next = input.get(++pos);
      if (pos == startNum)
        return;
    }
    if (next == _f) {
      if (!/32|64/.test(input.read(pos + 1, pos + 3)))
        return;
      isFloat = true;
      pos += 3;
    }
    if (isFloat)
      token.accept(Float, pos);
  } else if (next == _b || next == _r) {
    if (next == _b)
      next = input.get(++pos);
    if (next != _r)
      return;
    next = input.get(++pos);
    let count = 0;
    while (next == Hash) {
      count++;
      next = input.get(++pos);
    }
    if (next != Quote)
      return;
    next = input.get(++pos);
    content:
      for (; ; ) {
        if (next < 0)
          return;
        let isQuote = next == Quote;
        next = input.get(++pos);
        if (isQuote) {
          for (let i = 0; i < count; i++) {
            if (next != Hash)
              continue content;
            next = input.get(++pos);
          }
          token.accept(RawString, pos);
          return;
        }
      }
  }
});
var closureParam = new ExternalTokenizer((input, token) => {
  if (input.get(token.start) == Pipe)
    token.accept(closureParamDelim, token.start + 1);
});
var tpDelim = new ExternalTokenizer((input, token) => {
  let pos = token.start, next = input.get(pos);
  if (next == LessThan)
    token.accept(tpOpen, pos + 1);
  else if (next == GreaterThan)
    token.accept(tpClose, pos + 1);
});
var spec_identifier = { __proto__: null, self: 28, super: 32, crate: 34, impl: 46, true: 72, false: 72, pub: 88, in: 92, const: 96, unsafe: 104, async: 108, move: 110, if: 114, let: 118, ref: 142, mut: 144, _: 198, else: 200, match: 204, as: 248, return: 252, await: 262, break: 270, continue: 276, while: 312, loop: 316, for: 320, macro_rules: 327, mod: 334, extern: 342, struct: 346, where: 364, union: 379, enum: 382, type: 390, default: 395, fn: 396, trait: 412, use: 420, static: 438, dyn: 476 };
var parser = Parser.deserialize({
  version: 13,
  states: "$3tQ]Q_OOP$wOWOOO&sQWO'#CnO)WQWO'#IaOOQP'#Ia'#IaOOQQ'#If'#IfO)hO`O'#C}OOQR'#Ii'#IiO)sQWO'#IvOOQO'#Hk'#HkO)xQWO'#DpOOQR'#Ix'#IxO)xQWO'#DpO*ZQWO'#DpOOQO'#Iw'#IwO,SQWO'#J`O,ZQWO'#EiOOQV'#Hp'#HpO,cQYO'#F{OOQV'#El'#ElOOQV'#Em'#EmOOQV'#En'#EnO.YQ_O'#EkO0_Q_O'#EoO2gQWOOO4QQ_O'#FPO7hQWO'#J`OOQV'#FY'#FYO7{Q_O'#F^O:WQ_O'#FaOOQO'#F`'#F`O=sQ_O'#FcO=}Q_O'#FbO@VQWO'#FgOOQO'#J`'#J`OOQV'#Ip'#IpOA]Q_O'#IoOEPQWO'#IoOOQV'#Fw'#FwOF[QWO'#JuOFcQWO'#F|OOQO'#IO'#IOOGrQWO'#GhOOQV'#In'#InOOQV'#Im'#ImOOQV'#Hj'#HjQGyQ_OOOKeQ_O'#DUOKlQYO'#CqOOQP'#I`'#I`OOQV'#Hg'#HgQ]Q_OOOLuQWO'#IaONsQYO'#DXO!!eQWO'#JuO!!lQWO'#JuO!!vQ_O'#DfO!%]Q_O'#E}O!(sQ_O'#FWO!,ZQWO'#FZO!.^QXO'#FbO!.cQ_O'#EeO!!vQ_O'#FmO!0uQWO'#FoO!0zQWO'#FoO!1PQ^O'#FqO!1WQWO'#JuO!1_QWO'#FtO!1dQWO'#FxO!2WQWO'#JjO!2_QWO'#GOO!2_QWO'#G`O!2_QWO'#GbO!2_QWO'#GsOOQO'#Ju'#JuO!2dQWO'#GhO!2lQYO'#GpO!2_QWO'#GqO!3uQ^O'#GtO!3|QWO'#GuO!4hQWO'#HOP!4sOpO'#CcPOOO)CDO)CDOOOOO'#Hi'#HiO!5OO`O,59iOOQV,59i,59iO!5ZQYO,5?bOOQO-E;i-E;iOOQO,5:[,5:[OOQP,59Z,59ZO)xQWO,5:[O)xQWO,5:[O!5oQWO,5?lO!5zQYO,5;qO!6PQYO,5;TO!6hQWO,59QO!7kQXO'#CnO!7rQXO'#IaO!8vQWO'#CoO,^QWO'#EiOOQV-E;n-E;nO!9XQWO'#FsOOQV,5<g,5<gO!8vQWO'#CoO!9^QWO'#CoO!9cQWO'#IaO! yQWO'#JuO!9mQWO'#J`O!:TQWO,5;VOOQO'#Io'#IoO!0zQWO'#DaO!<TQWO'#DcO!<]QWO,5;ZO.YQ_O,5;ZOOQO,5;[,5;[OOQV'#Er'#ErOOQV'#Es'#EsOOQV'#Et'#EtOOQV'#Eu'#EuOOQV'#Ev'#EvOOQV'#Ew'#EwOOQV'#Ex'#ExOOQV'#Ey'#EyO.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;]O.YQ_O,5;fO!<sQ_O,5;kO!@ZQ_O'#FROOQO,5;l,5;lO!BfQWO,5;pO.YQ_O,5;wOKlQYO,5;gO!DRQWO,5;kO!DrQWO,5;xOOQO,5;x,5;xO!EPQWO,5;xO!EUQ_O,5;xO!GaQWO'#CfO!GfQWO,5<QO!GpQ_O,5<QOOQO,5;{,5;{O!J^QXO'#CnO!KoQXO'#IaOOQS'#Dk'#DkOOQP'#Is'#IsO!LiQ[O'#IsO!LqQXO'#DjO!MoQWO'#DnO!MoQWO'#DnO!NQQWO'#DnOOQP'#Iu'#IuO!NVQXO'#IuO# QQ^O'#DoO# [QWO'#DrO# dQ^O'#DzO# nQ^O'#D|O# uQWO'#EPO#!QQXO'#FdOOQP'#ES'#ESOOQP'#Ir'#IrO#!`QXO'#JfOOQP'#Je'#JeO#!hQXO,5;}O#!mQXO'#IaO!1PQ^O'#DyO!1PQ^O'#FdO##gQWO,5;|OOQO,5;|,5;|OKlQYO,5;|O##}QWO'#FhOOQO,5<R,5<ROOQV,5=l,5=lO#&SQYO'#FzOOQV,5<h,5<hO#&ZQWO,5<hO#&bQWO,5=SO!1WQWO,59rO!1dQWO,5<dO#&iQWO,5=iO!2_QWO,5<jO!2_QWO,5<zO!2_QWO,5<|O!2_QWO,5=QO#&pQWO,5=]O#&wQWO,5=SO!2_QWO,5=]O!3|QWO,5=aO#'PQWO,5=jOOQO-E;|-E;|O#'[QWO'#JjOOQV-E;h-E;hO#'sQWO'#HRO#'zQ_O,59pOOQV,59p,59pO#(RQWO,59pO#(WQ_O,59pO#(vQZO'#CuO#+OQZO'#CvOOQV'#C|'#C|O#-kQWO'#HTO#-rQYO'#IeOOQO'#Hh'#HhO#-zQWO'#CwO#-zQWO'#CwO#.]QWO'#CwOOQR'#Id'#IdO#.bQZO'#IcO#0wQYO'#HTO#1eQYO'#H[O#2qQYO'#H_OKlQYO'#H`OOQR'#Hb'#HbO#3}QWO'#HeO#4SQYO,59]OOQR'#Ic'#IcO#4sQZO'#CtO#7OQYO'#HUO#7TQWO'#HTO#7YQYO'#CrO#7yQWO'#H]O#7YQYO'#HcOOQV-E;e-E;eO#8RQWO,59sOOQV,59{,59{O#8aQYO,5=[OOQV,59},59}O!0zQWO,59}O#;TQWO'#IqOOQO'#Iq'#IqO!1PQ^O'#DhO!0zQWO,5:QO#;[QWO,5;iO#;rQWO,5;rO#<YQ_O,5;rOOQO,5;u,5;uO#?sQ_O,5;|O#A{QWO,5;PO!0zQWO,5<XO#BSQWO,5<ZOOQV,5<Z,5<ZO#B_QWO,5<]O!1PQ^O'#EOOOQQ'#D_'#D_O#BgQWO,59rO#BlQWO,5<`O#BqQWO,5<dOOQO,5@U,5@UO#ByQWO,5=iOOQQ'#Cv'#CvO#COQYO,5<jO#CaQYO,5<zO#ClQYO,5<|O#CwQYO,5=_O#DVQYO,5=SO#EoQYO'#GQO#E|QYO,5=[O#FaQWO,5=[O#FoQYO,5=[O#GxQYO,5=]O#HWQWO,5=`O!1PQ^O,5=`O#HfQWO'#CnO#HwQWO'#IaOOQO'#Jy'#JyO#IYQWO'#IQO#I_QWO'#GwOOQO'#Jz'#JzO#IvQWO'#GzOOQO'#G|'#G|OOQO'#Jx'#JxO#I_QWO'#GwO#I}QWO'#GxO#JSQWO,5=aO#JXQWO,5=jO!1dQWO,5=jO#'SQWO,5=jPOOO'#Hf'#HfP#J^OpO,58}POOO,58},58}OOOO-E;g-E;gOOQV1G/T1G/TO#JiQWO1G4|O#JnQ^O'#CyPOQQ'#Cx'#CxOOQO1G/v1G/vOOQP1G.u1G.uO)xQWO1G/vO#MwQ!fO'#EUO#NOQ!fO'#EVO#NVQ!fO'#ETO$ _QWO1G5WO$!RQ_O1G5WOOQO1G1]1G1]O$%uQWO1G0oO$%zQWO'#CiO!7rQXO'#IaO!6PQYO1G.lO!5oQWO,5<_O!8vQWO,59ZO!8vQWO,59ZO!5oQWO,5?lO$&]QWO1G0uO$(jQWO1G0wO$*bQWO1G0wO$*xQWO1G0wO$,|QWO1G0wO$-TQWO1G0wO$/UQWO1G0wO$/]QWO1G0wO$1^QWO1G0wO$1eQWO1G0wO$2|QWO1G1QO$4}QWO1G1VO$5nQ_O'#JcO$7vQWO'#JcOOQO'#Jb'#JbO$8QQWO,5;mOOQO'#Dw'#DwOOQO1G1[1G1[OOQO1G1Y1G1YO$8VQWO1G1cOOQO1G1R1G1RO$8^Q_O'#HrO$:lQWO,5@OO.YQ_O1G1dOOQO1G1d1G1dO$:tQWO1G1dO$;RQWO1G1dO$;WQWO1G1eOOQO1G1l1G1lO$;`QWO1G1lOOQP,5?_,5?_O$;jQ^O,5:kO$<TQXO,5:YO!MoQWO,5:YO!MoQWO,5:YO!1PQ^O,5:gO$=UQWO'#IzOOQO'#Iy'#IyO$=dQWO,5:ZO# QQ^O,5:ZO$=iQWO'#DsOOQP,5:^,5:^O$=zQWO,5:fOOQP,5:h,5:hO!1PQ^O,5:hO!1PQ^O,5:mO$>PQYO,5<OO$>ZQ_O'#HsO$>hQXO,5@QOOQV1G1i1G1iOOQP,5:e,5:eO$>pQXO,5<OO$?OQWO1G1hO$?WQWO'#CnO$?cQWO'#FiOOQO'#Fi'#FiO$?kQWO'#FjO.YQ_O'#FkOOQO'#Ji'#JiO$?pQWO'#JhOOQO'#Jg'#JgO$?xQWO,5<SOOQQ'#Hv'#HvO$?}QYO,5<fOOQV,5<f,5<fO$@UQYO,5<fOOQV1G2S1G2SO$@]QWO1G2nO$@eQWO1G/^O$@jQWO1G2OO#ByQWO1G3TO$@rQYO1G2UO#CaQYO1G2fO#ClQYO1G2hO$ATQYO1G2lO!2_QWO1G2wO#DVQYO1G2nO#GxQYO1G2wO$A]QWO1G2{O$AbQWO1G3UO!1dQWO1G3UO$AgQWO1G3UOOQV1G/[1G/[O$AoQWO1G/[O$AtQ_O1G/[O#7TQWO,5=oO$A{QYO,5?PO$BaQWO,5?PO$BfQZO'#IfOOQO-E;f-E;fOOQR,59c,59cO#-zQWO,59cO#-zQWO,59cOOQR,5=n,5=nO$ERQYO'#HVO$FkQZO,5=oO!5oQWO,5={O$H}QWO,5=oO$IUQZO,5=vO$KeQYO,5=vO$>PQYO,5=vO$KuQWO'#KRO$LQQWO,5=xOOQR,5=y,5=yO$LVQWO,5=zO$>PQYO,5>PO$>PQYO,5>POOQO1G.w1G.wO$>PQYO1G.wO$LbQYO,5=pO$LjQZO,59^OOQR,59^,59^O$>PQYO,5=wO$N|QZO,5=}OOQR,5=},5=}O%#`QWO1G/_O!6PQYO1G/_O#E|QYO1G2vO%#eQWO1G2vO%#sQYO1G2vOOQV1G/i1G/iO%$|QWO,5:SO%%UQ_O1G/lO%*_QWO1G1^O%*uQWO1G1hOOQO1G1h1G1hO$>PQYO1G1hO%+]Q^O'#EgOOQV1G0k1G0kOOQV1G1s1G1sO!!vQ_O1G1sO!0zQWO1G1uO!1PQ^O1G1wO!.cQ_O1G1wOOQP,5:j,5:jO$>PQYO1G/^OOQO'#Cn'#CnO%+jQWO1G1zOOQV1G2O1G2OO%+rQWO'#CnO%+zQWO1G3TO%,PQWO1G3TO%,UQYO'#GQO%,gQWO'#G]O%,xQYO'#G_O%.[QYO'#GXOOQV1G2U1G2UO%/kQWO1G2UO%/pQWO1G2UO$@uQWO1G2UOOQV1G2f1G2fO%/kQWO1G2fO#CdQWO1G2fO%/xQWO'#GdOOQV1G2h1G2hO%0ZQWO1G2hO#CoQWO1G2hO%0`QYO'#GSO$>PQYO1G2lO$AWQWO1G2lOOQV1G2y1G2yO%1lQWO1G2yO%3[Q^O'#GkO%3fQWO1G2nO#DYQWO1G2nO%3tQYO,5<lO%4OQYO,5<lO%4^QYO,5<lO%4{QYO,5<lOOQQ,5<l,5<lO!1WQWO'#JuO%5WQYO,5<lO%5`QWO1G2vOOQV1G2v1G2vO%5hQWO1G2vO$>PQYO1G2vOOQV1G2w1G2wO%5hQWO1G2wO%5mQWO1G2wO#G{QWO1G2wOOQV1G2z1G2zO.YQ_O1G2zO$>PQYO1G2zO%5uQWO1G2zOOQO,5>l,5>lOOQO-E<O-E<OOOQO,5=c,5=cOOQO,5=e,5=eOOQO,5=g,5=gOOQO,5=h,5=hO%6TQWO'#J|OOQO'#J{'#J{O%6]QWO,5=fO%6bQWO,5=cO!1dQWO,5=dOOQV1G2{1G2{O$>PQYO1G3UPOOO-E;d-E;dPOOO1G.i1G.iOOQO7+*h7+*hO%6yQYO'#IdO%7bQYO'#IgO%7mQYO'#IgO%7uQYO'#IgO%8QQYO,59eOOQO7+%b7+%bOOQP7+$a7+$aOOQV,5:p,5:pO%8VQ!fO,5:pO%8^Q!fO'#JTOOQS'#EZ'#EZOOQS'#E['#E[OOQS'#E]'#E]OOQS'#JT'#JTO%;PQWO'#EYOOQS'#Eb'#EbOOQS'#JR'#JROOQS'#Hn'#HnOOQV,5:q,5:qO%;UQ!fO,5:qO%;]Q!fO,5:oOOQV,5:o,5:oOOQV7+'e7+'eOOQV7+&Z7+&ZO%;dQ[O,59TO%;xQ^O,59TO%<cQWO7+$WO%<hQWO1G1yOOQV1G1y1G1yO!8vQWO1G.uOOQP1G5W1G5WO%<mQWO,5?}O%<wQ_O'#HqO%?SQWO,5?}OOQO1G1X1G1XOOQO7+&}7+&}O%?[QWO,5>^OOQO-E;p-E;pO%?iQWO7+'OO%?pQ_O7+'OOOQO7+'O7+'OOOQO7+'P7+'PO%ArQWO7+'POOQO7+'W7+'WOOQP1G0V1G0VO%AzQXO1G/tO!MoQWO1G/tO%B{QXO1G0RO%CsQ^O'#HlO%DTQWO,5?fOOQP1G/u1G/uO%D`QWO1G/uO%DeQWO'#D_OOQO'#Dt'#DtO%DpQWO'#DtO%DuQWO'#I|OOQO'#I{'#I{O%D}QWO,5:_O%ESQWO'#DtO%EXQWO'#DtOOQP1G0Q1G0QOOQP1G0S1G0SOOQP1G0X1G0XO%EaQXO1G1jO%ElQXO'#FeOOQP,5>_,5>_O!1PQ^O'#FeOOQP-E;q-E;qO$>PQYO1G1jOOQO7+'S7+'SOOQO,5<T,5<TO%EzQWO,5<UO%?pQ_O,5<UO%FPQWO,5<VO%FZQWO'#HtO%FlQWO,5@SOOQO1G1n1G1nOOQQ-E;t-E;tOOQV1G2Q1G2QO%FtQYO1G2QO#DVQYO7+(YO$>PQYO7+$xOOQV7+'j7+'jO%F{QWO7+(oO%GQQWO7+(oOOQV7+'p7+'pO%/kQWO7+'pO%GVQWO7+'pO%G_QWO7+'pOOQV7+(Q7+(QO%/kQWO7+(QO#CdQWO7+(QOOQV7+(S7+(SO%0ZQWO7+(SO#CoQWO7+(SO$>PQYO7+(WO%GmQWO7+(WO#GxQYO7+(cO%GrQWO7+(YO#DYQWO7+(YOOQV7+(c7+(cO%5hQWO7+(cO%5mQWO7+(cO#G{QWO7+(cOOQV7+(g7+(gO$>PQYO7+(pO%HQQWO7+(pO!1dQWO7+(pOOQV7+$v7+$vO%HVQWO7+$vO%H[QZO1G3ZO%JnQWO1G4kOOQO1G4k1G4kOOQR1G.}1G.}O#-zQWO1G.}O%JsQWO'#KQOOQO'#HW'#HWO%KUQWO'#HXO%KaQWO'#KQOOQO'#KP'#KPO%KiQWO,5=qO%KnQYO'#H[O%LzQWO'#GmO%MVQYO'#CtO%MaQWO'#GmO$>PQYO1G3ZOOQR1G3g1G3gO#7TQWO1G3ZO%MfQZO1G3bO$>PQYO1G3bO& uQYO'#IVO&!VQWO,5@mOOQR1G3d1G3dOOQR1G3f1G3fO%?pQ_O1G3fOOQR1G3k1G3kO&!_QYO7+$cO&!gQYO'#KOOOQQ'#J}'#J}O&!oQYO1G3[O&!tQZO1G3cOOQQ7+$y7+$yO&%TQWO7+$yO&%YQWO7+(bOOQV7+(b7+(bO%5hQWO7+(bO$>PQYO7+(bO#E|QYO7+(bO&%bQWO7+(bO!.cQ_O1G/nO&%pQWO7+%WO$?OQWO7+'SO&%xQWO'#EhO&&TQ^O'#EhOOQU'#Ho'#HoO&&TQ^O,5;ROOQV,5;R,5;RO&&_QWO,5;RO&&dQ^O,5;RO!0zQWO7+'_OOQV7+'a7+'aO&&qQWO7+'cO&&yQWO7+'cO&'QQWO7+$xO&)uQ!fO7+'fO&)|Q!fO7+'fOOQV7+(o7+(oO!1dQWO7+(oO&*TQYO,5<lO&*`QYO,5<lO!1dQWO'#GWO&*nQWO'#JpO&*|QWO'#G^O!BlQWO'#G^O&+RQWO'#JpOOQO'#Jo'#JoO&+ZQWO,5<wOOQO'#DX'#DXO&+`QYO'#JrO&,oQWO'#JrO$>PQYO'#JrOOQO'#Jq'#JqO&,zQWO,5<yO&-PQWO'#GZO#DQQWO'#G[O&-XQWO'#G[O&-aQWO'#JmOOQO'#Jl'#JlO&-lQYO'#GTOOQO,5<s,5<sO&-qQWO7+'pO&-vQWO'#JtO&.UQWO'#GeO#BlQWO'#GeO&.gQWO'#JtOOQO'#Js'#JsO&.oQWO,5=OO$>PQYO'#GUO&.tQYO'#JkOOQQ,5<n,5<nO&/]QWO7+(WOOQV7+(e7+(eO&/eQ^O'#D|O&0kQWO'#GlO&0sQ^O'#JwOOQO'#Gn'#GnO&0zQWO'#JwOOQO'#Jv'#JvO&1SQWO,5=VO&1XQWO'#IaO&1iQ^O'#GmO&2lQWO'#IrO&2zQWO'#GmOOQV7+(Y7+(YO&3SQWO7+(YO$>PQYO7+(YO&3[QYO'#HxO&3pQYO1G2WOOQQ1G2W1G2WOOQQ,5<m,5<mO$>PQYO,5<qO&3xQWO,5<rO&3}QWO7+(bO&4YQWO7+(fO&4aQWO7+(fOOQV7+(f7+(fO%?pQ_O7+(fO$>PQYO7+(fO&4lQWO'#IRO&4vQWO,5@hOOQO1G3Q1G3QOOQO1G2}1G2}OOQO1G3P1G3POOQO1G3R1G3ROOQO1G3S1G3SOOQO1G3O1G3OO&5OQWO7+(pO$>PQYO,59fO&5ZQ^O'#ISO&6QQYO,5?ROOQR1G/P1G/POOQV1G0[1G0[OOQS-E;l-E;lO&6YQ!bO,5:rO&6_Q!fO,5:tOOQV1G0]1G0]OOQV1G0Z1G0ZOOQO1G.o1G.oO&6fQWO'#KTOOQO'#KS'#KSO&6nQWO1G.oOOQV<<Gr<<GrO&6sQWO1G5iO&6{Q_O,5>]O&9QQWO,5>]OOQO-E;o-E;oOOQO<<Jj<<JjO&9[QWO<<JjOOQO<<Jk<<JkO&9cQXO7+%`O&:dQWO,5>WOOQO-E;j-E;jOOQP7+%a7+%aO!1PQ^O,5:`O&:rQWO'#HmO&;WQWO,5?hOOQP1G/y1G/yOOQO,5:`,5:`O&;`QWO,5:`O%ESQWO,5:`O$>PQYO,5<PO&;eQXO,5<PO&;sQXO7+'UO%?pQ_O1G1pO&<OQWO1G1pOOQO,5>`,5>`OOQO-E;r-E;rOOQV7+'l7+'lO&<YQWO<<KtO#DYQWO<<KtO&<hQWO<<HdOOQV<<LZ<<LZO!1dQWO<<LZOOQV<<K[<<K[O&<sQWO<<K[O%/kQWO<<K[O&<xQWO<<K[OOQV<<Kl<<KlO%/kQWO<<KlOOQV<<Kn<<KnO%0ZQWO<<KnO&=QQWO<<KrO$>PQYO<<KrOOQV<<K}<<K}O%5hQWO<<K}O%5mQWO<<K}O#G{QWO<<K}OOQV<<Kt<<KtO&=YQWO<<KtO$>PQYO<<KtO&=bQWO<<L[O$>PQYO<<L[O&=mQWO<<L[OOQV<<Hb<<HbO$>PQYO7+(uOOQO7+*V7+*VOOQR7+$i7+$iO&=rQWO,5@lOOQO'#Gm'#GmO&=zQWO'#GmO&>VQYO'#IUO&=rQWO,5@lOOQR1G3]1G3]O&?rQYO,5=vO&ARQYO,5=XO&A]QWO,5=XOOQO,5=X,5=XOOQR7+(u7+(uO&AbQZO7+(uO&CtQZO7+(|O&FTQWO,5>qOOQO-E<T-E<TO&F`QWO7+)QOOQO<<G}<<G}O&FgQYO'#ITO&FrQYO,5@jOOQQ7+(v7+(vOOQQ<<He<<HeO$>PQYO<<K|OOQV<<K|<<K|O&3}QWO<<K|O&FzQWO<<K|O%5hQWO<<K|O&GSQWO7+%YOOQV<<Hr<<HrOOQO<<Jn<<JnO%?pQ_O,5;SO&GZQWO,5;SO%?pQ_O'#EjO&G`QWO,5;SOOQU-E;m-E;mO&GkQWO1G0mOOQV1G0m1G0mO&&TQ^O1G0mOOQV<<Jy<<JyO!.cQ_O<<J}OOQV<<J}<<J}OOQV<<Hd<<HdO%?pQ_O<<HdO&GpQWO'#JTO&GxQWO'#FvO&G}QWO<<KQO&HVQ!fO<<KQO&H^QWO<<KQO&HcQWO<<KQO&HkQ!fO<<KQOOQV<<KQ<<KQO&HrQWO<<LZO&HwQWO,5@[O$>PQYO,5<xO&IPQWO,5<xO&IUQWO'#H{O&HwQWO,5@[OOQV1G2c1G2cO&IjQWO,5@^O$>PQYO,5@^O&IuQYO'#H|O&K[QWO,5@^OOQO1G2e1G2eO%,bQWO,5<uOOQO,5<v,5<vO&KdQYO'#HzO&LvQWO,5@XO%,UQYO,5=pO$>PQYO,5<oO&MRQWO,5@`O%?pQ_O,5=PO&MZQWO,5=PO&MfQWO,5=PO&MwQWO'#H}O&MRQWO,5@`OOQV1G2j1G2jO&N]QYO,5<pO%0`QYO,5>PO&NtQYO,5@VOOQV<<Kr<<KrO' ]QWO,5=XO' mQ^O,5:hO'!pQWO,5=XO$>PQYO,5=WO'!xQWO,5@cO'#QQWO,5@cO'#`Q^O'#IPO'!xQWO,5@cOOQO1G2q1G2qO'$rQWO,5=WO'$zQWO<<KtO'%YQYO,5>oO'%eQYO,5>dO'%sQYO,5>dOOQQ,5>d,5>dOOQQ-E;v-E;vOOQQ7+'r7+'rO'&OQYO1G2]O$>PQYO1G2^OOQV<<LQ<<LQO%?pQ_O<<LQO'&ZQWO<<LQO'&bQWO<<LQOOQO,5>m,5>mOOQO-E<P-E<POOQV<<L[<<L[O%?pQ_O<<L[O'&mQYO1G/QO'&xQYO,5>nOOQQ,5>n,5>nO''TQYO,5>nOOQQ-E<Q-E<QOOQS1G0^1G0^O')cQ!fO1G0`O')pQ!fO1G0`O')wQ^O'#IWO'*eQWO,5@oOOQO7+$Z7+$ZO'*mQWO1G3wOOQOAN@UAN@UO'*wQWO1G/zOOQO,5>X,5>XOOQO-E;k-E;kO!1PQ^O1G/zOOQO1G/z1G/zO'+SQWO1G/zO'+XQXO1G1kO$>PQYO1G1kO'+dQWO7+'[OOQVANA`ANA`O'+nQWOANA`O$>PQYOANA`O'+vQWOANA`OOQVAN>OAN>OO%?pQ_OAN>OO',UQWOANAuOOQVAN@vAN@vO',ZQWOAN@vOOQVANAWANAWOOQVANAYANAYOOQVANA^ANA^O',`QWOANA^OOQVANAiANAiO%5hQWOANAiO%5mQWOANAiO',hQWOANA`OOQVANAvANAvO%?pQ_OANAvO',vQWOANAvO$>PQYOANAvOOQR<<La<<LaO'-RQWO1G6WO%JsQWO,5>pOOQO'#HY'#HYO'-ZQWO'#HZOOQO,5>p,5>pOOQO-E<S-E<SO'-fQYO1G2sO'-pQWO1G2sOOQO1G2s1G2sO$>PQYO<<LaOOQR<<Ll<<LlOOQQ,5>o,5>oOOQQ-E<R-E<RO&3}QWOANAhOOQVANAhANAhO%5hQWOANAhO$>PQYOANAhO'-uQWO1G1rO'.iQ^O1G0nO%?pQ_O1G0nO'0_QWO,5;UO'0fQWO1G0nP'0kQWO'#ERP&&TQ^O'#HpOOQV7+&X7+&XO'0vQWO7+&XO&&yQWOAN@iO'0{QWOAN>OO!5oQWO,5<bOOQS,5>a,5>aO'1SQWOAN@lO'1XQWOAN@lOOQS-E;s-E;sOOQVAN@lAN@lO'1aQWOAN@lOOQVANAuANAuO'1iQWO1G5vO'1qQWO1G2dO$>PQYO1G2dO&*nQWO,5>gOOQO,5>g,5>gOOQO-E;y-E;yO'1|QWO1G5xO'2UQWO1G5xO&+`QYO,5>hO'2aQWO,5>hO$>PQYO,5>hOOQO-E;z-E;zO'2lQWO'#JnOOQO1G2a1G2aOOQO,5>f,5>fOOQO-E;x-E;xO&*TQYO,5<lO'2zQYO1G2ZO'3fQWO1G5zO'3nQWO1G2kO%?pQ_O1G2kO'3xQWO1G2kO&-vQWO,5>iOOQO,5>i,5>iOOQO-E;{-E;{OOQQ,5>c,5>cOOQQ-E;u-E;uO'4TQWO1G2sO'4eQWO1G2rO'4pQWO1G5}O'4xQ^O,5>kOOQO'#Go'#GoOOQO,5>k,5>kO'6UQWO,5>kOOQO-E;}-E;}O$>PQYO1G2rO'6dQYO7+'xO'6oQWOANAlOOQVANAlANAlO%?pQ_OANAlO'6vQWOANAvOOQS7+%z7+%zO'6}QWO7+%zO'7YQ!fO7+%zOOQO,5>r,5>rOOQO-E<U-E<UO'7gQWO7+%fO!1PQ^O7+%fO'7rQXO7+'VOOQVG26zG26zO'7}QWOG26zO'8]QWOG26zO$>PQYOG26zO'8eQWOG23jOOQVG27aG27aOOQVG26bG26bOOQVG26xG26xOOQVG27TG27TO%5hQWOG27TO'8lQWOG27bOOQVG27bG27bO%?pQ_OG27bO'8sQWOG27bOOQO1G4[1G4[OOQO7+(_7+(_OOQRANA{ANA{OOQVG27SG27SO%5hQWOG27SO&3}QWOG27SO'9OQ^O7+&YO':iQWO7+'^O';]Q^O7+&YO%?pQ_O7+&YP%?pQ_O,5;SP'<iQWO,5;SP'<nQWO,5;SOOQV<<Is<<IsOOQVG26TG26TOOQVG23jG23jOOQO1G1|1G1|OOQVG26WG26WO'<yQWOG26WP&HfQWO'#HuO'=OQWO7+(OOOQO1G4R1G4RO'=ZQWO7++dO'=cQWO1G4SO$>PQYO1G4SO%,bQWO'#HyO'=nQWO,5@YO'=|QWO7+(VO%?pQ_O7+(VOOQO1G4T1G4TOOQO1G4V1G4VO'>WQWO1G4VO'>fQWO7+(^OOQVG27WG27WO'>qQWOG27WOOQS<<If<<IfO'>xQWO<<IfO'?TQWO<<IQOOQVLD,fLD,fO'?`QWOLD,fO'?hQWOLD,fOOQVLD)ULD)UOOQVLD,oLD,oOOQVLD,|LD,|O'?vQWOLD,|O%?pQ_OLD,|OOQVLD,nLD,nO%5hQWOLD,nO'?}Q^O<<ItO'AhQWO<<JxO'B[Q^O<<ItP'ChQWO1G0nP'DXQ^O1G0nP%?pQ_O1G0nP'EzQWO1G0nOOQVLD+rLD+rO'FPQWO7+)nOOQO,5>e,5>eOOQO-E;w-E;wO'F[QWO<<KqOOQVLD,rLD,rOOQSAN?QAN?QOOQV!$(!Q!$(!QO'FfQWO!$(!QOOQV!$(!h!$(!hO'FnQWO!$(!hOOQV!$(!Y!$(!YO'FuQ^OAN?`POQU7+&Y7+&YP'H`QWO7+&YP'IPQ^O7+&YP%?pQ_O7+&YOOQV!)9El!)9ElOOQV!)9FS!)9FSPOQU<<It<<ItP'JrQWO<<ItP'KcQ^O<<ItPOQUAN?`AN?`O'MUQWO'#CnO'M]QXO'#CnO'NUQWO'#IaO( kQXO'#IaO(!bQWO'#DpO(!bQWO'#DpO!.cQ_O'#EkO(!sQ_O'#EoO(!zQ_O'#FPO(%{Q_O'#FbO(&SQXO'#IaO(&yQ_O'#E}O('|Q_O'#FWO(!bQWO,5:[O(!bQWO,5:[O!.cQ_O,5;ZO!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;]O!.cQ_O,5;fO()PQ_O,5;kO(,QQWO,5;kO(,bQWO,5;|O(,iQYO'#CuO(,tQYO'#CvO(-PQWO'#CwO(-PQWO'#CwO(-bQYO'#CtO(-mQWO,5;iO(-tQWO,5;rO(-{Q_O,5;rO(/RQ_O,5;|O(!bQWO1G/vO(/YQWO1G0uO(0wQWO1G0wO(1RQWO1G0wO(2vQWO1G0wO(2}QWO1G0wO(4oQWO1G0wO(4vQWO1G0wO(6hQWO1G0wO(6oQWO1G0wO(6vQWO1G1QO(7WQWO1G1VO(7hQYO'#IfO(-PQWO,59cO(-PQWO,59cO(7sQWO1G1^O(7zQWO1G1hO(-PQWO1G.}O(8RQWO'#DpO!.^QXO'#FbO(8WQWO,5;ZO(8_QWO'#Cw",
  stateData: "(8q~O&}OSUOS'OPQ~OPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'R`O'UQO'[kO'_UO'hcO'riO(QdO~O'O!sO~OZbX[bXdbXdlXobXwjX}bX!lbX!qbX!tbX#QbX#RbX#pbX'hbX'rbX'sbX'xbX'ybX'zbX'{bX'|bX'}bX(ObX(PbX(QbX(RbX(TbX~OybXXbX!ebX!PbXvbX#TbX~P$|OZ'TX['TXd'TXd'YXo'TXw'lXy'TX}'TX!l'TX!q'TX!t'TX#Q'TX#R'TX#p'TX'h'TX'r'TX's'TX'x'TX'y'TX'z'TX'{'TX'|'TX'}'TX(O'TX(P'TX(Q'TX(R'TX(T'TXv'TX~OX'TX!e'TX!P'TX#T'TX~P'ZOr!uO'^!wO'`!uO~Od!xO~O^RO_RO`ROaRO'UQO~Od!}O~Od#PO[(SXo(SXy(SX}(SX!l(SX!q(SX!t(SX#Q(SX#R(SX#p(SX'h(SX'r(SX's(SX'x(SX'y(SX'z(SX'{(SX'|(SX'}(SX(O(SX(P(SX(Q(SX(R(SX(T(SXv(SX~OZ#OO~P*`OZ#RO[#QO~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'R#VO'U#SO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!j#eO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdO~P)xO[#}Oo#xO}#zO!l#yO!q#jO!t#yO#Q#xO#R#uO#p$OO'h#gO'r#yO's#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~OPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO[#sXo#sXy#sX}#sX!l#sX!q#sX!t#sX#Q#sX#R#sX#p#sX'h#sX'r#sX's#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sXX#sX!e#sX!P#sXv#sX#T#sX~P)xOX(SX!e(SX!P(SXw(SX#T(SX~P*`OPoOQ!QOSVOTVOX$ROZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R$UO'[kO'_UO'hcO'riO(QdO~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!P$XO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R$UO'[kO'_UO'hcO'riO(QdO~P)xOQ!QOSVOTVO[$gO^$pO_$ZO`:QOa:QOd$aOsVOtVOuVO}$eO!i$qO!l$lO!q$hO#V$lO'U$YO'_UO'h$[O~O!j$rOP(XP~P<cOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#S$uO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdO~P)xOw$vO~Oo'cX#Q'cX#R'cX#p'cX's'cX'x'cX'y'cX'z'cX'{'cX'|'cX'}'cX(O'cX(P'cX(R'cX(T'cX~OP%tXQ%tXS%tXT%tXZ%tX[%tX^%tX_%tX`%tXa%tXd%tXg%tXs%tXt%tXu%tXw%tXy%tX|%tX}%tX!Q%tX!U%tX!W%tX!X%tX!Z%tX!]%tX!l%tX!q%tX!t%tX#Y%tX#r%tX#{%tX$O%tX$b%tX$d%tX$f%tX$i%tX$m%tX$q%tX$s%tX%T%tX%V%tX%Z%tX%]%tX%^%tX%f%tX%j%tX%s%tX&{%tX'R%tX'U%tX'[%tX'_%tX'h%tX'r%tX(Q%tXv%tX~P@[Oy$xO['cX}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cXv'cX~P@[Ow$yO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Oy$zO~PEsO!Q$}O!U%UO!W!lO$m%OO$q%PO$s%QO%T%RO%V%SO%Z%TO%]!lO%^%VO%f%WO%j%XO%s%YO~O!Q!lO!U!lO!W!lO$q%[O%]!lO~O%^%VO~PGaOPoOQ!QOSVOTVOZeO[lO^RO_RO`ROa!UOd[Og!nOsVOtVOuVOw!POyvO|!VO}mO!Q!dO!U!WO!W!XO!X!^O!Z!YO!]!pO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'R#VO'UQO'[kO'_UO'hcO'riO(QdO~Ov%`O~P]OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~P'ZO!Q{X!U{X!W{X$m{X$q{X$s{X%T{X%V{X%Z{X%]{X%^{X%f{X%j{X%s{X~O}%}O'U{XQ{XZ{X[{X^{X_{X`{Xa{Xd{Xg{X!q{X$f{X&W{X'[{X(Q{X~PMuOg&PO%f%WO!Q(iX!U(iX!W(iX$q(iX%](iX%^(iX~Ow!PO~P! yOw!PO!X&RO~PEvOPoOQ!QOSVOTVOZeO[lO^9xO_9xO`9xOa9xOd9{OsVOtVOuVOw!PO}mO!U#bO!W#cO!X;RO!Z!YO!]&UO!l:OO!q9}O!t:OO#Y!_O#r:RO#{:SO$O!]O$b!`O$d!bO$f!cO'U9vO'[kO'_UO'hcO'r:OO(QdO~OPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdOo#qXy#qX#Q#qX#R#qX#p#qX's#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qXX#qX!e#qX!P#qXv#qX#T#qX~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdOo#zXy#zX#Q#zX#R#zX#p#zX's#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zXX#zX!e#zX!P#zXv#zX#T#zX~P)xO'[kO[#}Xo#}Xy#}X}#}X!l#}X!q#}X!t#}X#Q#}X#R#}X#p#}X'h#}X'r#}X's#}X'x#}X'y#}X'z#}X'{#}X'|#}X'}#}X(O#}X(P#}X(Q#}X(R#}X(T#}XX#}X!e#}X!P#}Xv#}Xw#}X#T#}X~OPoO~OPoOQ!QOSVOTVOZeO[lO^9xO_9xO`9xOa9xOd9{OsVOtVOuVOw!PO}mO!U#bO!W#cO!X;RO!Z!YO!l:OO!q9}O!t:OO#Y!_O#r:RO#{:SO$O!]O$b!`O$d!bO$f!cO'U9vO'[kO'_UO'hcO'r:OO(QdO~O!S&_O~Ow!PO~O!j&bO~P<cO'U&cO~PEvOZ&eO~O'U&cO~O'_UOw(^Xy(^X!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Oa&hO~P!1iO'U&iO~O_&nO'U&cO~OQ&oOZ&pO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaO!j&uO~P<cO^&wO_&wO`&wOa&wOd'POw&|O'U&vO(Q&}O~O!i'UO!j'TO'U&cO~O'O!sO'P'VO'Q'XO~Or!uO'^'ZO'`!uO~OQ']O^'ja_'ja`'jaa'ja'U'ja~O['bOw'cO}'dO~OQ']O~OQ!QO^#TO_#TO`#TOa'jOd#ZO'U#SO~O['kO~OZbXdlXXbXobXPbX!SbX!ebX'sbX!PbX!ObXybX!ZbX#TbXvbX~O}bX~P!6mOZ'TXd'YXX'TXo'TX}'TX#p'TXP'TX!S'TX!e'TX's'TX!P'TX!O'TXy'TX!Z'TX#T'TXv'TX~O^#TO_#TO`#TOa'jO'U#SO~OZ'lO~Od'nO~OZ'TXd'YX~PMuOZ'oOX(SX!e(SX!P(SXw(SX#T(SX~P*`O[#}O}#zO(O#|O(R#fOo#_ay#_a!l#_a!q#_a!t#_a#Q#_a#R#_a#p#_a'h#_a'r#_a's#_a'x#_a'y#_a'z#_a'{#_a'|#_a'}#_a(P#_a(Q#_a(T#_aX#_a!e#_a!P#_av#_aw#_a#T#_a~Ow!PO!X&RO~Oy#caX#ca!e#ca!P#cav#ca#T#ca~P2gOPoOQ!QOSVOTVOZeOd[OsVOtVOuVOw!PO!U#bO!W#cO!X!^O!Z!YO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO[#sao#say#sa}#sa!l#sa!q#sa!t#sa#Q#sa#R#sa#p#sa'h#sa'r#sa's#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#saX#sa!e#sa!P#sav#sa#T#sa~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R#VO'[kO'_UO'hcO'riO(QdO!P(UP~P)xOu(RO#w(SO'U(QO~O[#}O}#zO!q#jO'h#gO's#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#sa!t#sa#p#sa'r#sa~Oo#xO#Q#xO#R#uOy#saX#sa!e#sa!P#sav#sa#T#sa~P!BqOy(XO!e(VOX(WX~P2gOX(YO~OPoOQ!QOSVOTVOX(YOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R$UO'[kO'_UO'hcO'riO(QdO~P)xOZ#RO~O!P(^O!e(VO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R$UO'[kO'_UO'hcO'riO(QdO~P)xOZbXdlXwjX}jX!tbX'rbX~OP!RX!S!RX!e!RX'q!RX's!RX!O!RXo!RXy!RX!P!RXX!RX!Z!RX#T!RXv!RX~P!IxOZ'TXd'YXw'lX}'lX!t'TX'r'TX~OP!`X!S!`X!e!`X's!`X!O!`Xo!`Xy!`X!P!`XX!`X!Z!`X#T!`Xv!`X~P!KZOT(`Ou(`O~O!t(aO'r(aOP!^X!S!^X!e!^X's!^X!O!^Xo!^Xy!^X!P!^XX!^X!Z!^X#T!^Xv!^X~O^9yO_9yO`:QOa:QO'U9wO~Od(dO~O'q(eOP'iX!S'iX!e'iX's'iX!O'iXo'iXy'iX!P'iXX'iX!Z'iX#T'iXv'iX~O!j&bO!P'mP~P<cOw(jO}(iO~O!j&bOX'mP~P<cO!j(nO~P<cOZ'oO!t(aO'r(aO~O!S(pO's(oOP$WX!e$WX~O!e(qOP(YX~OP(sO~OP!aX!S!aX!e!aX's!aX!O!aXo!aXy!aX!P!aXX!aX!Z!aX#T!aXv!aX~P!KZOy$UaX$Ua!e$Ua!P$Uav$Ua#T$Ua~P2gO!l({O'R#VO'U(wOv(ZP~OQ!QO^#TO_#TO`#TOa#]Od#ZOg!nOyvO|!VO!Q!dO!U#^O!W!lO!]!pO$i!eO$m!fO$q!gO$s!hO%T!iO%V!jO%Z!kO%]!lO%^!mO%f!oO%j!qO%s!rO'R`O'U#SO~Ov)SO~P#$]Oy)UO~PEsO%^)VO~PGaOa)YO~P!1iO%f)_O~PEvO_)`O'U&cO~O!i)eO!j)dO'U&cO~O'_UO!Q(^X!U(^X!W(^X$q(^X%](^X%^(^X~Ov%uX~P2gOv)fO~PGyOv)fO~Ov)fO~P]OQiXQ'YXZiXd'YX}iX#piX(PiX~ORiXwiX$fiX$|iX[iXoiXyiX!liX!qiX!tiX#QiX#RiX'hiX'riX'siX'xiX'yiX'ziX'{iX'|iX'}iX(OiX(QiX(RiX(TiX!PiX!eiXXiXPiXviX!SiX#TiX~P#(_OQjXQlXRjXZjXdlX}jX#pjX(PjXwjX$fjX$|jX[jXojXyjX!ljX!qjX!tjX#QjX#RjX'hjX'rjX'sjX'xjX'yjX'zjX'{jX'|jX'}jX(OjX(QjX(RjX(TjX!PjX!ejXXjX!SjXPjXvjX#TjX~O%^)iO~PGaOQ']Od)jO~O^)lO_)lO`)lOa)lO'U%dO~Od)pO~OQ']OZ)tO})rOR'VX#p'VX(P'VXw'VX$f'VX$|'VX['VXo'VXy'VX!l'VX!q'VX!t'VX#Q'VX#R'VX'h'VX'r'VX's'VX'x'VX'y'VX'z'VX'{'VX'|'VX'}'VX(O'VX(Q'VX(R'VX(T'VX!P'VX!e'VXX'VXP'VXv'VX!S'VX#T'VX~OQ!QO^:iO_:eO`TOaTOd:hO%^)iO'U:fO~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!j)xO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!P){O!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaO(P)}O~OR*PO#p*QO(P*OO~OQhXQ'YXZhXd'YX}hX(PhX~ORhX#phXwhX$fhX$|hX[hXohXyhX!lhX!qhX!thX#QhX#RhX'hhX'rhX'shX'xhX'yhX'zhX'{hX'|hX'}hX(OhX(QhX(RhX(ThX!PhX!ehXXhXPhXvhX!ShX#ThX~P#4_OQ*RO~O})rO~OQ!QO^%vO_%cO`TOaTOd%jO$f%wO%^%xO'U%dO~PGaO!Q*UO!j*UO~O^*XO`*XOa*XO!O*YO~OQ&oOZ*ZO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaO[#}Oo:aO}#zO!l:bO!q#jO!t:bO#Q:aO#R:^O#p$OO'h#gO'r:bO's#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO~Ow'eX~P#9jOy#qaX#qa!e#qa!P#qav#qa#T#qa~P2gOy#zaX#za!e#za!P#zav#za#T#za~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!S&_O!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdOo#zay#za#Q#za#R#za#p#za's#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#zaX#za!e#za!P#zav#za#T#za~P)xOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#S*dO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdO~P)xOw*eO~P#9jO$b*hO$d*iO$f*jO~O!O*kO's(oO~O!S*mO~O'U*nO~Ow$yOy*pO~O'U*qO~OQ*tOw*uOy*xO}*vO$|*wO~OQ*tOw*uO$|*wO~OQ*tOw+PO$|*wO~OQ*tOo+UOy+WO!S+TO~OQ*tO}+YO~OQ!QOZ%rO[%qO^%vO`TOaTOd%jOg%yO}%pO!U!lO!W!lO!q%oO$f%wO$q%[O%]!lO%^%xO&W%{O'U%dO'[%eO(Q%zO~OR+aO_+]O!Q+bO~P#D_O_%cO!Q!lOw&UX$|&UX(P&UX~P#D_Ow$yO$f+gO$|*wO(P*OO~OQ!QOZ*ZO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaOQ*tOw$yO!S+TO$|*wO~Oo+mOy+lO!S+nO's(oO~OdlXy!RX#pbXv!RX!e!RX~Od'YXy(mX#p'TXv(mX!e(mX~Od+pO~O^#TO_#TO`#TOa'jOw&|O'U&vO(Q+uO~Ov(oP~P!3|O#p+zO~Oy+{O~O!S+|O~O'O!sO'P'VO'Q,OO~Od,PO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'_UO~P#D_OS,_OT,_OZ,_O['bO_,ZOd,_Oo,_Os,_Ou,_Ow'cOy,_O}'dO!S,_O!e,_O!l,_O!q,]O!t,_O!{,_O#Q,_O#R,_O#S,_O#T,_O'R,_O'[%eO'_UO'h,[O's,]O'v,`O'x,[O'y,]O'z,]O'{,]O'|,^O'},^O(O,_O(P,aO(Q,aO(R,bO~OX,XO~P#K_Ov,dO~P#K_O!P,gO~P#K_Oo'ti#Q'ti#R'ti#p'ti's'ti'x'ti'y'ti'z'ti'{'ti'|'ti'}'ti(O'ti(P'ti(R'ti(T'ti~Oy,hO['ti}'ti!l'ti!q'ti!t'ti'h'ti'r'ti(Q'tiv'ti~P#N^OP$giQ$giS$giT$giZ$gi[$gi^$gi_$gi`$gia$gid$gig$gis$git$giu$giw$giy$gi|$gi}$gi!Q$gi!U$gi!W$gi!X$gi!Z$gi!]$gi!l$gi!q$gi!t$gi#Y$gi#r$gi#{$gi$O$gi$b$gi$d$gi$f$gi$i$gi$m$gi$q$gi$s$gi%T$gi%V$gi%Z$gi%]$gi%^$gi%f$gi%j$gi%s$gi&{$gi'R$gi'U$gi'[$gi'_$gi'h$gi'r$gi(Q$giv$gi~P#N^OX,iO~Oo,jO},kOX]X!P]X!e]X~Oy#ciX#ci!e#ci!P#civ#ci#T#ci~P2gO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!q#ei!t#ei#Q#ei#R#ei#p#ei'r#ei's#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#T#ei~O'h#ei(P#ei~P$&sO[#}O}#zO(O#|O(R#fOo#eiy#ei!l#ei!q#ei!t#ei#Q#ei#R#ei#p#ei'r#ei's#ei'y#ei'z#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#T#ei~O'h#ei'x#ei(P#ei(Q#ei(T#eiw#ei~P$(tO'h#gO(P#gO~P$&sO[#}O}#zO'h#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#Q#ei#R#ei#p#ei'r#ei's#ei'{#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#T#ei~O!q#ei~P$+SO!q#jO~P$+SO[#}O}#zO!q#jO'h#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#Q#ei#R#ei#p#ei'r#ei'|#ei'}#eiX#ei!e#ei!P#eiv#ei#T#ei~O's#ei~P$-[O's#lO~P$-[O[#}O}#zO!q#jO#R#uO'h#gO's#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiy#ei!l#ei!t#ei#Q#ei#p#ei'r#ei'|#eiX#ei!e#ei!P#eiv#ei#T#ei~O'}#ei~P$/dO'}#mO~P$/dO[#}O}#zO!q#jO'h#gO's#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#ni!t#ni#p#ni'r#ni~Oo#xO#Q#xO#R#uOy#niX#ni!e#ni!P#niv#ni#T#ni~P$1lO[#}O}#zO!q#jO'h#gO's#lO'x#hO'y#iO'z#iO'{#kO'|#nO'}#mO(O#|O(P#gO(Q#hO(R#fO(T#hO!l#si!t#si#p#si'r#si~Oo#xO#Q#xO#R#uOy#siX#si!e#si!P#siv#si#T#si~P$3mOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R#VO'[kO'_UO'hcO'riO(QdO~P)xO!e,rO!P(VX~P2gO!P,tO~OX,uO~P2gOPoOQ!QOSVOTVOZeO[lOd[OsVOtVOuVOw!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'[kO'_UO'hcO'riO(QdOX&fX!e&fX!P&fX~P)xO!e(VOX(Wa~Oy,yO!e(VOX(WX~P2gOX,zO~O!P,{O!e(VO~O!P,}O!e(VO~P2gOSVOTVOsVOtVOuVO'_UO'h$[O~P!6POP!baZca!S!ba!e!ba!tca'rca's!ba!O!bao!bay!ba!P!baX!ba!Z!ba#T!bav!ba~O!e-SO's(oO!P'nXX'nX~O!P-UO~O!i-_O!j-^O!l-ZO'U-WOv'oP~OX-`O~O_%cO!Q!lO~P#D_O!j-fOP&gX!e&gX~P<cO!e(qOP(Ya~O!S-hO's(oOP$Wa!e$Wa~Ow!PO(P*OO~OvbX!S!kX!ebX~O'R#VO'U(wO~O!S-lO~O!e-nOv([X~Ov-pO~Ov-rO~P,cOv-rO~P#$]O_-tO'U&cO~O!S-uO~Ow$yOy-vO~OQ*tOw*uOy-yO}*vO$|*wO~OQ*tOo.TO~Oy.^O~O!S._O~O!j.aO'U&cO~Ov.bO~Ov.bO~PGyOQ']O^'Xa_'Xa`'Xaa'Xa'U'Xa~Od.fO~OQ'YXQ'lXR'lXZ'lXd'YX}'lX#p'lX(P'lXw'lX$f'lX$|'lX['lXo'lXy'lX!l'lX!q'lX!t'lX#Q'lX#R'lX'h'lX'r'lX's'lX'x'lX'y'lX'z'lX'{'lX'|'lX'}'lX(O'lX(Q'lX(R'lX(T'lX!P'lX!e'lXX'lXP'lXv'lX!S'lX#T'lX~OQ!QOZ%rO[%qO^.qO_%cO`TOaTOd%jOg%yO}%pO!j.rO!q.oO!t.jO#V.lO$f%wO%^%xO&W%{O'R#VO'U%dO'[%eO(Q%zO!P(sP~PGaO#S.sOR%wa#p%wa(P%waw%wa$f%wa$|%wa[%wao%way%wa}%wa!l%wa!q%wa!t%wa#Q%wa#R%wa'h%wa'r%wa's%wa'x%wa'y%wa'z%wa'{%wa'|%wa'}%wa(O%wa(Q%wa(R%wa(T%wa!P%wa!e%waX%waP%wav%wa!S%wa#T%wa~O%^.uO~PGaO(P*OOR&Oa#p&Oaw&Oa$f&Oa$|&Oa[&Oao&Oay&Oa}&Oa!l&Oa!q&Oa!t&Oa#Q&Oa#R&Oa'h&Oa'r&Oa's&Oa'x&Oa'y&Oa'z&Oa'{&Oa'|&Oa'}&Oa(O&Oa(Q&Oa(R&Oa(T&Oa!P&Oa!e&OaX&OaP&Oav&Oa!S&Oa#T&Oa~O_%cO!Q!lO!j.wO(P)}O~P#D_O!e.xO(P*OO!P(uX~O!P.zO~OX.{Oy.|O(P*OO~O'[%eOR(qP~OQ']O})rORfa#pfa(Pfawfa$ffa$|fa[faofayfa!lfa!qfa!tfa#Qfa#Rfa'hfa'rfa'sfa'xfa'yfa'zfa'{fa'|fa'}fa(Ofa(Qfa(Rfa(Tfa!Pfa!efaXfaPfavfa!Sfa#Tfa~OQ']O})rOR&Va#p&Va(P&Vaw&Va$f&Va$|&Va[&Vao&Vay&Va!l&Va!q&Va!t&Va#Q&Va#R&Va'h&Va'r&Va's&Va'x&Va'y&Va'z&Va'{&Va'|&Va'}&Va(O&Va(Q&Va(R&Va(T&Va!P&Va!e&VaX&VaP&Vav&Va!S&Va#T&Va~O!P/TO~Ow$yO$f/YO$|*wO(P*OO~OQ!QOZ/ZO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaOo/]O's(oO~O#W/^OP!YiQ!YiS!YiT!YiZ!Yi[!Yi^!Yi_!Yi`!Yia!Yid!Yig!Yio!Yis!Yit!Yiu!Yiw!Yiy!Yi|!Yi}!Yi!Q!Yi!U!Yi!W!Yi!X!Yi!Z!Yi!]!Yi!l!Yi!q!Yi!t!Yi#Q!Yi#R!Yi#Y!Yi#p!Yi#r!Yi#{!Yi$O!Yi$b!Yi$d!Yi$f!Yi$i!Yi$m!Yi$q!Yi$s!Yi%T!Yi%V!Yi%Z!Yi%]!Yi%^!Yi%f!Yi%j!Yi%s!Yi&{!Yi'R!Yi'U!Yi'[!Yi'_!Yi'h!Yi'r!Yi's!Yi'x!Yi'y!Yi'z!Yi'{!Yi'|!Yi'}!Yi(O!Yi(P!Yi(Q!Yi(R!Yi(T!YiX!Yi!e!Yi!P!Yiv!Yi!i!Yi!j!Yi#V!Yi#T!Yi~Oy#ziX#zi!e#zi!P#ziv#zi#T#zi~P2gOy$UiX$Ui!e$Ui!P$Uiv$Ui#T$Ui~P2gOv/dO!j&bO'R`O~P<cOw/mO}/lO~Oy!RX#pbX~Oy/nO~O#p/oO~OR+aO_+cO!Q/rO'U&iO'[%eO~Oa/yO|!VO'R#VO'U(QOv(cP~OQ!QOZ%rO[%qO^%vO_%cO`TOa/yOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'R#VO'U%dO'[%eO(Q%zO!P(eP~PGaOQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0UO%^%xO&W%{O'U%dO'[%eO(Q%zOw(`Py(`P~PGaOw*uO~Oy-yO$|*wO~Oa/yO|!VO'R#VO'U*nOv(gP~Ow+PO~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0UO%^%xO&W%{O'U%dO'[%eO(Q%zO(R0_O~PGaOy0cO~OQ!QOSVOTVO[$gO^0kO_$ZO`:QOa:QOd$aOsVOtVOuVO}$eO!i$qO!j0lO!l$lO!q0dO!t0gO'R#VO'U$YO'[%eO'_UO'h$[O~O#V0mO!P(jP~P%1qOw!POy0oO#S0qO$|*wO~OR0tO!e0rO~P#(_OR0tO!S+TO!e0rO(P)}O~OR0tOo0vO!S+TO!e0rOQ'WXZ'WX}'WX#p'WX(P'WX~OR0tOo0vO!e0rO~OR0tO!e0rO~O$f/YO(P*OO~Ow$yO~Ow$yO$|*wO~Oo0|Oy0{O!S0}O's(oO~O!e1OOv(pX~Ov1QO~O^#TO_#TO`#TOa'jOw&|O'U&vO(Q1UO~Oo1XOQ'WXR'WXZ'WX}'WX!e'WX(P'WX~O!e1YO(P*OOR'ZX~O!e1YOR'ZX~O!e1YO(P)}OR'ZX~OR1[O~OX1]O~P#K_O!S1_OS'wXT'wXX'wXZ'wX['wX_'wXd'wXo'wXs'wXu'wXw'wXy'wX}'wX!e'wX!l'wX!q'wX!t'wX!{'wX#Q'wX#R'wX#S'wX#T'wX'R'wX'['wX'_'wX'h'wX's'wX'v'wX'x'wX'y'wX'z'wX'{'wX'|'wX'}'wX(O'wX(P'wX(Q'wX(R'wXv'wX!P'wX~O}1`O~Ov1aO~P#K_O!P1bO~P#K_OSVOTVOsVOtVOuVO'_UO~OSVOTVOsVOtVOuVO'_UO!P(vP~P!6POX1gO~Oy,hO~O!e,rO!P(Va~P2gOPoOQ!QOZeO[lO^RO_RO`ROaROd[Ow!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R#VO'UQO'[kO'hcO'riO(QdO!P&eX!e&eX~P%;dO!e,rO!P(Va~OX&fa!e&fa!P&fa~P2gOX1lO~P2gOPoOQ!QOZeO[lO^RO_RO`ROaROd[Ow!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'UQO'[kO'hcO'riO(QdO~P%;dO!P1nO!e(VO~OP!biZci!S!bi!e!bi!tci'rci's!bi!O!bio!biy!bi!P!biX!bi!Z!bi#T!biv!bi~O's(oOP!oi!S!oi!e!oi!O!oio!oiy!oi!P!oiX!oi!Z!oi#T!oiv!oi~O!j&bO!P&`X!e&`XX&`X~P<cO!e-SO!P'naX'na~O!P1rO~Ov!RX!S!kX!e!RX~O!S1sO~O!e1tOv'pX~Ov1vO~O'U-WO~O!j1yO'U-WO~O(P*OOP$Wi!e$Wi~O!S1zO's(oOP$XX!e$XX~O!S1}O~Ov$_a!e$_a~P2gO!l({O'R#VO'U(wOv&hX!e&hX~O!e-nOv([a~Ov2RO~P,cOy2VO~O#p2WO~Oy2XO$|*wO~Ow*uOy2XO}*vO$|*wO~Oo2bO~Ow!POy2gO#S2iO$|*wO~O!S2kO~Ov2mO~O#S2nOR%wi#p%wi(P%wiw%wi$f%wi$|%wi[%wio%wiy%wi}%wi!l%wi!q%wi!t%wi#Q%wi#R%wi'h%wi'r%wi's%wi'x%wi'y%wi'z%wi'{%wi'|%wi'}%wi(O%wi(Q%wi(R%wi(T%wi!P%wi!e%wiX%wiP%wiv%wi!S%wi#T%wi~Od2oO~O^2rO!j.rO!q2sO'R#VO'[%eO~O(P*OO!P%{X!e%{X~O!e2tO!P(tX~O!P2vO~OQ!QOZ%rO[%qO^2xO_%cO`TOaTOd%jOg%yO}%pO!j2yO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(Q%zO~PGaO^2zO!j2yO(P)}O~O!P%aX!e%aX~P#4_O^2zO~O(P*OOR&Oi#p&Oiw&Oi$f&Oi$|&Oi[&Oio&Oiy&Oi}&Oi!l&Oi!q&Oi!t&Oi#Q&Oi#R&Oi'h&Oi'r&Oi's&Oi'x&Oi'y&Oi'z&Oi'{&Oi'|&Oi'}&Oi(O&Oi(Q&Oi(R&Oi(T&Oi!P&Oi!e&OiX&OiP&Oiv&Oi!S&Oi#T&Oi~O_%cO!Q!lO!P&yX!e&yX~P#D_O!e.xO!P(ua~OR3RO(P*OO~O!e3SOR(rX~OR3UO~O(P*OOR&Pi#p&Piw&Pi$f&Pi$|&Pi[&Pio&Piy&Pi}&Pi!l&Pi!q&Pi!t&Pi#Q&Pi#R&Pi'h&Pi'r&Pi's&Pi'x&Pi'y&Pi'z&Pi'{&Pi'|&Pi'}&Pi(O&Pi(Q&Pi(R&Pi(T&Pi!P&Pi!e&PiX&PiP&Piv&Pi!S&Pi#T&Pi~O!P3VO~O$f3WO(P*OO~Ow$yO$f3WO$|*wO(P*OO~Ow!PO!Z!YO~O!Z3bO#T3`O's(oO~O!j&bO'R#VO~P<cOv3fO~Ov3fO!j&bO'R`O~P<cO!O3iO's(oO~Ow!PO~P#9jOo3lOy3kO(P*OO~OS,_OT,_OZ,_O['bO_3mOd,_Oo,_Os,_Ou,_Ow'cOy,_O}'dO!S,_O!e,_O!l,_O!q,]O!t,_O!{,_O#Q,_O#R,_O#S,_O#T,_O'R,_O'[%eO'_UO'h,[O's,]O'v,`O'x,[O'y,]O'z,]O'{,]O'|,^O'},^O(O,_O(P,aO(Q,aO(R,bO~O!P3qO~P&']Ov3tO~P&']OR0tO!S+TO!e0rO~OR0tOo0vO!S+TO!e0rO~Oa/yO|!VO'R#VO'U(QO~O!S3wO~O!e3yOv(dX~Ov3{O~OQ!QOZ%rO[%qO^%vO_%cO`TOa/yOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'R#VO'U%dO'[%eO(Q%zO~PGaO!e4OO(P*OO!P(fX~O!P4QO~O!S4RO(P)}O~O!S+TO(P*OO~O!e4TOw(aXy(aX~OQ4VO~Oy2XO~Oa/yO|!VO'R#VO'U*nO~Oo4YOw*uO}*vOv%XX!e%XX~O!e4]Ov(hX~Ov4_O~O(P4aOy(_Xw(_X$|(_XR(_Xo(_X!e(_X~Oy4cO(P*OO~OQ!QO[$gO^4dO_$ZO`:QOa:QOd$aO}$eO!i$qO!j4eO!l$lO!q$hO#V$lO'U$YO'[%eO'h$[O~P%;dO!S4gO's(oO~O#V4iO~P%1qO!e4jO!P(kX~O!P4lO~O!P%aX!S!aX!e%aX's!aX~P!KZOQ!QO[$gO^4dO_$ZO`:QOa:QOd$aO}$eO!i$qO!j&bO!l$lO!q$hO#V$lO'U$YO'h$[O~P%;dO!e4jO!P(kX!S'fX's'fX~O^2zO!j2yO~Ow!POy2gO~O_4rO!Q/rO'U&iO'[%eOR&lX!e&lX~OR4tO!e0rO~O!S4vO~Ow$yO$|*wO(P*OO~Oy4wO~P2gOo4xOy4wO(P*OO~Ov&uX!e&uX~P!3|O!e1OOv(pa~Oo5OOy4}O(P*OO~OSVOTVO_%cOsVOtVOuVOw!PO!Q!lO'_UOR&vX!e&vX~P#D_O!e1YOR'Za~O!{5UO~O!P5VO~P#K_O!e5XO!P(wX~O!P5ZO~O!e,rO!P(Vi~OPoOQ!QOZeO[lO^RO_RO`ROaROd[Ow!PO}mO!U#bO!W#cO!X!^O!Z!YO!liO!qgO!tiO#Y!_O#r!ZO#{![O$O!]O$b!`O$d!bO$f!cO'R#VO'UQO'[kO'hcO'riO(QdO~P%;dO!P&ea!e&ea~P2gOX5]O~P2gOP!bqZcq!S!bq!e!bq!tcq'rcq's!bq!O!bqo!bqy!bq!P!bqX!bq!Z!bq#T!bqv!bq~O's(oO!P&`a!e&`aX&`a~O!i-_O!j-^O!l5_O'U-WOv&aX!e&aX~O!e1tOv'pa~O!S5aO~O!S5eO's(oOP$Xa!e$Xa~O(P*OOP$Wq!e$Wq~Ov$^i!e$^i~P2gOw!POy5gO#S5iO$|*wO~Oo5lOy5kO(P*OO~Oy5nO~Oy5nO$|*wO~Oy5rO(P*OO~Ow!POy5gO~Oo5yOy5xO(P*OO~O!S5{O~O!e2tO!P(ta~O^2zO!j2yO'[%eO~OQ!QOZ%rO[%qO^.qO_%cO`TOaTOd%jOg%yO}%pO!j.rO!q.oO!t6PO#V6RO$f%wO%^%xO&W%{O'R#VO'U%dO'[%eO(Q%zO!P&xX!e&xX~PGaOQ!QOZ%rO[%qO^6TO_%cO`TOaTOd%jOg%yO}%pO!j6UO!q%oO$f%wO%^%xO&W%{O'U%dO'[%eO(P)}O(Q%zO~PGaO!P%aa!e%aa~P#4_O^6VO~O#S6WOR%wq#p%wq(P%wqw%wq$f%wq$|%wq[%wqo%wqy%wq}%wq!l%wq!q%wq!t%wq#Q%wq#R%wq'h%wq'r%wq's%wq'x%wq'y%wq'z%wq'{%wq'|%wq'}%wq(O%wq(Q%wq(R%wq(T%wq!P%wq!e%wqX%wqP%wqv%wq!S%wq#T%wq~O(P*OOR&Oq#p&Oqw&Oq$f&Oq$|&Oq[&Oqo&Oqy&Oq}&Oq!l&Oq!q&Oq!t&Oq#Q&Oq#R&Oq'h&Oq'r&Oq's&Oq'x&Oq'y&Oq'z&Oq'{&Oq'|&Oq'}&Oq(O&Oq(Q&Oq(R&Oq(T&Oq!P&Oq!e&OqX&OqP&Oqv&Oq!S&Oq#T&Oq~O(P*OO!P&ya!e&ya~OX6XO~P2gO'[%eOR&wX!e&wX~O!e3SOR(ra~O$f6_O(P*OO~Ow![q~P#9jO#T6bO~O!Z3bO#T6bO's(oO~Ov6gO~O!S1_O#T'wX~O#T6kO~Oy6lO!P6mO~O!P6mO~P&']Oy6pO~Ov6pOy6lO~Ov6pO~P&']Oy6rO~O!e3yOv(da~O!S6uO~Oa/yO|!VO'R#VO'U(QOv&oX!e&oX~O!e4OO(P*OO!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOa/yOd%jOg%yO|!VO}%pO!q%oO$f%wO%^%xO&W%{O'R#VO'U%dO'[%eO(Q%zO!P&pX!e&pX~PGaO!e4OO!P(fa~OQ!QOZ%rO[%qO^%vO_%cO`TOaTOd%jOg%yO}%pO!q%oO$f0UO%^%xO&W%{O'U%dO'[%eO(Q%zOw&nX!e&nXy&nX~PGaO!e4TOw(aay(aa~O!e4]Ov(ha~Oo7XOv%Xa!e%Xa~Oo7XOw*uO}*vOv%Xa!e%Xa~Oa/yO|!VO'R#VO'U*nOv&qX!e&qX~O(P*OOy$xaw$xa$|$xaR$xao$xa!e$xa~O(P4aOy(_aw(_a$|(_aR(_ao(_a!e(_a~O!P%aa!S!aX!e%aa's!aX~P!KZOQ!QO[$gO^7`O_$ZO`:QOa:QOd$aO}$eO!i$qO!j&bO!l$lO!q$hO#V$lO'U$YO'h$[O~P%;dO^6VO!j6UO~O!e4jO!P(ka~O!e4jO!P(ka!S'fX's'fX~OQ!QO[$gO^0kO_$ZO`:QOa:QOd$aO}$eO!i$qO!j0lO!l$lO!q0dO!t7dO#V7fO'R#VO'U$YO'[%eO'h$[O!P&sX!e&sX~P%;dO!S7hO's(oO~Ow!POy5gO$|*wO(P*OO~O!S+TOR&la!e&la~Oo0vO!S+TOR&la!e&la~Oo0vOR&la!e&la~O(P*OOR$yi!e$yi~Oy7kO~P2gOo7lOy7kO(P*OO~O(P*OORni!eni~O(P*OOR&va!e&va~O(P)}OR&va!e&va~OS,_OT,_OZ,_O_,_Od,_Oo,_Os,_Ou,_Oy,_O!S,_O!e,_O!l,_O!q,]O!t,_O!{,_O#Q,_O#R,_O#S,_O#T,_O'R,_O'[%eO'_UO'h,[O's,]O'x,[O'y,]O'z,]O'{,]O'|,^O'},^O(O,_O~O(P7nO(Q7nO(R7nO~P''`O!P7pO~P#K_OSVOTVOsVOtVOuVO'_UO!P&zX!e&zX~P!6PO!e5XO!P(wa~O!P&ei!e&ei~P2gO's(oOv!hi!e!hi~O!S7tO~O(P*OOP$Xi!e$Xi~Ov$^q!e$^q~P2gOw!POy7vO~Ow!POy7vO#S7yO$|*wO~Oy7{O~Oy7|O~Oy7}O(P*OO~Ow!POy7vO$|*wO(P*OO~Oo8SOy8RO(P*OO~O!e2tO!P(ti~O(P*OO!P%}X!e%}X~O!P%ai!e%ai~P#4_O^8VO~O!e8[O['cXv$`i}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[iv$`i}#[i!i#[i!j#[i!l#[i!q#[i!t'cX#V#[i'R#[i'U#[i'_#[i'h#[i'r'cX(Q'cX~P@[O#T#^a~P2gO#T8_O~O!Z3bO#T8`O's(oO~Ov8cO~Oy8eO~P2gOy8gO~Oy6lO!P8hO~Ov8gOy6lO~O!e3yOv(di~O(P*OOv%Qi!e%Qi~O!e4OO!P(fi~O!e4OO(P*OO!P(fi~O(P*OO!P&pa!e&pa~O(P8oOw(bX!e(bXy(bX~O(P*OO!S$wiy$wiw$wi$|$wiR$wio$wi!e$wi~O!e4]Ov(hi~Ov%Xi!e%Xi~P2gOo8rOv%Xi!e%Xi~O!P%ai!S!aX!e%ai's!aX~P!KZO(P*OO!P%`i!e%`i~O!e4jO!P(ki~OQ!QO[$gO^0kO_$ZO`:QOa:QOd$aO}$eO!i$qO!j0lO!l$lO!q0dO!t7dO#V8uO'R#VO'U$YO'[%eO'h$[O~P%;dO!P&sa!S'fX!e&sa's'fX~O(P*OOR$zq!e$zq~Oy8wO~P2gOy8RO~P2gO(P8yO(Q8yO(R8yO~O(P8yO(Q8yO(R8yO~P''`O's(oOv!hq!e!hq~O(P*OOP$Xq!e$Xq~Ow!POy8|O$|*wO(P*OO~Ow!POy8|O~Oy9PO~P2gOy9RO~P2gOo9TOy9RO(P*OO~OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[qv$`q}#[q!i#[q!j#[q!l#[q!q#[q#V#[q'R#[q'U#[q'_#[q'h#[q~O!e9WO['cXv$`q}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[Oo'cX!t'cX#Q'cX#R'cX#p'cX'r'cX's'cX'x'cX'y'cX'z'cX'{'cX'|'cX'}'cX(O'cX(P'cX(Q'cX(R'cX(T'cX~P'9OO#T9]O~O!Z3bO#T9]O's(oO~Oy9_O~O(P*OOv%Qq!e%Qq~O!e4OO!P(fq~O(P*OO!P&pi!e&pi~O(P8oOw(ba!e(bay(ba~Ov%Xq!e%Xq~P2gO!P&si!S'fX!e&si's'fX~O(P*OO!P%`q!e%`q~Oy9dO~P2gO(P9eO(Q9eO(R9eO~O's(oOv!hy!e!hy~Ow!POy9fO~Ow!POy9fO$|*wO(P*OO~Oy9hO~P2gOQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[yv$`y}#[y!i#[y!j#[y!l#[y!q#[y#V#[y'R#[y'U#[y'_#[y'h#[y~O!e9kO['cXv$`y}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[Oo'cX!t'cX#Q'cX#R'cX#p'cX'r'cX's'cX'x'cX'y'cX'z'cX'{'cX'|'cX'}'cX(O'cX(P'cX(Q'cX(R'cX(T'cX~P'?}O!e9lO['cX}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[OQ#[iS#[iT#[i[#[i^#[i_#[i`#[ia#[id#[is#[it#[iu#[i}#[i!i#[i!j#[i!l#[i!q#[i!t'cX#V#[i'R#[i'U#[i'_#[i'h#[i'r'cX(Q'cX~P@[O#T9oO~O(P*OO!P&pq!e&pq~Ov%Xy!e%Xy~P2gOw!POy9pO~Oy9qO~P2gOQ#[!RS#[!RT#[!R[#[!R^#[!R_#[!R`#[!Ra#[!Rd#[!Rs#[!Rt#[!Ru#[!Rv$`!R}#[!R!i#[!R!j#[!R!l#[!R!q#[!R#V#[!R'R#[!R'U#[!R'_#[!R'h#[!R~O!e9rO['cX}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[OQ#[qS#[qT#[q[#[q^#[q_#[q`#[qa#[qd#[qs#[qt#[qu#[q}#[q!i#[q!j#[q!l#[q!q#[q!t'cX#V#[q'R#[q'U#[q'_#[q'h#[q'r'cX(Q'cX~P@[O!e9uO['cX}'cX!l'cX!q'cX!t'cX'h'cX'r'cX(Q'cX~P@[OQ#[yS#[yT#[y[#[y^#[y_#[y`#[ya#[yd#[ys#[yt#[yu#[y}#[y!i#[y!j#[y!l#[y!q#[y!t'cX#V#[y'R#[y'U#[y'_#[y'h#[y'r'cX(Q'cX~P@[OwbX~P$|OwjX}jX!tbX'rbX~P!6mOZ'TXd'YXo'TXw'lX!t'TX'r'TX's'TX~O['TXd'TXw'TX}'TX!l'TX!q'TX#Q'TX#R'TX#p'TX'h'TX'x'TX'y'TX'z'TX'{'TX'|'TX'}'TX(O'TX(P'TX(Q'TX(R'TX(T'TX~P'MmOP'TX}'lX!S'TX!e'TX!O'TXy'TX!P'TXX'TX!Z'TX#T'TXv'TX~P'MmO^9xO_9xO`9xOa9xO'U9vO~O!j:VO~P!.cOPoOQ!QOZeO^9xO_9xO`9xOa9xOd9{O!U#bO!W#cO!X;RO!Z!YO#Y!_O#r:RO#{:SO$O!]O$b!`O$d!bO$f!cO'U9vO'[kO[#sXo#sXw#sX}#sX!l#sX!q#sX!t#sX#Q#sX#R#sX#p#sX'h#sX'r#sX's#sX'x#sX'y#sX'z#sX'{#sX'|#sX'}#sX(O#sX(P#sX(Q#sX(R#sX(T#sX~P%;dO#S$uO~P!.cO}'lXP'TX!S'TX!e'TX!O'TXy'TX!P'TXX'TX!Z'TX#T'TXv'TX~P'MmOo#qX#Q#qX#R#qX#p#qX's#qX'x#qX'y#qX'z#qX'{#qX'|#qX'}#qX(O#qX(P#qX(R#qX(T#qX~P!.cOo#zX#Q#zX#R#zX#p#zX's#zX'x#zX'y#zX'z#zX'{#zX'|#zX'}#zX(O#zX(P#zX(R#zX(T#zX~P!.cOPoOQ!QOZeO^9xO_9xO`9xOa9xOd9{O!U#bO!W#cO!X;RO!Z!YO#Y!_O#r:RO#{:SO$O!]O$b!`O$d!bO$f!cO'U9vO'[kO[#sao#saw#sa}#sa!l#sa!q#sa!t#sa#Q#sa#R#sa#p#sa'h#sa'r#sa's#sa'x#sa'y#sa'z#sa'{#sa'|#sa'}#sa(O#sa(P#sa(Q#sa(R#sa(T#sa~P%;dOo:aO#Q:aO#R:^Ow#sa~P!BqOw$Ua~P#9jOQ'YXd'YX}iX~OQlXdlX}jX~O^:zO_:zO`:zOa:zO'U:fO~OQ'YXd'YX}hX~Ow#qa~P#9jOw#za~P#9jO!S&_Oo#za#Q#za#R#za#p#za's#za'x#za'y#za'z#za'{#za'|#za'}#za(O#za(P#za(R#za(T#za~P!.cO#S*dO~P!.cOw#ci~P#9jO[#}O}#zO'x#hO(O#|O(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!q#ei!t#ei#Q#ei#R#ei#p#ei'r#ei's#ei'y#ei'z#ei'{#ei'|#ei'}#ei~O'h#ei(P#ei~P(/aO'h#gO(P#gO~P(/aO[#}O}#zO'h#gO'x#hO'y#iO'z#iO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#Q#ei#R#ei#p#ei'r#ei's#ei'{#ei'|#ei'}#ei~O!q#ei~P(1]O!q#jO~P(1]O[#}O}#zO!q#jO'h#gO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#Q#ei#R#ei#p#ei'r#ei'|#ei'}#ei~O's#ei~P(3UO's#lO~P(3UO[#}O}#zO!q#jO#R:^O'h#gO's#lO'x#hO'y#iO'z#iO'{#kO(O#|O(P#gO(Q#hO(R#fO(T#hOo#eiw#ei!l#ei!t#ei#Q#ei#p#ei'r#ei'|#ei~O'}#ei~P(4}O'}#mO~P(4}Oo:aO#Q:aO#R:^Ow#ni~P$1lOo:aO#Q:aO#R:^Ow#si~P$3mOQ'YXd'YX}'lX~Ow#zi~P#9jOw$Ui~P#9jOd:UO~Ow#ca~P#9jOd:|O~OU'x_'v'Q'P'_s!{'_'U'[~",
  goto: "$L^(xPPPPPPP(yPP)QPP)`PPPP)l-rP0r5oP7a7a9U7a?VDoEQPEWHaPPPPPPKqP! b! pPPPPP!!hP!%QP!%QPP!'QP!)TP!)Y!*P!*w!*w!*w!)Y!+nP!)Y!.c!.fPP!.lP!)Y!)Y!)Y!)YP!)Y!)YP!)Y!)Y!/[!/[!/y!0hP!0hKaKaKaPPPP!0hPP!%QP!0v!0y!1P!2Q!2^!4^!4^!6[!8^!2^!2^!:Y!;w!=h!?T!@n!BV!Cl!D}!2^!2^P!2^P!2^!2^!F^!2^P!G}!2^!2^P!I}!2^P!2^!8^!8^!2^!8^!2^!LU!N^!Na!8^!2^!Nd!Ng!Ng!Ng!Nk!%QP!%QP!%QP! b! bP!Nu! b! bP# R#!g! bP! bP#!v##{#$T#$s#$w#$}#$}#%VP#']#']#'c#(X#(e! bP! bP#(u#)U! bP! bPP#)b#)p#)|#*f#)v! b! bP! b! b! bP#*l#*l#*r#*x#*l#*l! b! bP#+V#+`#+j#+j#-b#/U#/b#/b#/e#/e5o5o5o5o5o5o5o5oP5o#/h#/n#0Y#2e#2k#2z#6x#7O#7U#7h#7r#9c#9m#9|#:S#:Y#:d#:n#:t#;R#;X#;_#;i#;w#<R#>a#>m#>z#?Q#?Y#?a#?k#?qPPPPPPP#?w#CTP#GS#Kn#Mi$ h$'UP$'XPPP$*`$*i$*{$0V$2e$2n$4gP!)Y$5a$8u$;l$?W$?a$?f$?iPPP$?l$BcP$BsPPPPPPPPPP$CXP$Eg$Ej$Em$Es$Ev$Ey$E|$FP$FV$Ha$Hd$Hg$Hj$Hm$Hp$Hs$Hv$Hy$H|$IP$KV$KY$K]#*l$Ki$Ko$Kr$Ku$Ky$K}$LQ$LT$LW$LZQ!tPT'V!s'Wi!SOlm!P!T$T$W$y%b)T*e/fQ'h#QQ,l'kQ1d,kR7q5X(SSOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%X%_%b&U&Y&[&b&u&z&|'P'a'k'm'n'|(V(X(a(c(d(e(i(n(o(q({)R)T)h*Y*e*h*j*k+Y+m+y,k,o,r,y-Q-S-f-l-s.|/]/a/c/f0d0f0l0|1O1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9z9{9|9}:O:P:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m:nS(y$v-nQ*o&eQ*s&hQ-j(xQ-x)YW0Y+P0X4]7ZR4[0Z&{!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'k'|(V(X(a(e(i(n(o(q({)R)T)h*Y*e*h*j*k+Y+m,k,r,y-S-f-l-s.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m#r]Ofgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h+m,r,y-l.|0|1i1}3`3b3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9of#[b#Q$y'k(a)R)T*Y,k-s5X!h$bo!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t$b%k!Q!n$O$u%o%p%q%y%{&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n!W;Q!Y!_!`*h*k/]3i9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mR;T%n$_%u!Q!n$O$u%o%p%q&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n$e%l!Q!n$O$u%n%o%p%q%y%{&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n'hZOY[fgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r%_%b%i%j&U&Y&[&b&u'a'|(V(X(c(d(e(i(n(o(q({)h)o)p*e*h*j*k+Y+m,r,y-Q-S-f-l.h.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9z9{9|9}:O:P:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:g:h:l:m:n:{:|;P$^%l!Q!n$O$u%n%o%p%q%y%{&P&p&r(p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nQ&j!hQ&k!iQ&l!jQ&m!kQ&s!oQ)Z%QQ)[%RQ)]%SQ)^%TQ)a%WQ+_&oS,Q']1YQ.V)_S/q*t4VR4p0r+}TOY[bfgilmop!O!P!Q!T!Y!Z![!_!`!c!n!p!q!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$O$T$W$`$a$e$g$h$q$r$u$y%X%_%b%i%j%n%o%p%q%y%{&P&U&Y&[&b&o&p&r&u&z&|'P']'a'k'm'n'|(V(X(a(c(d(e(i(n(o(p(q({)R)T)h)o)p)r)w)x)}*O*Q*U*Y*Z*]*d*e*h*j*k*m*v*w+T+U+Y+g+m+n+y+|,k,o,r,y-Q-S-f-h-l-s-u.T._.h.o.s.w.x.|/Y/Z/]/a/c/f/z/|0_0d0f0l0q0v0|0}1O1X1Y1i1s1z1}2b2i2k2n2t2w3W3`3b3g3i3l3w3}4O4T4W4Y4a4e4g4j4v4x5O5X5a5e5i5l5y5{6W6_6b6f6u6{6}7X7c7h7l7t7y8S8_8`8n8r9T9]9o9z9{9|9}:O:P:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:g:h:l:m:n:{:|;PQ'[!xQ'g#PQ)k%gU)q%m*S*VR.e)jQ,S']R5R1Y#t%s!Q!n$O$u%p%q&P&p&r(p)w)x)}*Q*U*Z*]*d*m*v+U+g+n+|-h-u.T._.s.w.x/Y/Z/z/|0_0q0v0}1X1z2b2i2k2n2w3W3w3}4O4W4g4v5e5i5{6W6_6u6{6}7h7y8nQ)w%oQ+^&oQ,T']l,_'b'c'd,Y,e,f/l/m1`3p3s5V5W7pS.p)r2tQ.}*OQ/P*RQ/p*tS0P*w4TQ0`+T[0n+Y.i0f4j6O7cQ2w.oS4f0d2sQ4o0rQ5S1YQ6Y3SQ7P4RQ7T4VQ7^4aR9a8o&pVOfgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u']'|(V(X(a(e(i(n(o(q({)h*e*h*j*k+Y+m,j,k,r,y-S-f-l.|/]/a/c/f0d0f0l0|1Y1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mU&g!g%P%[m,_'b'c'd,Y,e,f/l/m1`3p3s5V5W7p$nsOfgilm!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y'|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:R:S:V:W:X:Y:Z:[:]:^:_:`:a:lS$tp:PS&O!W#bS&Q!X#cQ&`!bQ*^&RQ*`&VS*c&[:mQ*g&^Q,S']Q-i(vQ/h*iQ0o+ZS2g.W0pQ3^/^Q3_/_Q3h/gQ3j/jQ5R1YU5g2S2h4nU7v5h5j5wQ8d6iS8|7w7xS9f8}9OR9p9gi{Ob!O!P!T$y%_%b)R)T)h-shxOb!O!P!T$y%_%b)R)T)h-sW/u*u/s3y6vQ/|*vW0Z+P0X4]7ZQ3}/zQ6}4OR8n6{!h$do!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7tQ&d!dQ&f!fQ&n!mW&x!q%X&|1OQ'S!rQ)W$}Q)X%OQ)`%VU)c%Y'T'UQ*r&hS+r&z'PS-X(j1tQ-t)VQ-w)YS.`)d)eS0w+b/rQ1R+yQ1V+zS1w-^-_Q2l.aQ3u/oQ5b1yR5m2W${sOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m$zsOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mR3^/^V&T!Y!`*h!i$lo!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t!k$^o!c!p$e$g$h$q$r&U&b&u(a(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t!i$co!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t&e^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'|(V(X(e(i(n(o(q({)h*e*h*j*k+Y+m,r,y-S-f-l.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mR(k$fQ-Z(jR5_1tQ(R#|S(z$v-nS-Y(j1tQ-k(xW/t*u/s3y6vS1x-^-_Q3x/uR5c1yQ'e#Oh,b'b'c'd,Y,e,f/l/m1`3p3s5WQ,m'lQ,p'oQ.t)tR8f6kQ'f#Oh,b'b'c'd,Y,e,f/l/m1`3p3s5WQ,n'lQ,p'oQ.t)tR8f6ki,b'b'c'd,Y,e,f/l/m1`3p3s5WR*f&]X/b*e/c/f3g!}aOb!O!P!T#z$v$y%_%b'|(x)R)T)h)r*e*u*v+P+Y,r-n-s.i/a/c/f/s/z0X0f1i2t3g3y4O4]4j6O6f6v6{7Z7cQ3a/`Q6d3cQ8a6eR9^8b${rOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m#nfOfglmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['|(V(X({)h+m,r,y-l.|0|1i1}3`3b3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o!T9|!Y!_!`*h*k/]3i9|9}:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:l:m#rfOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h+m,r,y-l.|0|1i1}3`3b3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o!X9|!Y!_!`*h*k/]3i9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m$srOfglmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:l:m#U#oh#d$P$Q$V$s%^&W&X'p's't'u'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9i}:W&S&]/j3]6i:c:d:j:k:o:q:r:s:t:u:v:w:x:y:};O;S#W#ph#d$P$Q$V$s%^&W&X'p'q's't'u'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9i!P:X&S&]/j3]6i:c:d:j:k:o:p:q:r:s:t:u:v:w:x:y:};O;S#S#qh#d$P$Q$V$s%^&W&X'p't'u'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9i{:Y&S&]/j3]6i:c:d:j:k:o:r:s:t:u:v:w:x:y:};O;S#Q#rh#d$P$Q$V$s%^&W&X'p'u'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9iy:Z&S&]/j3]6i:c:d:j:k:o:s:t:u:v:w:x:y:};O;S#O#sh#d$P$Q$V$s%^&W&X'p'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9iw:[&S&]/j3]6i:c:d:j:k:o:t:u:v:w:x:y:};O;S!|#th#d$P$Q$V$s%^&W&X'p'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9iu:]&S&]/j3]6i:c:d:j:k:o:u:v:w:x:y:};O;S!x#vh#d$P$Q$V$s%^&W&X'p'y'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9iq:_&S&]/j3]6i:c:d:j:k:o:w:x:y:};O;S!v#wh#d$P$Q$V$s%^&W&X'p'z'{'}(T(Z(_*a*b,q,v,x-m0y1j1m2O3Q4y5[5f6c6j7W7j7m7z8Q8q8x9S9c9io:`&S&]/j3]6i:c:d:j:k:o:x:y:};O;S$]#{h#`#d$P$Q$V$s%^&S&W&X&]'p'q'r's't'u'v'w'x'y'z'{'}(T(Z(_*a*b,q,v,x-m/j0y1j1m2O3Q3]4y5[5f6c6i6j7W7j7m7z8Q8q8x9S9c9i:c:d:j:k:o:p:q:r:s:t:u:v:w:x:y:};O;S${jOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m$v!aOfgilmp!O!P!T!Y!Z!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mQ&Y![Q&Z!]R:l:S#rpOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h+m,r,y-l.|0|1i1}3`3b3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9oQ&[!^!W:P!Y!_!`*h*k/]3i9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mR:m;RR$moR-e(qR$wqT(|$v-nQ/e*eS3e/c/fR6h3gQ3o/lQ3r/mQ6n3pR6q3sQ$zwQ)U${Q*p&fQ+e&qQ+h&sQ-v)XW.Y)a+i+j+kS/W*[+fW2c.V.Z.[.]U3X/X/[0xU5t2d2e2fS6]3Y3[S8O5u5vS8X6[6^Q9Q8PS9U8Y8ZR9j9V^|O!O!P!T%_%b)hX)Q$y)R)T-sQ&r!nQ*]&PQ*{&jQ+O&kQ+S&lQ+V&mQ+[&nQ+k&sQ-|)ZQ.P)[Q.S)]Q.U)^Q.X)`Q.])aQ2T-tQ2f.VR4W0UU+`&o*t4VR4q0rQ+X&mQ+j&sS.[)a+k^0u+^+_/p/q4o4p7TS2e.V.]S4S0Q0RR5v2fS0Q*w4TQ0`+TR7^4aU+c&o*t4VR4r0rQ*y&jQ*}&kQ+R&lQ+f&qQ+i&sS-z)Z*{S.O)[+OS.R)]+SU.Z)a+j+kQ/X*[Q0W*zQ0p+ZQ2Y-{Q2Z-|Q2^.PQ2`.SU2d.V.[.]Q2h.WS3[/[0xS5h2S4nQ5o2[S5u2e2fQ6^3YS7x5j5wQ8P5vQ8Y6[Q8}7wQ9V8ZR9g9OQ0S*wR7R4TQ*x&jQ*|&kU-y)Z*y*{U-})[*}+OS2X-z-|S2].O.PQ4Z0YQ5n2ZQ5p2^R7Y4[Q/v*uQ3v/sQ6w3yR8k6vQ*z&jS-{)Z*{Q2[-|Q4Z0YR7Y4[Q+Q&lU.Q)]+R+SS2_.R.SR5q2`Q0[+PQ4X0XQ7[4]R8s7ZQ+Z&nS.W)`+[S2S-t.XR5j2TQ0h+YQ4h0fQ7e4jR8t7cQ.l)rQ0h+YQ2q.iQ4h0fQ6R2tQ7e4jQ8U6OR8t7cQ0h+YR4h0fX'O!q%X&|1OX&{!q%X&|1OW'O!q%X&|1OS+t&z'PR1T+y_|O!O!P!T%_%b)hQ%a!PS)g%_%bR.c)h$^%u!Q!n$O$u%o%p%q&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nQ*T%yR*W%{$c%n!Q!n$O$u%o%p%q%y%{&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nW)s%m%x*S*VQ.d)iR2|.uR.l)rR6R2tQ'W!sR+}'WQ!TOQ$TlQ$WmQ%b!P[%|!T$T$W%b)T/fQ)T$yR/f*e$b%i!Q!n$O$u%o%p%q%y%{&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n[)m%i)o.h:g:{;PQ)o%jQ.h)pQ:g%nQ:{:hR;P:|Q!vUR'Y!vS!OO!TU%]!O%_)hQ%_!PR)h%b#rYOfgilmp!O!P!T!Z![#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h+m,r,y-l.|0|1i1}3`3b3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9oh!yY!|#U$`'a'm(c,o-Q9z:T:nQ!|[f#Ub#Q$y'k(a)R)T*Y,k-s5X!h$`o!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7tQ'a!}Q'm#ZQ(c$aQ,o'nQ-Q(d!W9z!Y!_!`*h*k/]3i9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mQ:T9{R:n:UQ-T(fR1q-TQ1u-ZR5`1uQ,Y'bQ,e'cQ,f'dW1^,Y,e,f5WR5W1`Q/c*eS3d/c3gR3g/ffbO!O!P!T$y%_%b)R)T)h-sp#Wb'|(x.i/a/s/z0X0f1i6O6f6v6{7Z7cQ'|#zS(x$v-nQ.i)rW/a*e/c/f3gQ/s*uQ/z*vQ0X+PQ0f+YQ1i,rQ6O2tQ6v3yQ6{4OQ7Z4]R7c4jQ,s'}Q1h,qT1k,s1hS(W$Q(ZQ(]$VU,w(W(],|R,|(_Q(r$mR-g(rQ-o(}R2Q-oQ3p/lQ3s/mT6o3p3sQ)R$yS-q)R-sR-s)TQ4b0`R7_4b`0s+]+^+_+`+c/p/q7TR4s0sQ8p7PR9b8pQ4U0SR7S4UQ3z/vQ6s3vT6x3z6sQ4P/{Q6y3|U7O4P6y8lR8l6zQ4^0[Q7V4XT7]4^7VhzOb!O!P!T$y%_%b)R)T)h-sQ$|xW%Zz$|%f)u$b%f!Q!n$O$u%o%p%q%y%{&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nR)u%nS4k0h0mS7b4h4iT7g4k7bW&z!q%X&|1OS+q&z+yR+y'PQ1P+vR4|1PU1Z,R,S,TR5T1ZS3T/P7TR6Z3TQ2u.lQ5}2qT6S2u5}Q.y)yR3P.yQ5Y1dR7r5Y^_O!O!P!T%_%b)hY#Xb$y)R)T-s$l#_fgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['|(V(X({*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m!h$io!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7tW'i#Q'k,k5XQ-O(aR/U*Y&z!RObfgilmop!O!P!T!Y!Z![!_!`!c!p#Q#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r$y%_%b&U&Y&[&b&u'k'|(V(X(a(e(i(n(o(q({)R)T)h*Y*e*h*j*k+Y+m,k,r,y-S-f-l-s.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m[!{Y[#U#Z9z9{W&{!q%X&|1O['`!|!}'m'n:T:US(b$`$aS+s&z'PU,W'a,o:nS-P(c(dQ1S+yR1o-QS%t!Q&oQ&q!nQ(U$OQ(v$uS)v%o.oQ)y%pQ)|%qS*[&P&rQ+d&pQ,R']Q-c(pQ.k)rU.v)w)x2wS.})}*OQ/O*QQ/S*UQ/V*ZQ/[*]Q/_*dQ/k*mQ/{*vS0R*w4TQ0`+TQ0b+UQ0x+gQ0z+nQ1W+|Q1|-hQ2U-uQ2a.TQ2j._Q2{.sQ2}.wQ3O.xQ3Y/YQ3Z/ZS3|/z/|Q4`0_Q4n0qQ4u0vQ4z0}Q5P1XQ5Q1YQ5d1zQ5s2bQ5w2iQ5z2kQ5|2nQ6Q2tQ6[3WQ6t3wQ6z3}Q6|4OQ7U4WQ7^4aQ7a4gQ7i4vQ7u5eQ7w5iQ8T5{Q8W6WQ8Z6_Q8j6uS8m6{6}Q8v7hQ9O7yR9`8n$^%m!Q!n$O$u%o%p%q&P&o&p&r'](p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nQ)i%nQ*S%yR*V%{$y%h!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](p)o)p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.h.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n:g:h:{:|;P'tWOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'k'm'n'|(V(X(a(c(d(e(i(n(o(q({)R)T)h*Y*e*h*j*k+Y+m,k,o,r,y-Q-S-f-l-s.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9z9{9|9}:O:P:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m:n$x%g!Q!n$O$u%i%j%n%o%p%q%y%{&P&o&p&r'](p)o)p)r)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.h.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8n:g:h:{:|;P_&y!q%X&z&|'P+y1OR,U']$zrOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m!j$]o!c!p$e$g$h$q$r&U&b&u(a(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7tQ,S']Q1c,jQ1d,kQ5R1YR7q5X_}O!O!P!T%_%b)h^|O!O!P!T%_%b)hQ#YbX)Q$y)R)T-sbhO!O!T3`6b8_8`9]9oS#`f9|Q#dgQ$PiQ$QlQ$VmQ$spW%^!P%_%b)hU&S!Y!`*hQ&W!ZQ&X![Q&]!_Q'p#eQ'q#oS'r#p:XQ's#qQ't#rQ'u#sQ'v#tQ'w#uQ'x#vQ'y#wQ'z#xQ'{#yQ'}#zQ(T#}Q(Z$TQ(_$WQ*a&YQ*b&[Q,q'|Q,v(VQ,x(XQ-m({Q/j*kQ0y+mQ1j,rQ1m,yQ2O-lQ3Q.|Q3]/]Q4y0|Q5[1iQ5f1}Q6c3bQ6i3iQ6j3lQ7W4YQ7j4xQ7m5OQ7z5lQ8Q5yQ8q7XQ8x7lQ9S8SQ9c8rQ9i9TQ:c:OQ:d:PQ:j:RQ:k:SQ:o:VQ:p:WQ:q:YQ:r:ZQ:s:[Q:t:]Q:u:^Q:v:_Q:w:`Q:x:aQ:y:bQ:}:lQ;O:mR;S9}^tO!O!P!T%_%b)h$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['|(V(X({*h*k+m,r,y-l.|/]0|1i1}3b3i3l4Y4x5O5l5y7X7l8S8r9T9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mQ6a3`Q8^6bQ9Y8_Q9[8`Q9n9]R9t9oQ&V!YQ&^!`R/g*hQ$joQ&a!cQ&t!pU(f$e$g(iS(m$h0dQ(t$qQ(u$rQ*_&UQ*l&bQ+o&uQ-R(eS-a(n4eQ-b(oQ-d(qW/`*e/c/f3gQ/i*jW0e+Y0f4j7cQ1p-SQ1{-fQ3c/aQ4m0lQ5^1sQ7s5aQ8b6fR8{7t!h$_o!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7tR-O(a'uXOY[bfgilmop!O!P!T!Y!Z![!_!`!c!p!|!}#Q#U#Z#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$`$a$e$g$h$q$r$y%_%b&U&Y&[&b&u'a'k'm'n'|(V(X(a(c(d(e(i(n(o(q({)R)T)h*Y*e*h*j*k+Y+m,k,o,r,y-Q-S-f-l-s.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5X5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9z9{9|9}:O:P:R:S:T:U:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m:n$zqOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m!i$fo!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t&d^Ofgilmop!O!P!T!Y!Z![!_!`!c!p#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W$e$g$h$q$r%_%b&U&Y&[&b&u'|(V(X(e(i(n(o(q({)h*e*h*j*k+Y+m,r,y-S-f-l.|/]/a/c/f0d0f0l0|1i1s1}3`3b3g3i3l4Y4e4j4x5O5a5l5y6b6f7X7c7l7t8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m[!zY[$`$a9z9{['_!|!}(c(d:T:UW)n%i%j:g:hU,V'a-Q:nW.g)o)p:{:|T2p.h;PQ(h$eQ(l$gR-V(iV(g$e$g(iR-](jR-[(j$znOfgilmp!O!P!T!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W%_%b&Y&['|(V(X({)h*h*k+m,r,y-l.|/]0|1i1}3`3b3i3l4Y4x5O5l5y6b7X7l8S8_8`8r9T9]9o9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:m!i$ko!c!p$e$g$h$q$r&U&b&u(e(i(n(o(q*e*j+Y-S-f/a/c/f0d0f0l1s3g4e4j5a6f7c7t`,c'b'c'd,Y,e,f1`5WX3n/l/m3p3sh,b'b'c'd,Y,e,f/l/m1`3p3s5WQ7o5VR8z7p^uO!O!P!T%_%b)h$`#afgilmp!Y!Z![!_!`#e#o#p#q#r#s#t#u#v#w#x#y#z#}$T$W&Y&['|(V(X({*h*k+m,r,y-l.|/]0|1i1}3b3i3l4Y4x5O5l5y7X7l8S8r9T9|9}:O:P:R:S:V:W:X:Y:Z:[:]:^:_:`:a:b:l:mQ6`3`Q8]6bQ9X8_Q9Z8`Q9m9]R9s9oR(P#zR(O#zQ$SlR([$TR$ooR$noR)P$vR)O$vQ(}$vR2P-nhwOb!O!P!T$y%_%b)R)T)h-s$l!lz!Q!n$O$u$|%f%n%o%p%q%y%{&P&o&p&r'](p)r)u)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nR${xR0a+TR0V*wR0T*wR7Q4RR/x*uR/w*uR0O*vR/}*vR0^+PR0]+P%XyObxz!O!P!Q!T!n$O$u$y$|%_%b%f%n%o%p%q%y%{&P&o&p&r'](p)R)T)h)r)u)w)x)}*O*Q*U*Z*]*d*m*v*w+T+U+g+n+|-h-s-u.T._.o.s.w.x/Y/Z/z/|0_0q0v0}1X1Y1z2b2i2k2n2t2w3W3w3}4O4T4W4a4g4v5e5i5{6W6_6u6{6}7h7y8nR0j+YR0i+YQ'R!qQ)b%XQ+v&|R4{1OX'Q!q%X&|1OR+x&|R+w&|T/R*R4VT/Q*R4VR.n)rR.m)rR)z%pR1f,kR1e,k",
  nodeNames: "\u26A0 | < > RawString Float LineComment BlockComment SourceFile ] InnerAttribute ! [ MetaItem self Metavariable super crate Identifier ScopedIdentifier :: QualifiedScope AbstractType impl SelfType MetaType TypeIdentifier ScopedTypeIdentifier ScopeIdentifier TypeArgList TypeBinding = Lifetime String Escape Char Boolean Integer } { Block ; ConstItem Vis pub ( in ) const BoundIdentifier : UnsafeBlock unsafe AsyncBlock async move IfExpression if LetDeclaration let LiteralPattern ArithOp MetaPattern SelfPattern ScopedIdentifier TuplePattern ScopedTypeIdentifier , StructPattern FieldPatternList FieldPattern ref mut FieldIdentifier .. RefPattern SlicePattern CapturedPattern ReferencePattern & MutPattern RangePattern ... OrPattern MacroPattern ParenthesizedTokens BracketedTokens BracedTokens TokenBinding Identifier TokenRepetition ArithOp BitOp LogicOp UpdateOp CompareOp -> => ArithOp _ else MatchExpression match MatchBlock MatchArm Attribute Guard UnaryExpression ArithOp DerefOp LogicOp ReferenceExpression TryExpression BinaryExpression ArithOp ArithOp BitOp BitOp BitOp BitOp LogicOp LogicOp AssignmentExpression TypeCastExpression as ReturnExpression return RangeExpression CallExpression ArgList AwaitExpression await FieldExpression GenericFunction BreakExpression break LoopLabel ContinueExpression continue IndexExpression ArrayExpression TupleExpression MacroInvocation UnitExpression ClosureExpression ParamList Parameter Parameter ParenthesizedExpression StructExpression FieldInitializerList ShorthandFieldInitializer FieldInitializer BaseFieldInitializer MatchArm WhileExpression while LoopExpression loop ForExpression for MacroInvocation MacroDefinition macro_rules MacroRule EmptyStatement ModItem mod DeclarationList AttributeItem ForeignModItem extern StructItem struct TypeParamList ConstrainedTypeParameter TraitBounds HigherRankedTraitBound RemovedTraitBound OptionalTypeParameter ConstParameter WhereClause where LifetimeClause TypeBoundClause FieldDeclarationList FieldDeclaration OrderedFieldDeclarationList UnionItem union EnumItem enum EnumVariantList EnumVariant TypeItem type FunctionItem default fn ParamList Parameter SelfParameter VariadicParameter VariadicParameter ImplItem TraitItem trait AssociatedType LetDeclaration UseDeclaration use ScopedIdentifier UseAsClause ScopedIdentifier UseList ScopedUseList UseWildcard ExternCrateDeclaration StaticItem static ExpressionStatement ExpressionStatement GenericType FunctionType ForLifetimes ParamList VariadicParameter Parameter VariadicParameter Parameter ReferenceType PointerType TupleType UnitType ArrayType MacroInvocation EmptyType DynamicType dyn BoundedType",
  maxTerm: 361,
  nodeProps: [
    [NodeProp.group, -42, 4, 5, 14, 15, 16, 17, 18, 19, 33, 35, 36, 37, 40, 51, 53, 56, 101, 107, 111, 112, 113, 122, 123, 125, 127, 128, 130, 132, 133, 134, 137, 139, 140, 141, 142, 143, 144, 148, 149, 155, 157, 159, "Expression", -16, 22, 24, 25, 26, 27, 222, 223, 230, 231, 232, 233, 234, 235, 236, 237, 239, "Type", -20, 42, 161, 162, 165, 166, 169, 170, 172, 188, 190, 194, 196, 204, 205, 207, 208, 209, 217, 218, 220, "Statement", -17, 49, 60, 62, 63, 64, 65, 68, 74, 75, 76, 77, 78, 80, 81, 83, 84, 99, "Pattern"],
    [NodeProp.openedBy, 9, "[", 38, "{", 47, "("],
    [NodeProp.closedBy, 12, "]", 39, "}", 45, ")"]
  ],
  skippedNodes: [0, 6, 7, 240],
  repeatNodeCount: 33,
  tokenData: "#CO_R!VOX$hXY1_YZ2ZZ]$h]^1_^p$hpq1_qr2srs4qst5Ztu6Vuv9lvw;jwx=nxy!#yyz!$uz{!%q{|!'k|}!(m}!O!)i!O!P!+j!P!Q!/f!Q!R!7q!R![!9f![!]!La!]!^!N_!^!_# Z!_!`##b!`!a#%c!a!b#'j!b!c#(f!c!}#)b!}#O#+X#O#P#,T#P#Q#4d#Q#R#5`#R#S#)b#S#T$h#T#U#)b#U#V#6b#V#f#)b#f#g#9u#g#o#)b#o#p#?S#p#q#@O#q#r#BS#r${$h${$|#)b$|4w$h4w5b#)b5b5i$h5i6S#)b6S~$hU$oZ'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU%iT'`Q'PSOz%xz{&^{!P%x!P!Q'S!Q~%xS%}T'PSOz%xz{&^{!P%x!P!Q'S!Q~%xS&aTOz&pz{&^{!P&p!P!Q({!Q~&pS&sTOz%xz{&^{!P%x!P!Q'S!Q~%xS'VSOz&p{!P&p!P!Q'c!Q~&pS'fSOz'r{!P'r!P!Q'c!Q~'rS'uTOz(Uz{(l{!P(U!P!Q'c!Q~(US(]T'QS'PSOz(Uz{(l{!P(U!P!Q'c!Q~(US(oSOz'rz{(l{!P'r!Q~'rS)QO'QSU)VZ'`QOY)xYZ+hZr)xrs&psz)xz{)Q{!P)x!P!Q0w!Q#O)x#O#P&p#P~)xU)}Z'`QOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU*uZ'`QOY)xYZ+hZr)xrs&psz)xz{+|{!P)x!P!Q,g!Q#O)x#O#P&p#P~)xU+mT'`QOz%xz{&^{!P%x!P!Q'S!Q~%xQ,RT'`QOY+|YZ,bZr+|s#O+|#P~+|Q,gO'`QU,lZ'`QOY-_YZ0cZr-_rs'rsz-_z{+|{!P-_!P!Q,g!Q#O-_#O#P'r#P~-_U-dZ'`QOY.VYZ/RZr.Vrs(Usz.Vz{/k{!P.V!P!Q,g!Q#O.V#O#P(U#P~.VU.`Z'`Q'QS'PSOY.VYZ/RZr.Vrs(Usz.Vz{/k{!P.V!P!Q,g!Q#O.V#O#P(U#P~.VU/[T'`Q'QS'PSOz(Uz{(l{!P(U!P!Q'c!Q~(UU/pZ'`QOY-_YZ0cZr-_rs'rsz-_z{/k{!P-_!P!Q+|!Q#O-_#O#P'r#P~-_U0hT'`QOz(Uz{(l{!P(U!P!Q'c!Q~(UU1OT'`Q'QSOY+|YZ,bZr+|s#O+|#P~+|_1hZ'`Q&}X'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_2dT'`Q&}X'PSOz%xz{&^{!P%x!P!Q'S!Q~%x_2|]ZX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`#O$h#O#P%x#P~$h_4OZ#RX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_4zT'^Q'PS'_XOz%xz{&^{!P%x!P!Q'S!Q~%x_5dZ'RX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_6`g'`Q'vW'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!c$h!c!}7w!}#O$h#O#P%x#P#R$h#R#S7w#S#T$h#T#o7w#o${$h${$|7w$|4w$h4w5b7w5b5i$h5i6S7w6S~$h_8Qh'`Q_X'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![7w![!c$h!c!}7w!}#O$h#O#P%x#P#R$h#R#S7w#S#T$h#T#o7w#o${$h${$|7w$|4w$h4w5b7w5b5i$h5i6S7w6S~$h_9u](TP'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_:wZ#QX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_;s_!qX'`Q'PSOY$hYZ%bZr$hrs%xsv$hvw<rwz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_<{Z'}X'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_=ui'`Q'PSOY?dYZA`Zr?drsBdsw?dwx@dxz?dz{CO{!P?d!P!QDv!Q!c?d!c!}Et!}#O?d#O#PId#P#R?d#R#SEt#S#T?d#T#oEt#o${?d${$|Et$|4w?d4w5bEt5b5i?d5i6SEt6S~?d_?k]'`Q'PSOY$hYZ%bZr$hrs%xsw$hwx@dxz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_@mZ'`Q'PSsXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_AgV'`Q'PSOw%xwxA|xz%xz{&^{!P%x!P!Q'S!Q~%x]BTT'PSsXOz%xz{&^{!P%x!P!Q'S!Q~%x]BiV'PSOw%xwxA|xz%xz{&^{!P%x!P!Q'S!Q~%x_CT]'`QOY)xYZ+hZr)xrs&psw)xwxC|xz)xz{)Q{!P)x!P!Q0w!Q#O)x#O#P&p#P~)x_DTZ'`QsXOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_D{]'`QOY)xYZ+hZr)xrs&psw)xwxC|xz)xz{+|{!P)x!P!Q,g!Q#O)x#O#P&p#P~)x_E}j'`Q'PS'[XOY$hYZ%bZr$hrs%xsw$hwx@dxz$hz{)Q{!P$h!P!Q*p!Q![Go![!c$h!c!}Go!}#O$h#O#P%x#P#R$h#R#SGo#S#T$h#T#oGo#o${$h${$|Go$|4w$h4w5bGo5b5i$h5i6SGo6S~$h_Gxh'`Q'PS'[XOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![Go![!c$h!c!}Go!}#O$h#O#P%x#P#R$h#R#SGo#S#T$h#T#oGo#o${$h${$|Go$|4w$h4w5bGo5b5i$h5i6SGo6S~$h]IiX'PSOzBdz{JU{!PBd!P!QKS!Q#iBd#i#jKi#j#lBd#l#m!!a#m~Bd]JXVOw&pwxJnxz&pz{&^{!P&p!P!Q({!Q~&p]JsTsXOz%xz{&^{!P%x!P!Q'S!Q~%x]KVUOw&pwxJnxz&p{!P&p!P!Q'c!Q~&p]Kn['PSOz%xz{&^{!P%x!P!Q'S!Q![Ld![!c%x!c!iLd!i#T%x#T#ZLd#Z#o%x#o#pNq#p~%x]LiY'PSOz%xz{&^{!P%x!P!Q'S!Q![MX![!c%x!c!iMX!i#T%x#T#ZMX#Z~%x]M^Y'PSOz%xz{&^{!P%x!P!Q'S!Q![M|![!c%x!c!iM|!i#T%x#T#ZM|#Z~%x]NRY'PSOz%xz{&^{!P%x!P!Q'S!Q![Bd![!c%x!c!iBd!i#T%x#T#ZBd#Z~%x]NvY'PSOz%xz{&^{!P%x!P!Q'S!Q![! f![!c%x!c!i! f!i#T%x#T#Z! f#Z~%x]! k['PSOz%xz{&^{!P%x!P!Q'S!Q![! f![!c%x!c!i! f!i#T%x#T#Z! f#Z#q%x#q#rBd#r~%x]!!fY'PSOz%xz{&^{!P%x!P!Q'S!Q![!#U![!c%x!c!i!#U!i#T%x#T#Z!#U#Z~%x]!#ZY'PSOz%xz{&^{!P%x!P!Q'S!Q![Bd![!c%x!c!iBd!i#T%x#T#ZBd#Z~%x_!$SZ}X'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!%OZ!PX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!%x](QX'`QOY)xYZ+hZr)xrs&psz)xz{)Q{!P)x!P!Q0w!Q!_)x!_!`!&q!`#O)x#O#P&p#P~)x_!&xZ#QX'`QOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!'t](PX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_!(vZ!eX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!)r^'hX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`!a!*n!a#O$h#O#P%x#P~$h_!*wZ#SX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!+s[(OX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!O$h!O!P!,i!P!Q*p!Q#O$h#O#P%x#P~$h_!,r^!lX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!O$h!O!P!-n!P!Q*p!Q!_$h!_!`!.j!`#O$h#O#P%x#P~$h_!-wZ!tX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hV!.sZ'rP'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!/m]'`Q'xXOY)xYZ+hZr)xrs&psz)xz{!0f{!P)x!P!Q!0|!Q!_)x!_!`!&q!`#O)x#O#P&p#P~)x_!0mT'O]'`QOY+|YZ,bZr+|s#O+|#P~+|_!1TZ'`QUXOY!1vYZ0cZr!1vrs!4xsz!1vz{!7T{!P!1v!P!Q!0|!Q#O!1v#O#P!4x#P~!1v_!1}Z'`QUXOY!2pYZ/RZr!2prs!3nsz!2pz{!6Z{!P!2p!P!Q!0|!Q#O!2p#O#P!3n#P~!2p_!2{Z'`QUX'QS'PSOY!2pYZ/RZr!2prs!3nsz!2pz{!6Z{!P!2p!P!Q!0|!Q#O!2p#O#P!3n#P~!2p]!3wVUX'QS'PSOY!3nYZ(UZz!3nz{!4^{!P!3n!P!Q!5d!Q~!3n]!4cVUXOY!4xYZ'rZz!4xz{!4^{!P!4x!P!Q!6O!Q~!4x]!4}VUXOY!3nYZ(UZz!3nz{!4^{!P!3n!P!Q!5d!Q~!3n]!5iVUXOY!4xYZ'rZz!4xz{!6O{!P!4x!P!Q!5d!Q~!4xX!6TQUXOY!6OZ~!6O_!6bZ'`QUXOY!1vYZ0cZr!1vrs!4xsz!1vz{!6Z{!P!1v!P!Q!7T!Q#O!1v#O#P!4x#P~!1vZ!7[V'`QUXOY!7TYZ,bZr!7Trs!6Os#O!7T#O#P!6O#P~!7T_!7zhuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!9f![#O$h#O#P%x#P#R$h#R#S!9f#S#U$h#U#V!Dc#V#]$h#]#^!:w#^#c$h#c#d!F}#d#i$h#i#j!:w#j#l$h#l#m!Ic#m~$h_!9obuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!9f![#O$h#O#P%x#P#R$h#R#S!9f#S#]$h#]#^!:w#^#i$h#i#j!:w#j~$h_!;Oe'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R$h!R!S!<a!S!T$h!T!U!?c!U!W$h!W!X!@c!X!Y$h!Y!Z!>g!Z#O$h#O#P%x#P#g$h#g#h!Ac#h~$h_!<h_'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!S$h!S!T!=g!T!W$h!W!X!>g!X#O$h#O#P%x#P~$h_!=n]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y$h!Y!Z!>g!Z#O$h#O#P%x#P~$h_!>pZuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!?j]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!S$h!S!T!>g!T#O$h#O#P%x#P~$h_!@j]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!U$h!U!V!>g!V#O$h#O#P%x#P~$h_!Aj]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#]$h#]#^!Bc#^~$h_!Bj]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#n$h#n#o!Cc#o~$h_!Cj]'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P#X$h#X#Y!>g#Y~$h_!Dj_'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R!Ei!R!S!Ei!S#O$h#O#P%x#P#R$h#R#S!Ei#S~$h_!ErcuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!R!Ei!R!S!Ei!S#O$h#O#P%x#P#R$h#R#S!Ei#S#]$h#]#^!:w#^#i$h#i#j!:w#j~$h_!GU^'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y!HQ!Y#O$h#O#P%x#P#R$h#R#S!HQ#S~$h_!HZbuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!Y!HQ!Y#O$h#O#P%x#P#R$h#R#S!HQ#S#]$h#]#^!:w#^#i$h#i#j!:w#j~$h_!Ijb'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!Jr![!c$h!c!i!Jr!i#O$h#O#P%x#P#R$h#R#S!Jr#S#T$h#T#Z!Jr#Z~$h_!J{fuX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![!Jr![!c$h!c!i!Jr!i#O$h#O#P%x#P#R$h#R#S!Jr#S#T$h#T#Z!Jr#Z#]$h#]#^!:w#^#i$h#i#j!:w#j~$h_!Lj]!SX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![$h![!]!Mc!]#O$h#O#P%x#P~$h_!MlZdX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_!NhZyX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_# d^#RX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!^$h!^!_#!`!_!`3u!`#O$h#O#P%x#P~$h_#!i]'yX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_##k^oX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`!a#$g!a#O$h#O#P%x#P~$h_#$pZ#TX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#%l^#RX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`3u!`!a#&h!a#O$h#O#P%x#P~$h_#&q]'zX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#'sZ(RX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hV#(oZ'qP'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#)mh'`Q'PS!{W'UPOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![#)b![!c$h!c!}#)b!}#O$h#O#P%x#P#R$h#R#S#)b#S#T$h#T#o#)b#o${$h${$|#)b$|4w$h4w5b#)b5b5i$h5i6S#)b6S~$h_#+bZ[X'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$hU#,YX'PSOz#,uz{#-]{!P#,u!P!Q#-q!Q#i#,u#i#j#.S#j#l#,u#l#m#2z#m~#,uU#,|TrQ'PSOz%xz{&^{!P%x!P!Q'S!Q~%xU#-bTrQOz&pz{&^{!P&p!P!Q({!Q~&pU#-vSrQOz&p{!P&p!P!Q'c!Q~&pU#.X['PSOz%xz{&^{!P%x!P!Q'S!Q![#.}![!c%x!c!i#.}!i#T%x#T#Z#.}#Z#o%x#o#p#1[#p~%xU#/SY'PSOz%xz{&^{!P%x!P!Q'S!Q![#/r![!c%x!c!i#/r!i#T%x#T#Z#/r#Z~%xU#/wY'PSOz%xz{&^{!P%x!P!Q'S!Q![#0g![!c%x!c!i#0g!i#T%x#T#Z#0g#Z~%xU#0lY'PSOz%xz{&^{!P%x!P!Q'S!Q![#,u![!c%x!c!i#,u!i#T%x#T#Z#,u#Z~%xU#1aY'PSOz%xz{&^{!P%x!P!Q'S!Q![#2P![!c%x!c!i#2P!i#T%x#T#Z#2P#Z~%xU#2U['PSOz%xz{&^{!P%x!P!Q'S!Q![#2P![!c%x!c!i#2P!i#T%x#T#Z#2P#Z#q%x#q#r#,u#r~%xU#3PY'PSOz%xz{&^{!P%x!P!Q'S!Q![#3o![!c%x!c!i#3o!i#T%x#T#Z#3o#Z~%xU#3tY'PSOz%xz{&^{!P%x!P!Q'S!Q![#,u![!c%x!c!i#,u!i#T%x#T#Z#,u#Z~%x_#4mZXX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#5i]'{X'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P~$h_#6mj'`Q'PS!{W'UPOY$hYZ%bZr$hrs#8_sw$hwx#8uxz$hz{)Q{!P$h!P!Q*p!Q![#)b![!c$h!c!}#)b!}#O$h#O#P%x#P#R$h#R#S#)b#S#T$h#T#o#)b#o${$h${$|#)b$|4w$h4w5b#)b5b5i$h5i6S#)b6S~$h]#8fT'PS'_XOz%xz{&^{!P%x!P!Q'S!Q~%x_#8|]'`Q'PSOY?dYZA`Zr?drsBdsw?dwx@dxz?dz{CO{!P?d!P!QDv!Q#O?d#O#PId#P~?d_#:Qi'`Q'PS!{W'UPOY$hYZ%bZr$hrs%xst#;otz$hz{)Q{!P$h!P!Q*p!Q![#)b![!c$h!c!}#)b!}#O$h#O#P%x#P#R$h#R#S#)b#S#T$h#T#o#)b#o${$h${$|#)b$|4w$h4w5b#)b5b5i$h5i6S#)b6S~$hV#;vg'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!c$h!c!}#=_!}#O$h#O#P%x#P#R$h#R#S#=_#S#T$h#T#o#=_#o${$h${$|#=_$|4w$h4w5b#=_5b5i$h5i6S#=_6S~$hV#=hh'`Q'PS'UPOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q![#=_![!c$h!c!}#=_!}#O$h#O#P%x#P#R$h#R#S#=_#S#T$h#T#o#=_#o${$h${$|#=_$|4w$h4w5b#=_5b5i$h5i6S#=_6S~$h_#?]ZwX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#@X_'sX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q!_$h!_!`:n!`#O$h#O#P%x#P#p$h#p#q#AW#q~$h_#AaZ'|X'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h_#B]ZvX'`Q'PSOY$hYZ%bZr$hrs%xsz$hz{)Q{!P$h!P!Q*p!Q#O$h#O#P%x#P~$h",
  tokenizers: [closureParam, tpDelim, literalTokens, 0, 1, 2, 3],
  topRules: { "SourceFile": [0, 8] },
  specialized: [{ term: 282, get: (value) => spec_identifier[value] || -1 }],
  tokenPrec: 15890
});

// node_modules/@codemirror/lang-rust/dist/index.js
var rustLanguage = LezerLanguage.define({
  parser: parser.configure({
    props: [
      indentNodeProp.add({
        IfExpression: continuedIndent({ except: /^\s*({|else\b)/ }),
        "String BlockComment": () => -1,
        "Statement MatchArm": continuedIndent()
      }),
      foldNodeProp.add((type) => {
        if (/(Block|edTokens|List)$/.test(type.name))
          return foldInside;
        if (type.name == "BlockComment")
          return (tree) => ({ from: tree.from + 2, to: tree.to - 2 });
        return void 0;
      }),
      styleTags({
        "const macro_rules mod struct union enum type fn impl trait let use crate static": tags.definitionKeyword,
        "pub unsafe async mut extern default move": tags.modifier,
        "for if else loop while match continue break return await": tags.controlKeyword,
        "as in ref": tags.operatorKeyword,
        "where _ crate super dyn": tags.keyword,
        "self": tags.self,
        String: tags.string,
        RawString: tags.special(tags.string),
        Boolean: tags.bool,
        Identifier: tags.variableName,
        "CallExpression/Identifier": tags.function(tags.variableName),
        BoundIdentifier: tags.definition(tags.variableName),
        LoopLabel: tags.labelName,
        FieldIdentifier: tags.propertyName,
        "CallExpression/FieldExpression/FieldIdentifier": tags.function(tags.propertyName),
        Lifetime: tags.special(tags.variableName),
        ScopeIdentifier: tags.namespace,
        TypeIdentifier: tags.typeName,
        "MacroInvocation/Identifier MacroInvocation/ScopedIdentifier/Identifier": tags.macroName,
        "MacroInvocation/TypeIdentifier MacroInvocation/ScopedIdentifier/TypeIdentifier": tags.macroName,
        '"!"': tags.macroName,
        UpdateOp: tags.updateOperator,
        LineComment: tags.lineComment,
        BlockComment: tags.blockComment,
        Integer: tags.integer,
        Float: tags.float,
        ArithOp: tags.arithmeticOperator,
        LogicOp: tags.logicOperator,
        BitOp: tags.bitwiseOperator,
        CompareOp: tags.compareOperator,
        "=": tags.definitionOperator,
        ".. ... => ->": tags.punctuation,
        "( )": tags.paren,
        "[ ]": tags.squareBracket,
        "{ }": tags.brace,
        ".": tags.derefOperator,
        "&": tags.operator,
        ", ; ::": tags.separator
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:\{|\})$/
  }
});
function rust() {
  return new LanguageSupport(rustLanguage);
}

// src/slicer.tsx
var import_react7 = __toModule(require_react());
var import_axios = __toModule(require_axios2());
var SliceListing = ({ code }) => {
  let [editor, set_editor] = (0, import_react7.useState)(null);
  let get_slice = async (range) => {
    editor.dispatch({ effects: clear_highlights.of(null) });
    let program = editor.state.doc.toJSON().join("\n");
    let start2 = pos_to_linecol(editor, range[0]);
    let end = pos_to_linecol(editor, range[1]);
    if (start2.line != end.line) {
      throw "Start line different from end line";
    }
    let request = { program, line: start2.line, start: start2.col, end: end.col };
    let response = await import_axios.default.post("http://charlotte.stanford.edu:8889", request);
    let ranges = response.data.ranges;
    editor.dispatch({
      effects: ranges.filter((range2) => range2.filename.includes("main.rs")).filter((range2) => !(range2.start_line == request.line && range2.start_col == request.start)).map((range2) => {
        let from = linecol_to_pos(editor, {
          line: range2.start_line,
          col: range2.start_col
        });
        let to = linecol_to_pos(editor, {
          line: range2.end_line,
          col: range2.end_col
        });
        return add_highlight.of({ from, to, color: "peach" });
      })
    });
    editor.dispatch({
      effects: [
        add_highlight.of({
          from: range[0],
          to: range[1],
          color: "forest-green"
        })
      ]
    });
  };
  return /* @__PURE__ */ import_react7.default.createElement("div", null, /* @__PURE__ */ import_react7.default.createElement(Listing, {
    editable: true,
    code,
    extensions: [
      EditorView.updateListener.of((update) => {
        if (update.docChanged) {
          editor.dispatch({ effects: clear_highlights.of(null) });
        }
      })
    ],
    onLoad: (e) => {
      editor = e;
      set_editor(e);
    },
    delimiters: {
      delimiters: [["@", "@"]],
      onParse: ([range]) => {
        get_slice(range);
      }
    }
  }), /* @__PURE__ */ import_react7.default.createElement("button", {
    onClick: () => {
      let selection = editor.state.selection;
      let range = selection.main;
      if (!range.empty) {
        get_slice([range.from, range.to]);
      }
    }
  }, "Slice"));
};

// src/example.bib
var example_default = `@inproceedings{horwitz1988interprocedural,
  title={Interprocedural slicing using dependence graphs},
  author={Horwitz, Susan and Reps, Thomas and Binkley, David},
  booktitle={Proceedings of the ACM SIGPLAN 1988 conference on Programming Language design and Implementation},
  pages={35--46},
  year={1988}
}

@article{ferrante1987program,
  title={The program dependence graph and its use in optimization},
  author={Ferrante, Jeanne and Ottenstein, Karl J and Warren, Joe D},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={9},
  number={3},
  pages={319--349},
  year={1987},
  publisher={ACM New York, NY, USA}
}

@article{cooper2001simple,
  title={A simple, fast dominance algorithm},
  author={Cooper, Keith D and Harvey, Timothy J and Kennedy, Ken},
  journal={Software Practice \\& Experience},
  volume={4},
  number={1-10},
  pages={1--8},
  year={2001}
}

@article{weiser1984program,
  title={Program slicing},
  author={Weiser, Mark},
  journal={IEEE Transactions on software engineering},
  number={4},
  pages={352--357},
  year={1984},
  publisher={IEEE}
}

@article{weiser1982programmers,
  title={Programmers use slices when debugging},
  author={Weiser, Mark},
  journal={Communications of the ACM},
  volume={25},
  number={7},
  pages={446--452},
  year={1982},
  publisher={ACM New York, NY, USA}
}

@article{xu2005brief,
  title={A brief survey of program slicing},
  author={Xu, Baowen and Qian, Ju and Zhang, Xiaofang and Wu, Zhongqiang and Chen, Lin},
  journal={ACM SIGSOFT Software Engineering Notes},
  volume={30},
  number={2},
  pages={1--36},
  year={2005},
  publisher={ACM New York, NY, USA}
}

@article{silva2012vocabulary,
  title={A vocabulary of program slicing-based techniques},
  author={Silva, Josep},
  journal={ACM computing surveys (CSUR)},
  volume={44},
  number={3},
  pages={1--41},
  year={2012},
  publisher={ACM New York, NY, USA}
}

@inproceedings{parnin2011automated,
  title={Are automated debugging techniques actually helping programmers?},
  author={Parnin, Chris and Orso, Alessandro},
  booktitle={Proceedings of the 2011 international symposium on software testing and analysis},
  pages={199--209},
  year={2011}
}

@inproceedings{cuoq2012frama,
  title={Frama-c},
  author={Cuoq, Pascal and Kirchner, Florent and Kosmatov, Nikolai and Prevosto, Virgile and Signoles, Julien and Yakobowski, Boris},
  booktitle={International conference on software engineering and formal methods},
  pages={233--247},
  year={2012},
  organization={Springer}
}

@inproceedings{balakrishnan2005codesurfer,
  title={Codesurfer/x86\u2014a platform for analyzing x86 executables},
  author={Balakrishnan, Gogul and Gruian, Radu and Reps, Thomas and Teitelbaum, Tim},
  booktitle={International Conference on Compiler Construction},
  pages={250--254},
  year={2005},
  organization={Springer}
}

@inproceedings{zhao2018parallel,
  title={Parallel sparse flow-sensitive points-to analysis},
  author={Zhao, Jisheng and Burke, Michael G and Sarkar, Vivek},
  booktitle={Proceedings of the 27th International Conference on Compiler Construction},
  pages={59--70},
  year={2018}
}

@inproceedings{might2010resolving,
  title={Resolving and exploiting the k-CFA paradox: illuminating functional vs. object-oriented program analysis},
  author={Might, Matthew and Smaragdakis, Yannis and Van Horn, David},
  booktitle={Proceedings of the 31st ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages={305--315},
  year={2010}
}

@inproceedings{clarke1998ownership,
  title={Ownership types for flexible alias protection},
  author={Clarke, David G and Potter, John M and Noble, James},
  booktitle={Proceedings of the 13th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications},
  pages={48--64},
  year={1998}
}

@inproceedings{grossman2002region,
  title={Region-based memory management in Cyclone},
  author={Grossman, Dan and Morrisett, Greg and Jim, Trevor and Hicks, Michael and Wang, Yanling and Cheney, James},
  booktitle={Proceedings of the ACM SIGPLAN 2002 Conference on Programming language design and implementation},
  pages={282--293},
  year={2002}
}

@inproceedings{agrawal2001evaluating,
  title={Evaluating explicitly context-sensitive program slicing},
  author={Agrawal, Gagan and Guo, Liang},
  booktitle={Proceedings of the 2001 ACM SIGPLAN-SIGSOFT workshop on Program analysis for software tools and engineering},
  pages={6--12},
  year={2001}
}

@article{girard1987linear,
  title={Linear logic},
  author={Girard, Jean-Yves},
  journal={Theoretical computer science},
  volume={50},
  number={1},
  pages={1--101},
  year={1987},
  publisher={Elsevier}
}

@article{weiss2019oxide,
  title={Oxide: The essence of rust},
  author={Weiss, Aaron and Gierczak, Olek and Patterson, Daniel and Matsakis, Nicholas D and Ahmed, Amal},
  journal={arXiv preprint arXiv:1903.00982},
  year={2019}
}

@inproceedings{rountev1999data,
  title={Data-flow analysis of program fragments},
  author={Rountev, Atanas and Ryder, Barbara G and Landi, William},
  booktitle={Software Engineering\u2014ESEC/FSE\u201999},
  pages={235--252},
  year={1999},
  organization={Springer}
}

@inproceedings{cousot2002modular,
  title={Modular static program analysis},
  author={Cousot, Patrick and Cousot, Radhia},
  booktitle={International Conference on Compiler Construction},
  pages={159--179},
  year={2002},
  organization={Springer}
}

@inproceedings{gulwani2007computing,
  title={Computing procedure summaries for interprocedural analysis},
  author={Gulwani, Sumit and Tiwari, Ashish},
  booktitle={European Symposium on Programming},
  pages={253--267},
  year={2007},
  organization={Springer}
}

@inproceedings{yorsh2008generating,
  title={Generating precise and concise procedure summaries},
  author={Yorsh, Greta and Yahav, Eran and Chandra, Satish},
  booktitle={Proceedings of the 35th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages={221--234},
  year={2008}
}

@book{sharir1978two,
  title={Two approaches to interprocedural data flow analysis},
  author={Sharir, Micha and Pnueli, Amir and others},
  year={1978},
  publisher={New York University. Courant Institute of Mathematical Sciences}
}

@inproceedings{tang2015summary,
  title={Summary-based context-sensitive data-dependence analysis in presence of callbacks},
  author={Tang, Hao and Wang, Xiaoyin and Zhang, Lingming and Xie, Bing and Zhang, Lu and Mei, Hong},
  booktitle={Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages={83--95},
  year={2015}
}

@inproceedings{madhavan2012modular,
  title={Modular heap analysis for higher-order programs},
  author={Madhavan, Ravichandhran and Ramalingam, Ganesan and Vaswani, Kapil},
  booktitle={International Static Analysis Symposium},
  pages={370--387},
  year={2012},
  organization={Springer}
}
 
@inproceedings{wadler1989theorems,
  title={Theorems for free!},
  author={Wadler, Philip},
  booktitle={Proceedings of the fourth international conference on Functional programming languages and computer architecture},
  pages={347--359},
  year={1989}
}

@article{tofte1997region,
  title={Region-based memory management},
  author={Tofte, Mads and Talpin, Jean-Pierre},
  journal={Information and computation},
  volume={132},
  number={2},
  pages={109--176},
  year={1997},
  publisher={Elsevier}
}

@misc{nllrfc,
    author={Niko Matsakis},
    title={Non-lexical lifetimes},
    year={2017},
    url={https://rust-lang.github.io/rfcs/2094-nll.html}
}

@misc{polonius,
  author={Niko Matsakis},
  title={An alias-based formulation of the borrow checker},
  year={2018},
  url={http://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker}
}

@article{jung2017rustbelt,
  title={RustBelt: Securing the foundations of the Rust programming language},
  author={Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
  journal={Proceedings of the ACM on Programming Languages},
  volume={2},
  number={POPL},
  pages={1--34},
  year={2017},
  publisher={ACM New York, NY, USA}
}

@book{appel1997modern,
  title={Modern Compiler Implementation in ML},
  author={Appel, Andrew W},
  year={1997},
  publisher={Cambridge University Press}
}

@misc{mirguide,
    title={The MIR (Mid-level IR) - Guide to Rustc Development},
    year={2021},
    url={https://rustc-dev-guide.rust-lang.org/mir/index.html},
}

@inproceedings{cytron1989efficient,
  title={An efficient method of computing static single assignment form},
  author={Cytron, Ron and Ferrante, Jeanne and Rosen, Barry K and Wegman, Mark N and Zadeck, F Kenneth},
  booktitle={Proceedings of the 16th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages={25--35},
  year={1989}
}

@misc{cloc,
    title={cloc: Count Lines of Code},
    author={Al Danial},
    year={2021},
    url={https://github.com/AlDanial/cloc}
}

@mastersthesis{llvmslicer,
 author={Marek Chalupa},
 title = {Slicing of LLVM bitcode},
 school = {Masaryk University},
 year = {2016},
} 

@inproceedings{jayaraman2005kaveri,
  title={Kaveri: Delivering the indus java program slicer to eclipse},
  author={Jayaraman, Ganeshan and Ranganath, Venkatesh Prasad and Hatcliff, John},
  booktitle={International Conference on Fundamental Approaches to Software Engineering},
  pages={269--272},
  year={2005},
  organization={Springer}
}

@inproceedings{abadi1999core,
  title={A core calculus of dependency},
  author={Abadi, Mart{\\'\\i}n and Banerjee, Anindya and Heintze, Nevin and Riecke, Jon G},
  booktitle={Proceedings of the 26th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages={147--160},
  year={1999}
}

@phdthesis{andersen1994program,
  title={Program analysis and specialization for the C programming language},
  author={Andersen, Lars Ole},
  year={1994},
  school={Citeseer}
}

@inproceedings{steensgaard1996points,
  title={Points-to analysis in almost linear time},
  author={Steensgaard, Bjarne},
  booktitle={Proceedings of the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages={32--41},
  year={1996}
}

@article{pottier2003information,
  title={Information flow inference for ML},
  author={Pottier, Fran{\\c{c}}ois and Simonet, Vincent},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={25},
  number={1},
  pages={117--158},
  year={2003},
  publisher={ACM New York, NY, USA}
}

@inproceedings{campbell2018cognitive,
  title={Cognitive complexity: An overview and evaluation},
  author={Campbell, G Ann},
  booktitle={Proceedings of the 2018 international conference on technical debt},
  pages={57--58},
  year={2018}
}

@article{smaragdakis2015pointer,
  title={Pointer analysis},
  author={Smaragdakis, Yannis and Balatsouras, George},
  journal={Foundations and Trends in Programming Languages},
  volume={2},
  number={1},
  pages={1--69},
  year={2015},
  publisher={Now Publishers Inc. Hanover, MA, USA}
}

@article{astrauskas2019leveraging,
  title={Leveraging Rust types for modular specification and verification},
  author={Astrauskas, Vytautas and M{\\"u}ller, Peter and Poli, Federico and Summers, Alexander J},
  journal={Proceedings of the ACM on Programming Languages},
  volume={3},
  number={OOPSLA},
  pages={1--30},
  year={2019},
  publisher={ACM New York, NY, USA}
}

@article{jung2020stacked,
  title={Stacked borrows: an aliasing model for Rust},
  author={Jung, Ralf and Dang, Hoang-Hai and Kang, Jeehoon and Dreyer, Derek},
  journal={Proceedings of the ACM on Programming Languages},
  volume={4},
  number={POPL},
  pages={1--32},
  year={2020},
  publisher={ACM New York, NY, USA}
}

@article{astrauskas2020programmers,
  title={How do programmers use unsafe rust?},
  author={Astrauskas, Vytautas and Matheja, Christoph and Poli, Federico and M{\\"u}ller, Peter and Summers, Alexander J},
  journal={Proceedings of the ACM on Programming Languages},
  volume={4},
  number={OOPSLA},
  pages={1--27},
  year={2020},
  publisher={ACM New York, NY, USA}
}

@article{dillig2011precise,
  title={Precise and compact modular procedure summaries for heap manipulating programs},
  author={Dillig, Isil and Dillig, Thomas and Aiken, Alex and Sagiv, Mooly},
  journal={ACM SIGPLAN Notices},
  volume={46},
  number={6},
  pages={567--577},
  year={2011},
  publisher={ACM New York, NY, USA}
}`;

// src/index.tsx
var r = String.raw;
var C2 = (props) => /* @__PURE__ */ import_react8.default.createElement("code", {
  ...props
});
var App = (_4) => /* @__PURE__ */ import_react8.default.createElement(Document, {
  bibtex: example_default
}, /* @__PURE__ */ import_react8.default.createElement(ListingConfigure, {
  language: rust()
}), /* @__PURE__ */ import_react8.default.createElement(Title, null, "Modular Program Slicing Through Ownership"), /* @__PURE__ */ import_react8.default.createElement(Authors, null, /* @__PURE__ */ import_react8.default.createElement(Author, null, /* @__PURE__ */ import_react8.default.createElement(Name, {
  value: "Will Crichton"
}), /* @__PURE__ */ import_react8.default.createElement(Affiliation, null, /* @__PURE__ */ import_react8.default.createElement(Institution, {
  value: "Stanford University"
})))), /* @__PURE__ */ import_react8.default.createElement(Abstract, null, "Program slicing, or identifying the subset of a program relevant to a value, relies on understanding the dataflow of a program. In languages with mutable pointers and functions like C or Java, tracking dataflow has historically required whole-program analysis, which can be be slow and challenging to integrate in practice. Advances in type systems have shown how to modularly track dataflow through the concept of ownership. We demonstrate that ownership can modularize program slicing by using types to compute a provably sound and reasonably precise approximation of mutation. We present an algorithm for slicing Oxide, a formalized ownership-based language, and prove the algorithm's soundness as a form of noninterference. Then we describe an implementation of the algorithm for the Rust programming language, and show empirically that modular slices are the same as whole-program slices in 95.4% of slices drawn from large Rust codebases."), /* @__PURE__ */ import_react8.default.createElement(Section, {
  title: "Introduction"
}, /* @__PURE__ */ import_react8.default.createElement("p", null, "Program slicing is the task of identifying the subset of a program relevant to computing a value of interest. The concept of slicing was introduced 40 years ago when ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  f: true,
  v: "weiser1982programmers"
}), " ", "demonstrated that programmers mentally construct slices while debugging. Since then, hundreds of papers have been published on implementing automated program slice, as surveyed by", " ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  f: true,
  v: ["xu2005brief", "silva2012vocabulary"]
}), '. Despite these efforts, a review of slicers found "slicing-based debugging techniques are rarely used in practice" ', /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "parnin2011automated"
}), /* @__PURE__ */ import_react8.default.createElement(Footnote, null, "The only open-source, functioning slicers the authors could find are Frama-C ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "cuoq2012frama"
}), " and dg ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "llvmslicer"
}), ". Slicing tools for Java like Kaveri ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "jayaraman2005kaveri"
}), " no longer work. The most industrial-strength slicing tool, CodeSurfer", " ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "balakrishnan2005codesurfer"
}), " was GrammaTech's proprietary technology and appears to no longer exist."), "."), /* @__PURE__ */ import_react8.default.createElement("p", null, "A major challenge for slicing is addressing the underlying program analysis problems. At a high level, slicing is about dataflow --- if", " ", /* @__PURE__ */ import_react8.default.createElement($, null, "x"), " is relevant, then any means by which data flows into ", /* @__PURE__ */ import_react8.default.createElement($, null, "x"), " ", "are also relevant. In today's programming languages, analyzing dataflow is difficult because of the interaction of two features: functions and pointers. For example, imagine slicing a value in a function ", /* @__PURE__ */ import_react8.default.createElement($, null, "f"), " ", "which calls a function ", /* @__PURE__ */ import_react8.default.createElement($, null, "g"), ". In a language without side-effects, then the only relevance ", /* @__PURE__ */ import_react8.default.createElement($, null, "g"), " could possibly have in ", /* @__PURE__ */ import_react8.default.createElement($, null, "f"), " is its return value. But in a language that allows effects such as mutation on pointers, ", /* @__PURE__ */ import_react8.default.createElement($, null, "g"), " could modify data used within ", /* @__PURE__ */ import_react8.default.createElement($, null, "f"), ", requiring a pointer analysis. Moreover, if ", /* @__PURE__ */ import_react8.default.createElement($, null, "f"), " is a higher-order function parameterized on ", /* @__PURE__ */ import_react8.default.createElement($, null, "g"), ", then the slice must consider all the possible functions that ", /* @__PURE__ */ import_react8.default.createElement($, null, "g"), " could be, i.e. control-flow analysis."), /* @__PURE__ */ import_react8.default.createElement("p", null, "The standard solution for analyzing programs with pointers and functions is ", /* @__PURE__ */ import_react8.default.createElement("em", null, "whole-program analysis"), ". That is, for a given function of interest, analyze the definitions of all of the function's callers and callees in the current codebase. However, whole-program analysis suffers from a few logistical and conceptual issues:"), /* @__PURE__ */ import_react8.default.createElement("ul", null, /* @__PURE__ */ import_react8.default.createElement("li", null, /* @__PURE__ */ import_react8.default.createElement("em", null, "Analysis time scales with the size of the whole program:"), " the time complexity of whole-program analysis scales either polynomially or exponentially with the number of call sites in the program, depending on context-sensitivity ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "might2010resolving"
}), ". In practice, this means more complex codebases can take substantially longer to analyze. For instance, the recent PSEGPT pointer analysis tool ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "zhao2018parallel"
}), " takes 1 second on a codebase of 282,000 lines of code and 3 minutes on a codebase of 2.2 million lines of code."), /* @__PURE__ */ import_react8.default.createElement("li", null, /* @__PURE__ */ import_react8.default.createElement("em", null, "Analysis requires access to source code for the whole program:"), " ", "an assumption of analyzing a whole program is that a whole program is actually accessible. However, many programs use libraries that are shipped as pre-compiled objects with no source code, either for reasons of efficiency or intellectual property."), /* @__PURE__ */ import_react8.default.createElement("li", null, /* @__PURE__ */ import_react8.default.createElement("em", null, "Analysis results are anti-modular:"), " when analyzing a particular function, relying on calling contexts to analyze the function's inputs means that any results are not universal.")), /* @__PURE__ */ import_react8.default.createElement("p", null, "Calling-context-sensitive analysis determine whether two pointers alias", " ", /* @__PURE__ */ import_react8.default.createElement("em", null, "in the context of the broader codebase"), ", so alias analysis results can change due to modifications in code far away from the current module."), /* @__PURE__ */ import_react8.default.createElement("p", null, "These issues are not new --- ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "rountev1999data",
  f: true
}), " and", " ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "cousot2002modular",
  f: true
}), " observed the same two decades ago when arguing for modular static analysis. The key insight arising from their research is that static analysis can be modularized by computing", " ", /* @__PURE__ */ import_react8.default.createElement("em", null, "symbolic procedure summaries"), ". For instance,", " ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "yorsh2008generating",
  f: true
}), " show how to automatically summarize which inputs and outputs are possibly null for a given Java function. The analysis is modular because a function's summary can be computed only given the summaries, and not definitions, of callees in the function. In such prior work, the language of symbolic procedure summaries has been defined in a separate formal system from the programming language being analyzed, such as the micro-transformer framework of ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "yorsh2008generating",
  f: true
}), "."), /* @__PURE__ */ import_react8.default.createElement("p", null, "Our work begins with the observation:", " ", /* @__PURE__ */ import_react8.default.createElement("em", null, "function type signatures are symbolic procedure summaries"), ". The more expressive a language's type system, the more behavior that can be summarized by a type. Nearly all work on program slicing, dataflow analysis, and procedure summaries has operated on C, Java, or equivalents. These languages have impoverished type systems, and so any interesting static analysis requires a standalone abstract interpreter. However, if a language's type system were expressive enough to encode information about dataflow, then a function's type signature could be used to reason about the aliasing and side effects needed for slicing. Moreover, a function's type signature is required information for a compiler to export when building a library. Using the type system for dataflow analysis therefore obviates the logistical challenge of integrating an external analysis tool into a complex build system."), /* @__PURE__ */ import_react8.default.createElement("p", null, "Today, the primary technique for managing dataflow with types is", " ", /* @__PURE__ */ import_react8.default.createElement("em", null, "ownership"), ". Ownership is a concept that has emerged from several intersecting lines of research on linear logic", " ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "girard1987linear"
}), ", class-based alias management", " ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "clarke1998ownership"
}), ", and region-based memory management", " ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "grossman2002region"
}), ". Generally, ownership refers to a system where values are owned by an entity, which can temporarily or permanently transfer ownership to other entities. The type system then statically tracks the flow of ownership between entities. Ownership-based type systems enforce the invariant that values are not simultaneously aliased and mutated, either for the purposes of avoiding memory errors, data races, or abstraction violations."), /* @__PURE__ */ import_react8.default.createElement("p", null, "Our thesis is that ownership can modularize program slicing by using types to compute a provably sound and reasonably precise approximation of the necessary dataflow information. We build this thesis in five parts:"), /* @__PURE__ */ import_react8.default.createElement("ol", null, /* @__PURE__ */ import_react8.default.createElement("li", null, "We provide an intuition for the relationship between ownership and slicing by describing how ownership works in Rust, the only industrial-grade ownership-based programming language today (", /* @__PURE__ */ import_react8.default.createElement(Ref, {
  label: "sec:background"
}), ")."), /* @__PURE__ */ import_react8.default.createElement("li", null, "We formalize an algorithm for modular static slicing as an extension to the type system of Oxide ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "weiss2019oxide"
}), ", a formal model of Rust's static and dynamic semantics (", /* @__PURE__ */ import_react8.default.createElement(Ref, {
  label: "sec:model"
}), " and ", /* @__PURE__ */ import_react8.default.createElement(Ref, {
  label: "sec:algorithm"
}), ")."), /* @__PURE__ */ import_react8.default.createElement("li", null, "We prove the soundness of this algorithm as a form of noninterference, building on the connection between slicing and information flow established by ", /* @__PURE__ */ import_react8.default.createElement(Cite, {
  v: "abadi1999core",
  f: true
}), " (", /* @__PURE__ */ import_react8.default.createElement(Ref, {
  label: "sec:soundness"
}), " and ", /* @__PURE__ */ import_react8.default.createElement(Ref, {
  label: "sec:appendix"
}), ")."), /* @__PURE__ */ import_react8.default.createElement("li", null, "We describe an implementation of the slicing algorithm for Rust, translating the core insights of the algorithm to work on a lower-level control-flow graph (", /* @__PURE__ */ import_react8.default.createElement(Ref, {
  label: "sec:implementation"
}), ")"), /* @__PURE__ */ import_react8.default.createElement("li", null, "We evaluate the precision of the modular Rust slicer against a whole-program slicer on a dataset of 10 codebases with a total of 280k LOC. We find that modular slices are the same size as whole-program slices 95.4% of the time, and are on average 7.6% larger in the remaining 4.6% of cases (", /* @__PURE__ */ import_react8.default.createElement(Ref, {
  label: "sec:evaluation"
}), ")."))), /* @__PURE__ */ import_react8.default.createElement(Section, {
  title: "Principles",
  label: "sec:background"
}, /* @__PURE__ */ import_react8.default.createElement("p", null, "A backwards static slice is the subset of a program that could influence a particular value (backwards) under any possible execution (static). A slice is defined with respect to a slicing criterion, which is a variable at a particular point in a program. In this section, we provide an intuition for how slices interact with different features of the Rust programming language, namely: places (", /* @__PURE__ */ import_react8.default.createElement(Ref, {
  label: "sec:places"
}), "), references (", /* @__PURE__ */ import_react8.default.createElement(Ref, {
  label: "sec:pointers"
}), "), function calls (", /* @__PURE__ */ import_react8.default.createElement(Ref, {
  label: "sec:funcalls"
}), "), and interior mutability (", /* @__PURE__ */ import_react8.default.createElement(Ref, {
  label: "sec:intmut"
}), ").", " "), /* @__PURE__ */ import_react8.default.createElement(Section, {
  title: "Places",
  label: "sec:places"
}, /* @__PURE__ */ import_react8.default.createElement(Wrap, {
  align: "right"
}, /* @__PURE__ */ import_react8.default.createElement(SliceListing, {
  code: `let mut x = 1;
let y = 2;
let z = 3;
x = y;
println!("{}", @x@);`
})), /* @__PURE__ */ import_react8.default.createElement("p", null, "A place is a reference to a concrete piece of data in memory, like a variable ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "x"), " or path into a data structure ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "x.field"), ". Slices on places are defined by bindings, mutation, and control flow."), /* @__PURE__ */ import_react8.default.createElement("p", null, "For instance, the Rust snippet on the right shows the slice in orange of a place in green. The assignment ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "x = y"), " means ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "y"), " is relevant for the slice, so the statement ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "let y = 2"), " is relevant as well. Because ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "z"), " is not used in the computation of ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "x"), ", then ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "let z = 3"), ". is not relevant. Additionally, because", " ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "x = y"), " overwrites the previous value of ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "x"), ", then the original assignment ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "x = 1"), " is not relevant either."), /* @__PURE__ */ import_react8.default.createElement(Wrap, {
  align: "left"
}, /* @__PURE__ */ import_react8.default.createElement(SliceListing, {
  code: `let mut x = 1;
let mut y = 2;
if y > 0 { x = 3; } 
else     { y = 4; }
println!("{}", @x@);`
})), /* @__PURE__ */ import_react8.default.createElement("p", null, "If a mutation is conditioned on a predicate (as in line 3 in the snippet on the left) then the predicate is relevant to the mutated place. In this example, because ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "x = 3"), " is only executed if", " ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "y > 0"), ", then the value of ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "y"), " (at the time-of-check) is relevant to the value of ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "x"), "."), /* @__PURE__ */ import_react8.default.createElement("p", null, "Slices on composite data structures are defined by whether a mutation conflicts with a particular path into the data structure. For example, consider slicing on a tuple as in the three snippets below (note that", " ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "t.n"), " gets the ", /* @__PURE__ */ import_react8.default.createElement($, null, "n"), "-th field of the tuple ", /* @__PURE__ */ import_react8.default.createElement(C2, null, "t"), "):"))));
import_react_dom.default.render(/* @__PURE__ */ import_react8.default.createElement(App, null), document.getElementById("container"));
export {
  App
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=index.js.map
